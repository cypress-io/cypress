diff --git a/node_modules/devtools-protocol/types/protocol-mapping.d.ts b/node_modules/devtools-protocol/types/protocol-mapping.d.ts
index 6004a4b..9102022 100644
--- a/node_modules/devtools-protocol/types/protocol-mapping.d.ts
+++ b/node_modules/devtools-protocol/types/protocol-mapping.d.ts
@@ -92,6 +92,15 @@ export namespace ProtocolMapping {
          * call).
          */
         'Runtime.inspectRequested': [Protocol.Runtime.InspectRequestedEvent];
+        /**
+         * The loadComplete event mirrors the load complete event sent by the browser to assistive
+         * technology when the web page has finished loading.
+         */
+        'Accessibility.loadComplete': [Protocol.Accessibility.LoadCompleteEvent];
+        /**
+         * The nodesUpdated event is sent every time a previously requested node has changed the in tree.
+         */
+        'Accessibility.nodesUpdated': [Protocol.Accessibility.NodesUpdatedEvent];
         /**
          * Event for when an animation has been cancelled.
          */
@@ -104,9 +113,15 @@ export namespace ProtocolMapping {
          * Event for animation that has been started.
          */
         'Animation.animationStarted': [Protocol.Animation.AnimationStartedEvent];
-        'ApplicationCache.applicationCacheStatusUpdated': [Protocol.ApplicationCache.ApplicationCacheStatusUpdatedEvent];
-        'ApplicationCache.networkStateUpdated': [Protocol.ApplicationCache.NetworkStateUpdatedEvent];
+        /**
+         * Event for animation that has been updated.
+         */
+        'Animation.animationUpdated': [Protocol.Animation.AnimationUpdatedEvent];
         'Audits.issueAdded': [Protocol.Audits.IssueAddedEvent];
+        /**
+         * Emitted when an address form is filled.
+         */
+        'Autofill.addressFormFilled': [Protocol.Autofill.AddressFormFilledEvent];
         /**
          * Called when the recording state for the service has been updated.
          */
@@ -126,7 +141,7 @@ export namespace ProtocolMapping {
         'Browser.downloadProgress': [Protocol.Browser.DownloadProgressEvent];
         /**
          * Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
-         * web font
+         * web font.
          */
         'CSS.fontsUpdated': [Protocol.CSS.FontsUpdatedEvent];
         /**
@@ -196,6 +211,10 @@ export namespace ProtocolMapping {
          * Called when a pseudo element is added to an element.
          */
         'DOM.pseudoElementAdded': [Protocol.DOM.PseudoElementAddedEvent];
+        /**
+         * Called when top layer elements are changed.
+         */
+        'DOM.topLayerElementsUpdated': [];
         /**
          * Called when a pseudo element is removed from an element.
          */
@@ -222,12 +241,6 @@ export namespace ProtocolMapping {
          * Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
          */
         'Emulation.virtualTimeBudgetExpired': [];
-        /**
-         * Issued when the target starts or stops needing BeginFrames.
-         * Deprecated. Issue beginFrame unconditionally instead and use result from
-         * beginFrame to detect whether the frames were suppressed.
-         */
-        'HeadlessExperimental.needsBeginFramesChanged': [Protocol.HeadlessExperimental.NeedsBeginFramesChangedEvent];
         /**
          * Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to
          * restore normal drag and drop behavior.
@@ -346,6 +359,12 @@ export namespace ProtocolMapping {
          * it, and responseReceivedExtraInfo may be fired before or after responseReceived.
          */
         'Network.responseReceivedExtraInfo': [Protocol.Network.ResponseReceivedExtraInfoEvent];
+        /**
+         * Fired when 103 Early Hints headers is received in addition to the common response.
+         * Not every responseReceived event will have an responseReceivedEarlyHints fired.
+         * Only one responseReceivedEarlyHints may be fired for eached responseReceived event.
+         */
+        'Network.responseReceivedEarlyHints': [Protocol.Network.ResponseReceivedEarlyHintsEvent];
         /**
          * Fired exactly once for each Trust Token operation. Depending on
          * the type of the operation and whether the operation succeeded or
@@ -353,6 +372,10 @@ export namespace ProtocolMapping {
          * or after the response was received.
          */
         'Network.trustTokenOperationDone': [Protocol.Network.TrustTokenOperationDoneEvent];
+        /**
+         * Fired once security policy has been updated.
+         */
+        'Network.policyUpdated': [];
         /**
          * Fired once when parsing the .wbn file has succeeded.
          * The event contains the information about the web bundle contents.
@@ -377,6 +400,7 @@ export namespace ProtocolMapping {
          */
         'Network.reportingApiReportAdded': [Protocol.Network.ReportingApiReportAddedEvent];
         'Network.reportingApiReportUpdated': [Protocol.Network.ReportingApiReportUpdatedEvent];
+        'Network.reportingApiEndpointsChangedForOrigin': [Protocol.Network.ReportingApiEndpointsChangedForOriginEvent];
         /**
          * Fired when the node should be inspected. This happens after call to `setInspectMode` or when
          * user manually inspects an element.
@@ -519,7 +543,7 @@ export namespace ProtocolMapping {
          */
         'Security.visibleSecurityStateChanged': [Protocol.Security.VisibleSecurityStateChangedEvent];
         /**
-         * The security state of the page changed.
+         * The security state of the page changed. No longer being sent.
          */
         'Security.securityStateChanged': [Protocol.Security.SecurityStateChangedEvent];
         'ServiceWorker.workerErrorReported': [Protocol.ServiceWorker.WorkerErrorReportedEvent];
@@ -541,6 +565,32 @@ export namespace ProtocolMapping {
          * The origin's IndexedDB database list has been modified.
          */
         'Storage.indexedDBListUpdated': [Protocol.Storage.IndexedDBListUpdatedEvent];
+        /**
+         * One of the interest groups was accessed. Note that these events are global
+         * to all targets sharing an interest group store.
+         */
+        'Storage.interestGroupAccessed': [Protocol.Storage.InterestGroupAccessedEvent];
+        /**
+         * An auction involving interest groups is taking place. These events are
+         * target-specific.
+         */
+        'Storage.interestGroupAuctionEventOccurred': [Protocol.Storage.InterestGroupAuctionEventOccurredEvent];
+        /**
+         * Specifies which auctions a particular network fetch may be related to, and
+         * in what role. Note that it is not ordered with respect to
+         * Network.requestWillBeSent (but will happen before loadingFinished
+         * loadingFailed).
+         */
+        'Storage.interestGroupAuctionNetworkRequestCreated': [Protocol.Storage.InterestGroupAuctionNetworkRequestCreatedEvent];
+        /**
+         * Shared storage was accessed by the associated page.
+         * The following parameters are included in all events.
+         */
+        'Storage.sharedStorageAccessed': [Protocol.Storage.SharedStorageAccessedEvent];
+        'Storage.storageBucketCreatedOrUpdated': [Protocol.Storage.StorageBucketCreatedOrUpdatedEvent];
+        'Storage.storageBucketDeleted': [Protocol.Storage.StorageBucketDeletedEvent];
+        'Storage.attributionReportingSourceRegistered': [Protocol.Storage.AttributionReportingSourceRegisteredEvent];
+        'Storage.attributionReportingTriggerRegistered': [Protocol.Storage.AttributionReportingTriggerRegisteredEvent];
         /**
          * Issued when attached to target because of auto-attach or `attachToTarget` command.
          */
@@ -578,8 +628,8 @@ export namespace ProtocolMapping {
         'Tethering.accepted': [Protocol.Tethering.AcceptedEvent];
         'Tracing.bufferUsage': [Protocol.Tracing.BufferUsageEvent];
         /**
-         * Contains an bucket of collected trace events. When tracing is stopped collected events will be
-         * send as a sequence of dataCollected events followed by tracingComplete event.
+         * Contains a bucket of collected trace events. When tracing is stopped collected events will be
+         * sent as a sequence of dataCollected events followed by tracingComplete event.
          */
         'Tracing.dataCollected': [Protocol.Tracing.DataCollectedEvent];
         /**
@@ -594,6 +644,11 @@ export namespace ProtocolMapping {
          * The stage of the request can be determined by presence of responseErrorReason
          * and responseStatusCode -- the request is at the response stage if either
          * of these fields is present and in the request stage otherwise.
+         * Redirect responses and subsequent requests are reported similarly to regular
+         * responses and requests. Redirect responses may be distinguished by the value
+         * of `responseStatusCode` (which is one of 301, 302, 303, 307, 308) along with
+         * presence of the `location` header. Requests resulting from a redirect will
+         * have `redirectedRequestId` field set.
          */
         'Fetch.requestPaused': [Protocol.Fetch.RequestPausedEvent];
         /**
@@ -653,6 +708,14 @@ export namespace ProtocolMapping {
          * Notifies that an AudioNode is disconnected to an AudioParam.
          */
         'WebAudio.nodeParamDisconnected': [Protocol.WebAudio.NodeParamDisconnectedEvent];
+        /**
+         * Triggered when a credential is added to an authenticator.
+         */
+        'WebAuthn.credentialAdded': [Protocol.WebAuthn.CredentialAddedEvent];
+        /**
+         * Triggered when a credential is used in a webauthn assertion.
+         */
+        'WebAuthn.credentialAsserted': [Protocol.WebAuthn.CredentialAssertedEvent];
         /**
          * This can be called multiple times, and can be used to set / override /
          * remove player properties. A null propValue indicates removal.
@@ -677,6 +740,38 @@ export namespace ProtocolMapping {
          * list of player ids and all events again.
          */
         'Media.playersCreated': [Protocol.Media.PlayersCreatedEvent];
+        /**
+         * A device request opened a user prompt to select a device. Respond with the
+         * selectPrompt or cancelPrompt command.
+         */
+        'DeviceAccess.deviceRequestPrompted': [Protocol.DeviceAccess.DeviceRequestPromptedEvent];
+        /**
+         * Upsert. Currently, it is only emitted when a rule set added.
+         */
+        'Preload.ruleSetUpdated': [Protocol.Preload.RuleSetUpdatedEvent];
+        'Preload.ruleSetRemoved': [Protocol.Preload.RuleSetRemovedEvent];
+        /**
+         * Fired when a preload enabled state is updated.
+         */
+        'Preload.preloadEnabledStateUpdated': [Protocol.Preload.PreloadEnabledStateUpdatedEvent];
+        /**
+         * Fired when a prefetch attempt is updated.
+         */
+        'Preload.prefetchStatusUpdated': [Protocol.Preload.PrefetchStatusUpdatedEvent];
+        /**
+         * Fired when a prerender attempt is updated.
+         */
+        'Preload.prerenderStatusUpdated': [Protocol.Preload.PrerenderStatusUpdatedEvent];
+        /**
+         * Send a list of sources for all preloading attempts in a document.
+         */
+        'Preload.preloadingAttemptSourcesUpdated': [Protocol.Preload.PreloadingAttemptSourcesUpdatedEvent];
+        'FedCm.dialogShown': [Protocol.FedCm.DialogShownEvent];
+        /**
+         * Triggered when a dialog is closed, either by user action, JS abort,
+         * or a command below.
+         */
+        'FedCm.dialogClosed': [Protocol.FedCm.DialogClosedEvent];
     }
 
     export interface Commands {
@@ -746,6 +841,20 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Debugger.GetScriptSourceRequest];
             returnType: Protocol.Debugger.GetScriptSourceResponse;
         };
+        'Debugger.disassembleWasmModule': {
+            paramsType: [Protocol.Debugger.DisassembleWasmModuleRequest];
+            returnType: Protocol.Debugger.DisassembleWasmModuleResponse;
+        };
+        /**
+         * Disassemble the next chunk of lines for the module corresponding to the
+         * stream. If disassembly is complete, this API will invalidate the streamId
+         * and return an empty chunk. Any subsequent calls for the now invalid stream
+         * will return errors.
+         */
+        'Debugger.nextWasmDisassemblyChunk': {
+            paramsType: [Protocol.Debugger.NextWasmDisassemblyChunkRequest];
+            returnType: Protocol.Debugger.NextWasmDisassemblyChunkResponse;
+        };
         /**
          * This command is deprecated. Use getScriptSource instead.
          */
@@ -779,7 +888,19 @@ export namespace ProtocolMapping {
             returnType: void;
         };
         /**
-         * Restarts particular call frame from the beginning.
+         * Restarts particular call frame from the beginning. The old, deprecated
+         * behavior of `restartFrame` is to stay paused and allow further CDP commands
+         * after a restart was scheduled. This can cause problems with restarting, so
+         * we now continue execution immediatly after it has been scheduled until we
+         * reach the beginning of the restarted frame.
+         * 
+         * To stay back-wards compatible, `restartFrame` now expects a `mode`
+         * parameter to be present. If the `mode` parameter is missing, `restartFrame`
+         * errors out.
+         * 
+         * The various return values are deprecated and `callFrames` is always empty.
+         * Use the call frames from the `Debugger#paused` events instead, that fires
+         * once V8 pauses at the beginning of the restarted function.
          */
         'Debugger.restartFrame': {
             paramsType: [Protocol.Debugger.RestartFrameRequest];
@@ -866,8 +987,8 @@ export namespace ProtocolMapping {
             returnType: void;
         };
         /**
-         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or
-         * no exceptions. Initial pause on exceptions state is `none`.
+         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
+         * or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
          */
         'Debugger.setPauseOnExceptions': {
             paramsType: [Protocol.Debugger.SetPauseOnExceptionsRequest];
@@ -882,6 +1003,12 @@ export namespace ProtocolMapping {
         };
         /**
          * Edits JavaScript source live.
+         * 
+         * In general, functions that are currently on the stack can not be edited with
+         * a single exception: If the edited function is the top-most stack frame and
+         * that is the only activation of that function on the stack. In this case
+         * the live edit will be successful and a `Debugger.restartFrame` for the
+         * top-most function is automatically triggered.
          */
         'Debugger.setScriptSource': {
             paramsType: [Protocol.Debugger.SetScriptSourceRequest];
@@ -1011,13 +1138,6 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Profiler.StartPreciseCoverageRequest?];
             returnType: Protocol.Profiler.StartPreciseCoverageResponse;
         };
-        /**
-         * Enable type profile.
-         */
-        'Profiler.startTypeProfile': {
-            paramsType: [];
-            returnType: void;
-        };
         'Profiler.stop': {
             paramsType: [];
             returnType: Protocol.Profiler.StopResponse;
@@ -1030,13 +1150,6 @@ export namespace ProtocolMapping {
             paramsType: [];
             returnType: void;
         };
-        /**
-         * Disable type profile. Disabling releases type profile data collected so far.
-         */
-        'Profiler.stopTypeProfile': {
-            paramsType: [];
-            returnType: void;
-        };
         /**
          * Collect coverage data for the current isolate, and resets execution counters. Precise code
          * coverage needs to have started.
@@ -1045,13 +1158,6 @@ export namespace ProtocolMapping {
             paramsType: [];
             returnType: Protocol.Profiler.TakePreciseCoverageResponse;
         };
-        /**
-         * Collect type profile.
-         */
-        'Profiler.takeTypeProfile': {
-            paramsType: [];
-            returnType: Protocol.Profiler.TakeTypeProfileResponse;
-        };
         /**
          * Add handler to promise with given promise object id.
          */
@@ -1209,6 +1315,17 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Runtime.RemoveBindingRequest];
             returnType: void;
         };
+        /**
+         * This method tries to lookup and populate exception details for a
+         * JavaScript Error object.
+         * Note that the stackTrace portion of the resulting exceptionDetails will
+         * only be populated if the Runtime domain was enabled at the time when the
+         * Error was thrown.
+         */
+        'Runtime.getExceptionDetails': {
+            paramsType: [Protocol.Runtime.GetExceptionDetailsRequest];
+            returnType: Protocol.Runtime.GetExceptionDetailsResponse;
+        };
         /**
          * Returns supported domains.
          */
@@ -1245,6 +1362,22 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Accessibility.GetFullAXTreeRequest?];
             returnType: Protocol.Accessibility.GetFullAXTreeResponse;
         };
+        /**
+         * Fetches the root node.
+         * Requires `enable()` to have been called previously.
+         */
+        'Accessibility.getRootAXNode': {
+            paramsType: [Protocol.Accessibility.GetRootAXNodeRequest?];
+            returnType: Protocol.Accessibility.GetRootAXNodeResponse;
+        };
+        /**
+         * Fetches a node and all ancestors up to and including the root.
+         * Requires `enable()` to have been called previously.
+         */
+        'Accessibility.getAXNodeAndAncestors': {
+            paramsType: [Protocol.Accessibility.GetAXNodeAndAncestorsRequest?];
+            returnType: Protocol.Accessibility.GetAXNodeAndAncestorsResponse;
+        };
         /**
          * Fetches a particular accessibility node by AXNodeId.
          * Requires `enable()` to have been called previously.
@@ -1256,7 +1389,7 @@ export namespace ProtocolMapping {
         /**
          * Query a DOM node's accessibility subtree for accessible name and role.
          * This command computes the name and role for all nodes in the subtree, including those that are
-         * ignored for accessibility, and returns those that mactch the specified name and role. If no DOM
+         * ignored for accessibility, and returns those that match the specified name and role. If no DOM
          * node is specified, or the DOM node does not exist, the command returns an error. If neither
          * `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
          */
@@ -1334,35 +1467,6 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Animation.SetTimingRequest];
             returnType: void;
         };
-        /**
-         * Enables application cache domain notifications.
-         */
-        'ApplicationCache.enable': {
-            paramsType: [];
-            returnType: void;
-        };
-        /**
-         * Returns relevant application cache data for the document in given frame.
-         */
-        'ApplicationCache.getApplicationCacheForFrame': {
-            paramsType: [Protocol.ApplicationCache.GetApplicationCacheForFrameRequest];
-            returnType: Protocol.ApplicationCache.GetApplicationCacheForFrameResponse;
-        };
-        /**
-         * Returns array of frame identifiers with manifest urls for each frame containing a document
-         * associated with some application cache.
-         */
-        'ApplicationCache.getFramesWithManifests': {
-            paramsType: [];
-            returnType: Protocol.ApplicationCache.GetFramesWithManifestsResponse;
-        };
-        /**
-         * Returns manifest URL for document in the given frame.
-         */
-        'ApplicationCache.getManifestForFrame': {
-            paramsType: [Protocol.ApplicationCache.GetManifestForFrameRequest];
-            returnType: Protocol.ApplicationCache.GetManifestForFrameResponse;
-        };
         /**
          * Returns the response body and size if it were re-encoded with the specified settings. Only
          * applies to images.
@@ -1394,6 +1498,84 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Audits.CheckContrastRequest?];
             returnType: void;
         };
+        /**
+         * Runs the form issues check for the target page. Found issues are reported
+         * using Audits.issueAdded event.
+         */
+        'Audits.checkFormsIssues': {
+            paramsType: [];
+            returnType: Protocol.Audits.CheckFormsIssuesResponse;
+        };
+        /**
+         * Installs an unpacked extension from the filesystem similar to
+         * --load-extension CLI flags. Returns extension ID once the extension
+         * has been installed. Available if the client is connected using the
+         * --remote-debugging-pipe flag and the --enable-unsafe-extension-debugging
+         * flag is set.
+         */
+        'Extensions.loadUnpacked': {
+            paramsType: [Protocol.Extensions.LoadUnpackedRequest];
+            returnType: Protocol.Extensions.LoadUnpackedResponse;
+        };
+        /**
+         * Gets data from extension storage in the given `storageArea`. If `keys` is
+         * specified, these are used to filter the result.
+         */
+        'Extensions.getStorageItems': {
+            paramsType: [Protocol.Extensions.GetStorageItemsRequest];
+            returnType: Protocol.Extensions.GetStorageItemsResponse;
+        };
+        /**
+         * Removes `keys` from extension storage in the given `storageArea`.
+         */
+        'Extensions.removeStorageItems': {
+            paramsType: [Protocol.Extensions.RemoveStorageItemsRequest];
+            returnType: void;
+        };
+        /**
+         * Clears extension storage in the given `storageArea`.
+         */
+        'Extensions.clearStorageItems': {
+            paramsType: [Protocol.Extensions.ClearStorageItemsRequest];
+            returnType: void;
+        };
+        /**
+         * Sets `values` in extension storage in the given `storageArea`. The provided `values`
+         * will be merged with existing values in the storage area.
+         */
+        'Extensions.setStorageItems': {
+            paramsType: [Protocol.Extensions.SetStorageItemsRequest];
+            returnType: void;
+        };
+        /**
+         * Trigger autofill on a form identified by the fieldId.
+         * If the field and related form cannot be autofilled, returns an error.
+         */
+        'Autofill.trigger': {
+            paramsType: [Protocol.Autofill.TriggerRequest];
+            returnType: void;
+        };
+        /**
+         * Set addresses so that developers can verify their forms implementation.
+         */
+        'Autofill.setAddresses': {
+            paramsType: [Protocol.Autofill.SetAddressesRequest];
+            returnType: void;
+        };
+        /**
+         * Disables autofill domain notifications.
+         */
+        'Autofill.disable': {
+            paramsType: [];
+            returnType: void;
+        };
+        /**
+         * Enables autofill domain notifications.
+         */
+        'Autofill.enable': {
+            paramsType: [];
+            returnType: void;
+        };
         /**
          * Enables event updates for the service.
          */
@@ -1542,6 +1724,14 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Browser.ExecuteBrowserCommandRequest];
             returnType: void;
         };
+        /**
+         * Allows a site to use privacy sandbox features that require enrollment
+         * without the site actually being enrolled. Only supported on page targets.
+         */
+        'Browser.addPrivacySandboxEnrollmentOverride': {
+            paramsType: [Protocol.Browser.AddPrivacySandboxEnrollmentOverrideRequest];
+            returnType: void;
+        };
         /**
          * Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
          * position specified by `location`.
@@ -1635,6 +1825,24 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.CSS.GetStyleSheetTextRequest];
             returnType: Protocol.CSS.GetStyleSheetTextResponse;
         };
+        /**
+         * Returns all layers parsed by the rendering engine for the tree scope of a node.
+         * Given a DOM element identified by nodeId, getLayersForNode returns the root
+         * layer for the nearest ancestor document or shadow root. The layer root contains
+         * the full layer tree for the tree scope and their ordering.
+         */
+        'CSS.getLayersForNode': {
+            paramsType: [Protocol.CSS.GetLayersForNodeRequest];
+            returnType: Protocol.CSS.GetLayersForNodeResponse;
+        };
+        /**
+         * Given a CSS selector text and a style sheet ID, getLocationForSelector
+         * returns an array of locations of the CSS selector in the style sheet.
+         */
+        'CSS.getLocationForSelector': {
+            paramsType: [Protocol.CSS.GetLocationForSelectorRequest];
+            returnType: Protocol.CSS.GetLocationForSelectorResponse;
+        };
         /**
          * Starts tracking the given computed styles for updates. The specified array of properties
          * replaces the one previously specified. Pass empty array to disable tracking.
@@ -1662,6 +1870,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.CSS.SetEffectivePropertyValueForNodeRequest];
             returnType: void;
         };
+        /**
+         * Modifies the property rule property name.
+         */
+        'CSS.setPropertyRulePropertyName': {
+            paramsType: [Protocol.CSS.SetPropertyRulePropertyNameRequest];
+            returnType: Protocol.CSS.SetPropertyRulePropertyNameResponse;
+        };
         /**
          * Modifies the keyframe rule key text.
          */
@@ -1683,6 +1898,20 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.CSS.SetContainerQueryTextRequest];
             returnType: Protocol.CSS.SetContainerQueryTextResponse;
         };
+        /**
+         * Modifies the expression of a supports at-rule.
+         */
+        'CSS.setSupportsText': {
+            paramsType: [Protocol.CSS.SetSupportsTextRequest];
+            returnType: Protocol.CSS.SetSupportsTextResponse;
+        };
+        /**
+         * Modifies the expression of a scope at-rule.
+         */
+        'CSS.setScopeText': {
+            paramsType: [Protocol.CSS.SetScopeTextRequest];
+            returnType: Protocol.CSS.SetScopeTextResponse;
+        };
         /**
          * Modifies the rule selector.
          */
@@ -1713,7 +1942,7 @@ export namespace ProtocolMapping {
         };
         /**
          * Stop tracking rule usage and return the list of rules that were used since last call to
-         * `takeCoverageDelta` (or since start of coverage instrumentation)
+         * `takeCoverageDelta` (or since start of coverage instrumentation).
          */
         'CSS.stopRuleUsageTracking': {
             paramsType: [];
@@ -1721,7 +1950,7 @@ export namespace ProtocolMapping {
         };
         /**
          * Obtain list of rules that became used since last call to this method (or since start of coverage
-         * instrumentation)
+         * instrumentation).
          */
         'CSS.takeCoverageDelta': {
             paramsType: [];
@@ -1752,7 +1981,7 @@ export namespace ProtocolMapping {
          * Requests cache names.
          */
         'CacheStorage.requestCacheNames': {
-            paramsType: [Protocol.CacheStorage.RequestCacheNamesRequest];
+            paramsType: [Protocol.CacheStorage.RequestCacheNamesRequest?];
             returnType: Protocol.CacheStorage.RequestCacheNamesResponse;
         };
         /**
@@ -1795,6 +2024,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Cast.SetSinkToUseRequest];
             returnType: void;
         };
+        /**
+         * Starts mirroring the desktop to the sink.
+         */
+        'Cast.startDesktopMirroring': {
+            paramsType: [Protocol.Cast.StartDesktopMirroringRequest];
+            returnType: void;
+        };
         /**
          * Starts mirroring the tab to the sink.
          */
@@ -1860,7 +2096,7 @@ export namespace ProtocolMapping {
          * Enables DOM agent for the given page.
          */
         'DOM.enable': {
-            paramsType: [];
+            paramsType: [Protocol.DOM.EnableRequest?];
             returnType: void;
         };
         /**
@@ -1894,6 +2130,7 @@ export namespace ProtocolMapping {
         };
         /**
          * Returns the root DOM node (and optionally the subtree) to the caller.
+         * Implicitly enables the DOM domain events for the current target.
          */
         'DOM.getDocument': {
             paramsType: [Protocol.DOM.GetDocumentRequest?];
@@ -2016,6 +2253,22 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.DOM.QuerySelectorAllRequest];
             returnType: Protocol.DOM.QuerySelectorAllResponse;
         };
+        /**
+         * Returns NodeIds of current top layer elements.
+         * Top layer is rendered closest to the user within a viewport, therefore its elements always
+         * appear on top of all other content.
+         */
+        'DOM.getTopLayerElements': {
+            paramsType: [];
+            returnType: Protocol.DOM.GetTopLayerElementsResponse;
+        };
+        /**
+         * Returns the NodeId of the matched element according to certain relations.
+         */
+        'DOM.getElementByRelation': {
+            paramsType: [Protocol.DOM.GetElementByRelationRequest];
+            returnType: Protocol.DOM.GetElementByRelationResponse;
+        };
         /**
          * Re-does the last undone action.
          */
@@ -2106,6 +2359,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.DOM.GetFileInfoRequest];
             returnType: Protocol.DOM.GetFileInfoResponse;
         };
+        /**
+         * Returns list of detached nodes
+         */
+        'DOM.getDetachedDomNodes': {
+            paramsType: [];
+            returnType: Protocol.DOM.GetDetachedDomNodesResponse;
+        };
         /**
          * Enables console to refer to the node with given id via $x (see Command Line API for more details
          * $x functions).
@@ -2150,9 +2410,10 @@ export namespace ProtocolMapping {
             returnType: Protocol.DOM.GetFrameOwnerResponse;
         };
         /**
-         * Returns the container of the given node based on container query conditions.
-         * If containerName is given, it will find the nearest container with a matching name;
-         * otherwise it will find the nearest container regardless of its container name.
+         * Returns the query container of the given node based on container query
+         * conditions: containerName, physical, and logical axes. If no axes are
+         * provided, the style container is returned, which is the direct parent or the
+         * closest element with a matching container-name.
          */
         'DOM.getContainerForNode': {
             paramsType: [Protocol.DOM.GetContainerForNodeRequest];
@@ -2166,6 +2427,14 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.DOM.GetQueryingDescendantsForContainerRequest];
             returnType: Protocol.DOM.GetQueryingDescendantsForContainerResponse;
         };
+        /**
+         * Returns the target anchor element of the given anchor query according to
+         * https://www.w3.org/TR/css-anchor-position-1/#target.
+         */
+        'DOM.getAnchorElement': {
+            paramsType: [Protocol.DOM.GetAnchorElementRequest];
+            returnType: Protocol.DOM.GetAnchorElementResponse;
+        };
         /**
          * Returns event listeners of the given object.
          */
@@ -2236,6 +2505,27 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.DOMDebugger.SetXHRBreakpointRequest];
             returnType: void;
         };
+        /**
+         * Sets breakpoint on particular native event.
+         */
+        'EventBreakpoints.setInstrumentationBreakpoint': {
+            paramsType: [Protocol.EventBreakpoints.SetInstrumentationBreakpointRequest];
+            returnType: void;
+        };
+        /**
+         * Removes breakpoint on particular native event.
+         */
+        'EventBreakpoints.removeInstrumentationBreakpoint': {
+            paramsType: [Protocol.EventBreakpoints.RemoveInstrumentationBreakpointRequest];
+            returnType: void;
+        };
+        /**
+         * Removes all breakpoints
+         */
+        'EventBreakpoints.disable': {
+            paramsType: [];
+            returnType: void;
+        };
         /**
          * Disables DOM snapshot agent for the given page.
          */
@@ -2402,6 +2692,24 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Emulation.SetDeviceMetricsOverrideRequest];
             returnType: void;
         };
+        /**
+         * Start reporting the given posture value to the Device Posture API.
+         * This override can also be set in setDeviceMetricsOverride().
+         */
+        'Emulation.setDevicePostureOverride': {
+            paramsType: [Protocol.Emulation.SetDevicePostureOverrideRequest];
+            returnType: void;
+        };
+        /**
+         * Clears a device posture override set with either setDeviceMetricsOverride()
+         * or setDevicePostureOverride() and starts using posture information from the
+         * platform again.
+         * Does nothing if no override is set.
+         */
+        'Emulation.clearDevicePostureOverride': {
+            paramsType: [];
+            returnType: void;
+        };
         'Emulation.setScrollbarsHidden': {
             paramsType: [Protocol.Emulation.SetScrollbarsHiddenRequest];
             returnType: void;
@@ -2436,6 +2744,48 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Emulation.SetGeolocationOverrideRequest?];
             returnType: void;
         };
+        'Emulation.getOverriddenSensorInformation': {
+            paramsType: [Protocol.Emulation.GetOverriddenSensorInformationRequest];
+            returnType: Protocol.Emulation.GetOverriddenSensorInformationResponse;
+        };
+        /**
+         * Overrides a platform sensor of a given type. If |enabled| is true, calls to
+         * Sensor.start() will use a virtual sensor as backend rather than fetching
+         * data from a real hardware sensor. Otherwise, existing virtual
+         * sensor-backend Sensor objects will fire an error event and new calls to
+         * Sensor.start() will attempt to use a real sensor instead.
+         */
+        'Emulation.setSensorOverrideEnabled': {
+            paramsType: [Protocol.Emulation.SetSensorOverrideEnabledRequest];
+            returnType: void;
+        };
+        /**
+         * Updates the sensor readings reported by a sensor type previously overridden
+         * by setSensorOverrideEnabled.
+         */
+        'Emulation.setSensorOverrideReadings': {
+            paramsType: [Protocol.Emulation.SetSensorOverrideReadingsRequest];
+            returnType: void;
+        };
+        /**
+         * Overrides a pressure source of a given type, as used by the Compute
+         * Pressure API, so that updates to PressureObserver.observe() are provided
+         * via setPressureStateOverride instead of being retrieved from
+         * platform-provided telemetry data.
+         */
+        'Emulation.setPressureSourceOverrideEnabled': {
+            paramsType: [Protocol.Emulation.SetPressureSourceOverrideEnabledRequest];
+            returnType: void;
+        };
+        /**
+         * Provides a given pressure state that will be processed and eventually be
+         * delivered to PressureObserver users. |source| must have been previously
+         * overridden by setPressureSourceOverrideEnabled.
+         */
+        'Emulation.setPressureStateOverride': {
+            paramsType: [Protocol.Emulation.SetPressureStateOverrideRequest];
+            returnType: void;
+        };
         /**
          * Overrides the Idle state.
          */
@@ -2513,18 +2863,30 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Emulation.SetDisabledImageTypesRequest];
             returnType: void;
         };
+        'Emulation.setHardwareConcurrencyOverride': {
+            paramsType: [Protocol.Emulation.SetHardwareConcurrencyOverrideRequest];
+            returnType: void;
+        };
         /**
          * Allows overriding user agent with the given string.
+         * `userAgentMetadata` must be set for Client Hint headers to be sent.
          */
         'Emulation.setUserAgentOverride': {
             paramsType: [Protocol.Emulation.SetUserAgentOverrideRequest];
             returnType: void;
         };
+        /**
+         * Allows overriding the automation flag.
+         */
+        'Emulation.setAutomationOverride': {
+            paramsType: [Protocol.Emulation.SetAutomationOverrideRequest];
+            returnType: void;
+        };
         /**
          * Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
          * screenshot from the resulting frame. Requires that the target was created with enabled
          * BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
-         * https://goo.gl/3zHXhB for more background.
+         * https://goo.gle/chrome-headless-rendering for more background.
          */
         'HeadlessExperimental.beginFrame': {
             paramsType: [Protocol.HeadlessExperimental.BeginFrameRequest?];
@@ -2565,6 +2927,10 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.IO.ResolveBlobRequest];
             returnType: Protocol.IO.ResolveBlobResponse;
         };
+        'FileSystem.getDirectory': {
+            paramsType: [Protocol.FileSystem.GetDirectoryRequest];
+            returnType: Protocol.FileSystem.GetDirectoryResponse;
+        };
         /**
          * Clears all entries from an object store.
          */
@@ -2608,7 +2974,7 @@ export namespace ProtocolMapping {
             returnType: Protocol.IndexedDB.RequestDataResponse;
         };
         /**
-         * Gets metadata of an object store
+         * Gets metadata of an object store.
          */
         'IndexedDB.getMetadata': {
             paramsType: [Protocol.IndexedDB.GetMetadataRequest];
@@ -2625,7 +2991,7 @@ export namespace ProtocolMapping {
          * Requests database names for given security origin.
          */
         'IndexedDB.requestDatabaseNames': {
-            paramsType: [Protocol.IndexedDB.RequestDatabaseNamesRequest];
+            paramsType: [Protocol.IndexedDB.RequestDatabaseNamesRequest?];
             returnType: Protocol.IndexedDB.RequestDatabaseNamesResponse;
         };
         /**
@@ -2651,7 +3017,7 @@ export namespace ProtocolMapping {
             returnType: void;
         };
         /**
-         * This method sets the current candidate text for ime.
+         * This method sets the current candidate text for IME.
          * Use imeCommitComposition to commit the final text.
          * Use imeSetComposition with empty string as text to cancel composition.
          */
@@ -2673,6 +3039,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Input.DispatchTouchEventRequest];
             returnType: void;
         };
+        /**
+         * Cancels any active dragging in the page.
+         */
+        'Input.cancelDragging': {
+            paramsType: [];
+            returnType: void;
+        };
         /**
          * Emulates touch event from the mouse event parameters.
          */
@@ -2954,7 +3327,7 @@ export namespace ProtocolMapping {
             returnType: void;
         };
         /**
-         * Deletes browser cookies with matching name and url or domain/path pair.
+         * Deletes browser cookies with matching name and url or domain/path/partitionKey pair.
          */
         'Network.deleteCookies': {
             paramsType: [Protocol.Network.DeleteCookiesRequest];
@@ -2984,6 +3357,7 @@ export namespace ProtocolMapping {
         /**
          * Returns all browser cookies. Depending on the backend support, will return detailed cookie
          * information in the `cookies` field.
+         * Deprecated. Use Storage.getCookies instead.
          */
         'Network.getAllCookies': {
             paramsType: [];
@@ -3115,6 +3489,14 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Network.SetUserAgentOverrideRequest];
             returnType: void;
         };
+        /**
+         * Enables streaming of the response for the given requestId.
+         * If enabled, the dataReceived event contains the data that was received during streaming.
+         */
+        'Network.streamResourceContent': {
+            paramsType: [Protocol.Network.StreamResourceContentRequest];
+            returnType: Protocol.Network.StreamResourceContentResponse;
+        };
         /**
          * Returns information about the COEP/COOP isolation status.
          */
@@ -3181,8 +3563,8 @@ export namespace ProtocolMapping {
         };
         /**
          * Highlights owner element of the frame with given id.
-         * Deprecated: Doesn't work reliablity and cannot be fixed due to process
-         * separatation (the owner node might be in a different process). Determine
+         * Deprecated: Doesn't work reliably and cannot be fixed due to process
+         * separation (the owner node might be in a different process). Determine
          * the owner node in the client and use highlightNode.
          */
         'Overlay.highlightFrame': {
@@ -3293,7 +3675,7 @@ export namespace ProtocolMapping {
             returnType: void;
         };
         /**
-         * Requests that backend shows hit-test borders on layers
+         * Deprecated, no longer has any effect.
          */
         'Overlay.setShowHitTestBorders': {
             paramsType: [Protocol.Overlay.SetShowHitTestBordersRequest];
@@ -3327,6 +3709,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Overlay.SetShowIsolatedElementsRequest];
             returnType: void;
         };
+        /**
+         * Show Window Controls Overlay for PWA
+         */
+        'Overlay.setShowWindowControlsOverlay': {
+            paramsType: [Protocol.Overlay.SetShowWindowControlsOverlayRequest?];
+            returnType: void;
+        };
         /**
          * Deprecated, please use addScriptToEvaluateOnNewDocument instead.
          */
@@ -3412,14 +3801,24 @@ export namespace ProtocolMapping {
             paramsType: [];
             returnType: void;
         };
+        /**
+         * Gets the processed manifest for this current document.
+         *   This API always waits for the manifest to be loaded.
+         *   If manifestId is provided, and it does not match the manifest of the
+         *     current document, this API errors out.
+         *   If there is not a loaded page, this API errors out immediately.
+         */
         'Page.getAppManifest': {
-            paramsType: [];
+            paramsType: [Protocol.Page.GetAppManifestRequest?];
             returnType: Protocol.Page.GetAppManifestResponse;
         };
         'Page.getInstallabilityErrors': {
             paramsType: [];
             returnType: Protocol.Page.GetInstallabilityErrorsResponse;
         };
+        /**
+         * Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.
+         */
         'Page.getManifestIcons': {
             paramsType: [];
             returnType: Protocol.Page.GetManifestIconsResponse;
@@ -3432,13 +3831,9 @@ export namespace ProtocolMapping {
             paramsType: [];
             returnType: Protocol.Page.GetAppIdResponse;
         };
-        /**
-         * Returns all browser cookies. Depending on the backend support, will return detailed cookie
-         * information in the `cookies` field.
-         */
-        'Page.getCookies': {
-            paramsType: [];
-            returnType: Protocol.Page.GetCookiesResponse;
+        'Page.getAdScriptId': {
+            paramsType: [Protocol.Page.GetAdScriptIdRequest];
+            returnType: Protocol.Page.GetAdScriptIdResponse;
         };
         /**
          * Returns present frame tree structure.
@@ -3683,21 +4078,10 @@ export namespace ProtocolMapping {
             paramsType: [];
             returnType: void;
         };
-        /**
-         * Forces compilation cache to be generated for every subresource script.
-         * See also: `Page.produceCompilationCache`.
-         */
-        'Page.setProduceCompilationCache': {
-            paramsType: [Protocol.Page.SetProduceCompilationCacheRequest];
-            returnType: void;
-        };
         /**
          * Requests backend to produce compilation cache for the specified scripts.
-         * Unlike setProduceCompilationCache, this allows client to only produce cache
-         * for specific scripts. `scripts` are appeneded to the list of scripts
-         * for which the cache for would produced. Disabling compilation cache with
-         * `setProduceCompilationCache` would reset all pending cache requests.
-         * The list may also be reset during page navigation.
+         * `scripts` are appended to the list of scripts for which the cache
+         * would be produced. The list may be reset during page navigation.
          * When script with a matching URL is encountered, the cache is optionally
          * produced upon backend discretion, based on internal heuristics.
          * See also: `Page.compilationCacheProduced`.
@@ -3721,6 +4105,22 @@ export namespace ProtocolMapping {
             paramsType: [];
             returnType: void;
         };
+        /**
+         * Sets the Secure Payment Confirmation transaction mode.
+         * https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
+         */
+        'Page.setSPCTransactionMode': {
+            paramsType: [Protocol.Page.SetSPCTransactionModeRequest];
+            returnType: void;
+        };
+        /**
+         * Extensions for Custom Handlers API:
+         * https://html.spec.whatwg.org/multipage/system-state.html#rph-automation
+         */
+        'Page.setRPHRegistrationMode': {
+            paramsType: [Protocol.Page.SetRPHRegistrationModeRequest];
+            returnType: void;
+        };
         /**
          * Generates a report for testing.
          */
@@ -3744,6 +4144,19 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Page.SetInterceptFileChooserDialogRequest];
             returnType: void;
         };
+        /**
+         * Enable/disable prerendering manually.
+         * 
+         * This command is a short-term solution for https://crbug.com/1440085.
+         * See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
+         * for more details.
+         * 
+         * TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.
+         */
+        'Page.setPrerenderingAllowed': {
+            paramsType: [Protocol.Page.SetPrerenderingAllowedRequest];
+            returnType: void;
+        };
         /**
          * Disable collecting and reporting metrics.
          */
@@ -3870,6 +4283,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.ServiceWorker.UpdateRegistrationRequest];
             returnType: void;
         };
+        /**
+         * Returns a storage key given a frame id.
+         */
+        'Storage.getStorageKeyForFrame': {
+            paramsType: [Protocol.Storage.GetStorageKeyForFrameRequest];
+            returnType: Protocol.Storage.GetStorageKeyForFrameResponse;
+        };
         /**
          * Clears storage for origin.
          */
@@ -3877,6 +4297,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Storage.ClearDataForOriginRequest];
             returnType: void;
         };
+        /**
+         * Clears storage for storage key.
+         */
+        'Storage.clearDataForStorageKey': {
+            paramsType: [Protocol.Storage.ClearDataForStorageKeyRequest];
+            returnType: void;
+        };
         /**
          * Returns all browser cookies.
          */
@@ -3919,6 +4346,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Storage.TrackCacheStorageForOriginRequest];
             returnType: void;
         };
+        /**
+         * Registers storage key to be notified when an update occurs to its cache storage list.
+         */
+        'Storage.trackCacheStorageForStorageKey': {
+            paramsType: [Protocol.Storage.TrackCacheStorageForStorageKeyRequest];
+            returnType: void;
+        };
         /**
          * Registers origin to be notified when an update occurs to its IndexedDB.
          */
@@ -3926,6 +4360,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Storage.TrackIndexedDBForOriginRequest];
             returnType: void;
         };
+        /**
+         * Registers storage key to be notified when an update occurs to its IndexedDB.
+         */
+        'Storage.trackIndexedDBForStorageKey': {
+            paramsType: [Protocol.Storage.TrackIndexedDBForStorageKeyRequest];
+            returnType: void;
+        };
         /**
          * Unregisters origin from receiving notifications for cache storage.
          */
@@ -3933,6 +4374,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Storage.UntrackCacheStorageForOriginRequest];
             returnType: void;
         };
+        /**
+         * Unregisters storage key from receiving notifications for cache storage.
+         */
+        'Storage.untrackCacheStorageForStorageKey': {
+            paramsType: [Protocol.Storage.UntrackCacheStorageForStorageKeyRequest];
+            returnType: void;
+        };
         /**
          * Unregisters origin from receiving notifications for IndexedDB.
          */
@@ -3940,6 +4388,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Storage.UntrackIndexedDBForOriginRequest];
             returnType: void;
         };
+        /**
+         * Unregisters storage key from receiving notifications for IndexedDB.
+         */
+        'Storage.untrackIndexedDBForStorageKey': {
+            paramsType: [Protocol.Storage.UntrackIndexedDBForStorageKeyRequest];
+            returnType: void;
+        };
         /**
          * Returns the number of stored Trust Tokens per issuer for the
          * current browsing context.
@@ -3956,6 +4411,128 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.Storage.ClearTrustTokensRequest];
             returnType: Protocol.Storage.ClearTrustTokensResponse;
         };
+        /**
+         * Gets details for a named interest group.
+         */
+        'Storage.getInterestGroupDetails': {
+            paramsType: [Protocol.Storage.GetInterestGroupDetailsRequest];
+            returnType: Protocol.Storage.GetInterestGroupDetailsResponse;
+        };
+        /**
+         * Enables/Disables issuing of interestGroupAccessed events.
+         */
+        'Storage.setInterestGroupTracking': {
+            paramsType: [Protocol.Storage.SetInterestGroupTrackingRequest];
+            returnType: void;
+        };
+        /**
+         * Enables/Disables issuing of interestGroupAuctionEventOccurred and
+         * interestGroupAuctionNetworkRequestCreated.
+         */
+        'Storage.setInterestGroupAuctionTracking': {
+            paramsType: [Protocol.Storage.SetInterestGroupAuctionTrackingRequest];
+            returnType: void;
+        };
+        /**
+         * Gets metadata for an origin's shared storage.
+         */
+        'Storage.getSharedStorageMetadata': {
+            paramsType: [Protocol.Storage.GetSharedStorageMetadataRequest];
+            returnType: Protocol.Storage.GetSharedStorageMetadataResponse;
+        };
+        /**
+         * Gets the entries in an given origin's shared storage.
+         */
+        'Storage.getSharedStorageEntries': {
+            paramsType: [Protocol.Storage.GetSharedStorageEntriesRequest];
+            returnType: Protocol.Storage.GetSharedStorageEntriesResponse;
+        };
+        /**
+         * Sets entry with `key` and `value` for a given origin's shared storage.
+         */
+        'Storage.setSharedStorageEntry': {
+            paramsType: [Protocol.Storage.SetSharedStorageEntryRequest];
+            returnType: void;
+        };
+        /**
+         * Deletes entry for `key` (if it exists) for a given origin's shared storage.
+         */
+        'Storage.deleteSharedStorageEntry': {
+            paramsType: [Protocol.Storage.DeleteSharedStorageEntryRequest];
+            returnType: void;
+        };
+        /**
+         * Clears all entries for a given origin's shared storage.
+         */
+        'Storage.clearSharedStorageEntries': {
+            paramsType: [Protocol.Storage.ClearSharedStorageEntriesRequest];
+            returnType: void;
+        };
+        /**
+         * Resets the budget for `ownerOrigin` by clearing all budget withdrawals.
+         */
+        'Storage.resetSharedStorageBudget': {
+            paramsType: [Protocol.Storage.ResetSharedStorageBudgetRequest];
+            returnType: void;
+        };
+        /**
+         * Enables/disables issuing of sharedStorageAccessed events.
+         */
+        'Storage.setSharedStorageTracking': {
+            paramsType: [Protocol.Storage.SetSharedStorageTrackingRequest];
+            returnType: void;
+        };
+        /**
+         * Set tracking for a storage key's buckets.
+         */
+        'Storage.setStorageBucketTracking': {
+            paramsType: [Protocol.Storage.SetStorageBucketTrackingRequest];
+            returnType: void;
+        };
+        /**
+         * Deletes the Storage Bucket with the given storage key and bucket name.
+         */
+        'Storage.deleteStorageBucket': {
+            paramsType: [Protocol.Storage.DeleteStorageBucketRequest];
+            returnType: void;
+        };
+        /**
+         * Deletes state for sites identified as potential bounce trackers, immediately.
+         */
+        'Storage.runBounceTrackingMitigations': {
+            paramsType: [];
+            returnType: Protocol.Storage.RunBounceTrackingMitigationsResponse;
+        };
+        /**
+         * https://wicg.github.io/attribution-reporting-api/
+         */
+        'Storage.setAttributionReportingLocalTestingMode': {
+            paramsType: [Protocol.Storage.SetAttributionReportingLocalTestingModeRequest];
+            returnType: void;
+        };
+        /**
+         * Enables/disables issuing of Attribution Reporting events.
+         */
+        'Storage.setAttributionReportingTracking': {
+            paramsType: [Protocol.Storage.SetAttributionReportingTrackingRequest];
+            returnType: void;
+        };
+        /**
+         * Sends all pending Attribution Reports immediately, regardless of their
+         * scheduled report time.
+         */
+        'Storage.sendPendingAttributionReports': {
+            paramsType: [];
+            returnType: Protocol.Storage.SendPendingAttributionReportsResponse;
+        };
+        /**
+         * Returns the effective Related Website Sets in use by this profile for the browser
+         * session. The effective Related Website Sets will not change during a browser session.
+         */
+        'Storage.getRelatedWebsiteSets': {
+            paramsType: [];
+            returnType: Protocol.Storage.GetRelatedWebsiteSetsResponse;
+        };
         /**
          * Returns information about the system.
          */
@@ -3963,6 +4540,13 @@ export namespace ProtocolMapping {
             paramsType: [];
             returnType: Protocol.SystemInfo.GetInfoResponse;
         };
+        /**
+         * Returns information about the feature state.
+         */
+        'SystemInfo.getFeatureState': {
+            paramsType: [Protocol.SystemInfo.GetFeatureStateRequest];
+            returnType: Protocol.SystemInfo.GetFeatureStateResponse;
+        };
         /**
          * Returns information about all running processes.
          */
@@ -4004,7 +4588,7 @@ export namespace ProtocolMapping {
          * 
          * Injected object will be available as `window[bindingName]`.
          * 
-         * The object has the follwing API:
+         * The object has the following API:
          * - `binding.send(json)` - a method to send messages over the remote debugging protocol
          * - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
          */
@@ -4060,7 +4644,7 @@ export namespace ProtocolMapping {
          * Retrieves a list of available targets.
          */
         'Target.getTargets': {
-            paramsType: [];
+            paramsType: [Protocol.Target.GetTargetsRequest?];
             returnType: Protocol.Target.GetTargetsResponse;
         };
         /**
@@ -4218,6 +4802,10 @@ export namespace ProtocolMapping {
          * takeResponseBodyForInterceptionAsStream. Calling other methods that
          * affect the request or disabling fetch domain before body is received
          * results in an undefined behavior.
+         * Note that the response body is not available for redirects. Requests
+         * paused in the _redirect received_ state may be differentiated by
+         * `responseCode` and presence of `location` response header, see
+         * comments to `requestPaused` for details.
          */
         'Fetch.getResponseBody': {
             paramsType: [Protocol.Fetch.GetResponseBodyRequest];
@@ -4265,7 +4853,7 @@ export namespace ProtocolMapping {
          * retrieval with a virtual authenticator.
          */
         'WebAuthn.enable': {
-            paramsType: [];
+            paramsType: [Protocol.WebAuthn.EnableRequest?];
             returnType: void;
         };
         /**
@@ -4282,6 +4870,13 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.WebAuthn.AddVirtualAuthenticatorRequest];
             returnType: Protocol.WebAuthn.AddVirtualAuthenticatorResponse;
         };
+        /**
+         * Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present.
+         */
+        'WebAuthn.setResponseOverrideBits': {
+            paramsType: [Protocol.WebAuthn.SetResponseOverrideBitsRequest];
+            returnType: void;
+        };
         /**
          * Removes the given authenticator.
          */
@@ -4341,6 +4936,14 @@ export namespace ProtocolMapping {
             paramsType: [Protocol.WebAuthn.SetAutomaticPresenceSimulationRequest];
             returnType: void;
         };
+        /**
+         * Allows setting credential properties.
+         * https://w3c.github.io/webauthn/#sctn-automation-set-credential-properties
+         */
+        'WebAuthn.setCredentialProperties': {
+            paramsType: [Protocol.WebAuthn.SetCredentialPropertiesRequest];
+            returnType: void;
+        };
         /**
          * Enables the Media domain
          */
@@ -4355,6 +4958,186 @@ export namespace ProtocolMapping {
             paramsType: [];
             returnType: void;
         };
+        /**
+         * Enable events in this domain.
+         */
+        'DeviceAccess.enable': {
+            paramsType: [];
+            returnType: void;
+        };
+        /**
+         * Disable events in this domain.
+         */
+        'DeviceAccess.disable': {
+            paramsType: [];
+            returnType: void;
+        };
+        /**
+         * Select a device in response to a DeviceAccess.deviceRequestPrompted event.
+         */
+        'DeviceAccess.selectPrompt': {
+            paramsType: [Protocol.DeviceAccess.SelectPromptRequest];
+            returnType: void;
+        };
+        /**
+         * Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event.
+         */
+        'DeviceAccess.cancelPrompt': {
+            paramsType: [Protocol.DeviceAccess.CancelPromptRequest];
+            returnType: void;
+        };
+        'Preload.enable': {
+            paramsType: [];
+            returnType: void;
+        };
+        'Preload.disable': {
+            paramsType: [];
+            returnType: void;
+        };
+        'FedCm.enable': {
+            paramsType: [Protocol.FedCm.EnableRequest?];
+            returnType: void;
+        };
+        'FedCm.disable': {
+            paramsType: [];
+            returnType: void;
+        };
+        'FedCm.selectAccount': {
+            paramsType: [Protocol.FedCm.SelectAccountRequest];
+            returnType: void;
+        };
+        'FedCm.clickDialogButton': {
+            paramsType: [Protocol.FedCm.ClickDialogButtonRequest];
+            returnType: void;
+        };
+        'FedCm.openUrl': {
+            paramsType: [Protocol.FedCm.OpenUrlRequest];
+            returnType: void;
+        };
+        'FedCm.dismissDialog': {
+            paramsType: [Protocol.FedCm.DismissDialogRequest];
+            returnType: void;
+        };
+        /**
+         * Resets the cooldown time, if any, to allow the next FedCM call to show
+         * a dialog even if one was recently dismissed by the user.
+         */
+        'FedCm.resetCooldown': {
+            paramsType: [];
+            returnType: void;
+        };
+        /**
+         * Returns the following OS state for the given manifest id.
+         */
+        'PWA.getOsAppState': {
+            paramsType: [Protocol.PWA.GetOsAppStateRequest];
+            returnType: Protocol.PWA.GetOsAppStateResponse;
+        };
+        /**
+         * Installs the given manifest identity, optionally using the given install_url
+         * or IWA bundle location.
+         * 
+         * TODO(crbug.com/337872319) Support IWA to meet the following specific
+         * requirement.
+         * IWA-specific install description: If the manifest_id is isolated-app://,
+         * install_url_or_bundle_url is required, and can be either an http(s) URL or
+         * file:// URL pointing to a signed web bundle (.swbn). The .swbn file's
+         * signing key must correspond to manifest_id. If Chrome is not in IWA dev
+         * mode, the installation will fail, regardless of the state of the allowlist.
+         */
+        'PWA.install': {
+            paramsType: [Protocol.PWA.InstallRequest];
+            returnType: void;
+        };
+        /**
+         * Uninstalls the given manifest_id and closes any opened app windows.
+         */
+        'PWA.uninstall': {
+            paramsType: [Protocol.PWA.UninstallRequest];
+            returnType: void;
+        };
+        /**
+         * Launches the installed web app, or an url in the same web app instead of the
+         * default start url if it is provided. Returns a page Target.TargetID which
+         * can be used to attach to via Target.attachToTarget or similar APIs.
+         */
+        'PWA.launch': {
+            paramsType: [Protocol.PWA.LaunchRequest];
+            returnType: Protocol.PWA.LaunchResponse;
+        };
+        /**
+         * Opens one or more local files from an installed web app identified by its
+         * manifestId. The web app needs to have file handlers registered to process
+         * the files. The API returns one or more page Target.TargetIDs which can be
+         * used to attach to via Target.attachToTarget or similar APIs.
+         * If some files in the parameters cannot be handled by the web app, they will
+         * be ignored. If none of the files can be handled, this API returns an error.
+         * If no files are provided as the parameter, this API also returns an error.
+         * 
+         * According to the definition of the file handlers in the manifest file, one
+         * Target.TargetID may represent a page handling one or more files. The order
+         * of the returned Target.TargetIDs is not guaranteed.
+         * 
+         * TODO(crbug.com/339454034): Check the existences of the input files.
+         */
+        'PWA.launchFilesInApp': {
+            paramsType: [Protocol.PWA.LaunchFilesInAppRequest];
+            returnType: Protocol.PWA.LaunchFilesInAppResponse;
+        };
+        /**
+         * Opens the current page in its web app identified by the manifest id, needs
+         * to be called on a page target. This function returns immediately without
+         * waiting for the app to finish loading.
+         */
+        'PWA.openCurrentPageInApp': {
+            paramsType: [Protocol.PWA.OpenCurrentPageInAppRequest];
+            returnType: void;
+        };
+        /**
+         * Changes user settings of the web app identified by its manifestId. If the
+         * app was not installed, this command returns an error. Unset parameters will
+         * be ignored; unrecognized values will cause an error.
+         * 
+         * Unlike the ones defined in the manifest files of the web apps, these
+         * settings are provided by the browser and controlled by the users, they
+         * impact the way the browser handling the web apps.
+         * 
+         * See the comment of each parameter.
+         */
+        'PWA.changeAppUserSettings': {
+            paramsType: [Protocol.PWA.ChangeAppUserSettingsRequest];
+            returnType: void;
+        };
+        /**
+         * Enable the BluetoothEmulation domain.
+         */
+        'BluetoothEmulation.enable': {
+            paramsType: [Protocol.BluetoothEmulation.EnableRequest];
+            returnType: void;
+        };
+        /**
+         * Disable the BluetoothEmulation domain.
+         */
+        'BluetoothEmulation.disable': {
+            paramsType: [];
+            returnType: void;
+        };
+        /**
+         * Simulates a peripheral with |address|, |name| and |knownServiceUuids|
+         * that has already been connected to the system.
+         */
+        'BluetoothEmulation.simulatePreconnectedPeripheral': {
+            paramsType: [Protocol.BluetoothEmulation.SimulatePreconnectedPeripheralRequest];
+            returnType: void;
+        };
+        /**
+         * Simulates an advertisement packet described in |entry| being received by
+         * the central.
+         */
+        'BluetoothEmulation.simulateAdvertisement': {
+            paramsType: [Protocol.BluetoothEmulation.SimulateAdvertisementRequest];
+            returnType: void;
+        };
     }
 }
 
diff --git a/node_modules/devtools-protocol/types/protocol-proxy-api.d.ts b/node_modules/devtools-protocol/types/protocol-proxy-api.d.ts
index eae6317..ff41fb3 100644
--- a/node_modules/devtools-protocol/types/protocol-proxy-api.d.ts
+++ b/node_modules/devtools-protocol/types/protocol-proxy-api.d.ts
@@ -26,10 +26,12 @@ export namespace ProtocolProxyApi {
 
         Animation: AnimationApi;
 
-        ApplicationCache: ApplicationCacheApi;
-
         Audits: AuditsApi;
 
+        Extensions: ExtensionsApi;
+
+        Autofill: AutofillApi;
+
         BackgroundService: BackgroundServiceApi;
 
         Browser: BrowserApi;
@@ -44,6 +46,8 @@ export namespace ProtocolProxyApi {
 
         DOMDebugger: DOMDebuggerApi;
 
+        EventBreakpoints: EventBreakpointsApi;
+
         DOMSnapshot: DOMSnapshotApi;
 
         DOMStorage: DOMStorageApi;
@@ -58,6 +62,8 @@ export namespace ProtocolProxyApi {
 
         IO: IOApi;
 
+        FileSystem: FileSystemApi;
+
         IndexedDB: IndexedDBApi;
 
         Input: InputApi;
@@ -102,6 +108,16 @@ export namespace ProtocolProxyApi {
 
         Media: MediaApi;
 
+        DeviceAccess: DeviceAccessApi;
+
+        Preload: PreloadApi;
+
+        FedCm: FedCmApi;
+
+        PWA: PWAApi;
+
+        BluetoothEmulation: BluetoothEmulationApi;
+
     }
 
 
@@ -162,6 +178,16 @@ export namespace ProtocolProxyApi {
          */
         getScriptSource(params: Protocol.Debugger.GetScriptSourceRequest): Promise<Protocol.Debugger.GetScriptSourceResponse>;
 
+        disassembleWasmModule(params: Protocol.Debugger.DisassembleWasmModuleRequest): Promise<Protocol.Debugger.DisassembleWasmModuleResponse>;
+
+        /**
+         * Disassemble the next chunk of lines for the module corresponding to the
+         * stream. If disassembly is complete, this API will invalidate the streamId
+         * and return an empty chunk. Any subsequent calls for the now invalid stream
+         * will return errors.
+         */
+        nextWasmDisassemblyChunk(params: Protocol.Debugger.NextWasmDisassemblyChunkRequest): Promise<Protocol.Debugger.NextWasmDisassemblyChunkResponse>;
+
         /**
          * This command is deprecated. Use getScriptSource instead.
          */
@@ -185,7 +211,19 @@ export namespace ProtocolProxyApi {
         removeBreakpoint(params: Protocol.Debugger.RemoveBreakpointRequest): Promise<void>;
 
         /**
-         * Restarts particular call frame from the beginning.
+         * Restarts particular call frame from the beginning. The old, deprecated
+         * behavior of `restartFrame` is to stay paused and allow further CDP commands
+         * after a restart was scheduled. This can cause problems with restarting, so
+         * we now continue execution immediatly after it has been scheduled until we
+         * reach the beginning of the restarted frame.
+         * 
+         * To stay back-wards compatible, `restartFrame` now expects a `mode`
+         * parameter to be present. If the `mode` parameter is missing, `restartFrame`
+         * errors out.
+         * 
+         * The various return values are deprecated and `callFrames` is always empty.
+         * Use the call frames from the `Debugger#paused` events instead, that fires
+         * once V8 pauses at the beginning of the restarted function.
          */
         restartFrame(params: Protocol.Debugger.RestartFrameRequest): Promise<Protocol.Debugger.RestartFrameResponse>;
 
@@ -250,8 +288,8 @@ export namespace ProtocolProxyApi {
         setBreakpointsActive(params: Protocol.Debugger.SetBreakpointsActiveRequest): Promise<void>;
 
         /**
-         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or
-         * no exceptions. Initial pause on exceptions state is `none`.
+         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
+         * or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
          */
         setPauseOnExceptions(params: Protocol.Debugger.SetPauseOnExceptionsRequest): Promise<void>;
 
@@ -262,6 +300,12 @@ export namespace ProtocolProxyApi {
 
         /**
          * Edits JavaScript source live.
+         * 
+         * In general, functions that are currently on the stack can not be edited with
+         * a single exception: If the edited function is the top-most stack frame and
+         * that is the only activation of that function on the stack. In this case
+         * the live edit will be successful and a `Debugger.restartFrame` for the
+         * top-most function is automatically triggered.
          */
         setScriptSource(params: Protocol.Debugger.SetScriptSourceRequest): Promise<Protocol.Debugger.SetScriptSourceResponse>;
 
@@ -393,11 +437,6 @@ export namespace ProtocolProxyApi {
          */
         startPreciseCoverage(params: Protocol.Profiler.StartPreciseCoverageRequest): Promise<Protocol.Profiler.StartPreciseCoverageResponse>;
 
-        /**
-         * Enable type profile.
-         */
-        startTypeProfile(): Promise<void>;
-
         stop(): Promise<Protocol.Profiler.StopResponse>;
 
         /**
@@ -406,22 +445,12 @@ export namespace ProtocolProxyApi {
          */
         stopPreciseCoverage(): Promise<void>;
 
-        /**
-         * Disable type profile. Disabling releases type profile data collected so far.
-         */
-        stopTypeProfile(): Promise<void>;
-
         /**
          * Collect coverage data for the current isolate, and resets execution counters. Precise code
          * coverage needs to have started.
          */
         takePreciseCoverage(): Promise<Protocol.Profiler.TakePreciseCoverageResponse>;
 
-        /**
-         * Collect type profile.
-         */
-        takeTypeProfile(): Promise<Protocol.Profiler.TakeTypeProfileResponse>;
-
         on(event: 'consoleProfileFinished', listener: (params: Protocol.Profiler.ConsoleProfileFinishedEvent) => void): void;
 
         /**
@@ -553,6 +582,15 @@ export namespace ProtocolProxyApi {
          */
         removeBinding(params: Protocol.Runtime.RemoveBindingRequest): Promise<void>;
 
+        /**
+         * This method tries to lookup and populate exception details for a
+         * JavaScript Error object.
+         * Note that the stackTrace portion of the resulting exceptionDetails will
+         * only be populated if the Runtime domain was enabled at the time when the
+         * Error was thrown.
+         */
+        getExceptionDetails(params: Protocol.Runtime.GetExceptionDetailsRequest): Promise<Protocol.Runtime.GetExceptionDetailsResponse>;
+
         /**
          * Notification is issued every time when binding is called.
          */
@@ -626,6 +664,18 @@ export namespace ProtocolProxyApi {
          */
         getFullAXTree(params: Protocol.Accessibility.GetFullAXTreeRequest): Promise<Protocol.Accessibility.GetFullAXTreeResponse>;
 
+        /**
+         * Fetches the root node.
+         * Requires `enable()` to have been called previously.
+         */
+        getRootAXNode(params: Protocol.Accessibility.GetRootAXNodeRequest): Promise<Protocol.Accessibility.GetRootAXNodeResponse>;
+
+        /**
+         * Fetches a node and all ancestors up to and including the root.
+         * Requires `enable()` to have been called previously.
+         */
+        getAXNodeAndAncestors(params: Protocol.Accessibility.GetAXNodeAndAncestorsRequest): Promise<Protocol.Accessibility.GetAXNodeAndAncestorsResponse>;
+
         /**
          * Fetches a particular accessibility node by AXNodeId.
          * Requires `enable()` to have been called previously.
@@ -635,12 +685,23 @@ export namespace ProtocolProxyApi {
         /**
          * Query a DOM node's accessibility subtree for accessible name and role.
          * This command computes the name and role for all nodes in the subtree, including those that are
-         * ignored for accessibility, and returns those that mactch the specified name and role. If no DOM
+         * ignored for accessibility, and returns those that match the specified name and role. If no DOM
          * node is specified, or the DOM node does not exist, the command returns an error. If neither
          * `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
          */
         queryAXTree(params: Protocol.Accessibility.QueryAXTreeRequest): Promise<Protocol.Accessibility.QueryAXTreeResponse>;
 
+        /**
+         * The loadComplete event mirrors the load complete event sent by the browser to assistive
+         * technology when the web page has finished loading.
+         */
+        on(event: 'loadComplete', listener: (params: Protocol.Accessibility.LoadCompleteEvent) => void): void;
+
+        /**
+         * The nodesUpdated event is sent every time a previously requested node has changed the in tree.
+         */
+        on(event: 'nodesUpdated', listener: (params: Protocol.Accessibility.NodesUpdatedEvent) => void): void;
+
     }
 
     export interface AnimationApi {
@@ -709,61 +770,107 @@ export namespace ProtocolProxyApi {
          */
         on(event: 'animationStarted', listener: (params: Protocol.Animation.AnimationStartedEvent) => void): void;
 
+        /**
+         * Event for animation that has been updated.
+         */
+        on(event: 'animationUpdated', listener: (params: Protocol.Animation.AnimationUpdatedEvent) => void): void;
+
     }
 
-    export interface ApplicationCacheApi {
+    export interface AuditsApi {
+        /**
+         * Returns the response body and size if it were re-encoded with the specified settings. Only
+         * applies to images.
+         */
+        getEncodedResponse(params: Protocol.Audits.GetEncodedResponseRequest): Promise<Protocol.Audits.GetEncodedResponseResponse>;
+
         /**
-         * Enables application cache domain notifications.
+         * Disables issues domain, prevents further issues from being reported to the client.
+         */
+        disable(): Promise<void>;
+
+        /**
+         * Enables issues domain, sends the issues collected so far to the client by means of the
+         * `issueAdded` event.
          */
         enable(): Promise<void>;
 
         /**
-         * Returns relevant application cache data for the document in given frame.
+         * Runs the contrast check for the target page. Found issues are reported
+         * using Audits.issueAdded event.
+         */
+        checkContrast(params: Protocol.Audits.CheckContrastRequest): Promise<void>;
+
+        /**
+         * Runs the form issues check for the target page. Found issues are reported
+         * using Audits.issueAdded event.
          */
-        getApplicationCacheForFrame(params: Protocol.ApplicationCache.GetApplicationCacheForFrameRequest): Promise<Protocol.ApplicationCache.GetApplicationCacheForFrameResponse>;
+        checkFormsIssues(): Promise<Protocol.Audits.CheckFormsIssuesResponse>;
+
+        on(event: 'issueAdded', listener: (params: Protocol.Audits.IssueAddedEvent) => void): void;
 
+    }
+
+    export interface ExtensionsApi {
         /**
-         * Returns array of frame identifiers with manifest urls for each frame containing a document
-         * associated with some application cache.
+         * Installs an unpacked extension from the filesystem similar to
+         * --load-extension CLI flags. Returns extension ID once the extension
+         * has been installed. Available if the client is connected using the
+         * --remote-debugging-pipe flag and the --enable-unsafe-extension-debugging
+         * flag is set.
          */
-        getFramesWithManifests(): Promise<Protocol.ApplicationCache.GetFramesWithManifestsResponse>;
+        loadUnpacked(params: Protocol.Extensions.LoadUnpackedRequest): Promise<Protocol.Extensions.LoadUnpackedResponse>;
 
         /**
-         * Returns manifest URL for document in the given frame.
+         * Gets data from extension storage in the given `storageArea`. If `keys` is
+         * specified, these are used to filter the result.
          */
-        getManifestForFrame(params: Protocol.ApplicationCache.GetManifestForFrameRequest): Promise<Protocol.ApplicationCache.GetManifestForFrameResponse>;
+        getStorageItems(params: Protocol.Extensions.GetStorageItemsRequest): Promise<Protocol.Extensions.GetStorageItemsResponse>;
 
-        on(event: 'applicationCacheStatusUpdated', listener: (params: Protocol.ApplicationCache.ApplicationCacheStatusUpdatedEvent) => void): void;
+        /**
+         * Removes `keys` from extension storage in the given `storageArea`.
+         */
+        removeStorageItems(params: Protocol.Extensions.RemoveStorageItemsRequest): Promise<void>;
+
+        /**
+         * Clears extension storage in the given `storageArea`.
+         */
+        clearStorageItems(params: Protocol.Extensions.ClearStorageItemsRequest): Promise<void>;
 
-        on(event: 'networkStateUpdated', listener: (params: Protocol.ApplicationCache.NetworkStateUpdatedEvent) => void): void;
+        /**
+         * Sets `values` in extension storage in the given `storageArea`. The provided `values`
+         * will be merged with existing values in the storage area.
+         */
+        setStorageItems(params: Protocol.Extensions.SetStorageItemsRequest): Promise<void>;
 
     }
 
-    export interface AuditsApi {
+    export interface AutofillApi {
         /**
-         * Returns the response body and size if it were re-encoded with the specified settings. Only
-         * applies to images.
+         * Trigger autofill on a form identified by the fieldId.
+         * If the field and related form cannot be autofilled, returns an error.
          */
-        getEncodedResponse(params: Protocol.Audits.GetEncodedResponseRequest): Promise<Protocol.Audits.GetEncodedResponseResponse>;
+        trigger(params: Protocol.Autofill.TriggerRequest): Promise<void>;
 
         /**
-         * Disables issues domain, prevents further issues from being reported to the client.
+         * Set addresses so that developers can verify their forms implementation.
+         */
+        setAddresses(params: Protocol.Autofill.SetAddressesRequest): Promise<void>;
+
+        /**
+         * Disables autofill domain notifications.
          */
         disable(): Promise<void>;
 
         /**
-         * Enables issues domain, sends the issues collected so far to the client by means of the
-         * `issueAdded` event.
+         * Enables autofill domain notifications.
          */
         enable(): Promise<void>;
 
         /**
-         * Runs the contrast check for the target page. Found issues are reported
-         * using Audits.issueAdded event.
+         * Emitted when an address form is filled.
          */
-        checkContrast(params: Protocol.Audits.CheckContrastRequest): Promise<void>;
-
-        on(event: 'issueAdded', listener: (params: Protocol.Audits.IssueAddedEvent) => void): void;
+        on(event: 'addressFormFilled', listener: (params: Protocol.Autofill.AddressFormFilledEvent) => void): void;
 
     }
 
@@ -888,6 +995,12 @@ export namespace ProtocolProxyApi {
          */
         executeBrowserCommand(params: Protocol.Browser.ExecuteBrowserCommandRequest): Promise<void>;
 
+        /**
+         * Allows a site to use privacy sandbox features that require enrollment
+         * without the site actually being enrolled. Only supported on page targets.
+         */
+        addPrivacySandboxEnrollmentOverride(params: Protocol.Browser.AddPrivacySandboxEnrollmentOverrideRequest): Promise<void>;
+
         /**
          * Fired when page is about to start a download.
          */
@@ -968,6 +1081,20 @@ export namespace ProtocolProxyApi {
          */
         getStyleSheetText(params: Protocol.CSS.GetStyleSheetTextRequest): Promise<Protocol.CSS.GetStyleSheetTextResponse>;
 
+        /**
+         * Returns all layers parsed by the rendering engine for the tree scope of a node.
+         * Given a DOM element identified by nodeId, getLayersForNode returns the root
+         * layer for the nearest ancestor document or shadow root. The layer root contains
+         * the full layer tree for the tree scope and their ordering.
+         */
+        getLayersForNode(params: Protocol.CSS.GetLayersForNodeRequest): Promise<Protocol.CSS.GetLayersForNodeResponse>;
+
+        /**
+         * Given a CSS selector text and a style sheet ID, getLocationForSelector
+         * returns an array of locations of the CSS selector in the style sheet.
+         */
+        getLocationForSelector(params: Protocol.CSS.GetLocationForSelectorRequest): Promise<Protocol.CSS.GetLocationForSelectorResponse>;
+
         /**
          * Starts tracking the given computed styles for updates. The specified array of properties
          * replaces the one previously specified. Pass empty array to disable tracking.
@@ -989,6 +1116,11 @@ export namespace ProtocolProxyApi {
          */
         setEffectivePropertyValueForNode(params: Protocol.CSS.SetEffectivePropertyValueForNodeRequest): Promise<void>;
 
+        /**
+         * Modifies the property rule property name.
+         */
+        setPropertyRulePropertyName(params: Protocol.CSS.SetPropertyRulePropertyNameRequest): Promise<Protocol.CSS.SetPropertyRulePropertyNameResponse>;
+
         /**
          * Modifies the keyframe rule key text.
          */
@@ -1004,6 +1136,16 @@ export namespace ProtocolProxyApi {
          */
         setContainerQueryText(params: Protocol.CSS.SetContainerQueryTextRequest): Promise<Protocol.CSS.SetContainerQueryTextResponse>;
 
+        /**
+         * Modifies the expression of a supports at-rule.
+         */
+        setSupportsText(params: Protocol.CSS.SetSupportsTextRequest): Promise<Protocol.CSS.SetSupportsTextResponse>;
+
+        /**
+         * Modifies the expression of a scope at-rule.
+         */
+        setScopeText(params: Protocol.CSS.SetScopeTextRequest): Promise<Protocol.CSS.SetScopeTextResponse>;
+
         /**
          * Modifies the rule selector.
          */
@@ -1026,13 +1168,13 @@ export namespace ProtocolProxyApi {
 
         /**
          * Stop tracking rule usage and return the list of rules that were used since last call to
-         * `takeCoverageDelta` (or since start of coverage instrumentation)
+         * `takeCoverageDelta` (or since start of coverage instrumentation).
          */
         stopRuleUsageTracking(): Promise<Protocol.CSS.StopRuleUsageTrackingResponse>;
 
         /**
          * Obtain list of rules that became used since last call to this method (or since start of coverage
-         * instrumentation)
+         * instrumentation).
          */
         takeCoverageDelta(): Promise<Protocol.CSS.TakeCoverageDeltaResponse>;
 
@@ -1043,7 +1185,7 @@ export namespace ProtocolProxyApi {
 
         /**
          * Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
-         * web font
+         * web font.
          */
         on(event: 'fontsUpdated', listener: (params: Protocol.CSS.FontsUpdatedEvent) => void): void;
 
@@ -1119,6 +1261,11 @@ export namespace ProtocolProxyApi {
          */
         setSinkToUse(params: Protocol.Cast.SetSinkToUseRequest): Promise<void>;
 
+        /**
+         * Starts mirroring the desktop to the sink.
+         */
+        startDesktopMirroring(params: Protocol.Cast.StartDesktopMirroringRequest): Promise<void>;
+
         /**
          * Starts mirroring the tab to the sink.
          */
@@ -1182,7 +1329,7 @@ export namespace ProtocolProxyApi {
         /**
          * Enables DOM agent for the given page.
          */
-        enable(): Promise<void>;
+        enable(params: Protocol.DOM.EnableRequest): Promise<void>;
 
         /**
          * Focuses the given element.
@@ -1207,6 +1354,7 @@ export namespace ProtocolProxyApi {
 
         /**
          * Returns the root DOM node (and optionally the subtree) to the caller.
+         * Implicitly enables the DOM domain events for the current target.
          */
         getDocument(params: Protocol.DOM.GetDocumentRequest): Promise<Protocol.DOM.GetDocumentResponse>;
 
@@ -1295,6 +1443,18 @@ export namespace ProtocolProxyApi {
          */
         querySelectorAll(params: Protocol.DOM.QuerySelectorAllRequest): Promise<Protocol.DOM.QuerySelectorAllResponse>;
 
+        /**
+         * Returns NodeIds of current top layer elements.
+         * Top layer is rendered closest to the user within a viewport, therefore its elements always
+         * appear on top of all other content.
+         */
+        getTopLayerElements(): Promise<Protocol.DOM.GetTopLayerElementsResponse>;
+
+        /**
+         * Returns the NodeId of the matched element according to certain relations.
+         */
+        getElementByRelation(params: Protocol.DOM.GetElementByRelationRequest): Promise<Protocol.DOM.GetElementByRelationResponse>;
+
         /**
          * Re-does the last undone action.
          */
@@ -1361,6 +1521,11 @@ export namespace ProtocolProxyApi {
          */
         getFileInfo(params: Protocol.DOM.GetFileInfoRequest): Promise<Protocol.DOM.GetFileInfoResponse>;
 
+        /**
+         * Returns list of detached nodes
+         */
+        getDetachedDomNodes(): Promise<Protocol.DOM.GetDetachedDomNodesResponse>;
+
         /**
          * Enables console to refer to the node with given id via $x (see Command Line API for more details
          * $x functions).
@@ -1393,9 +1558,10 @@ export namespace ProtocolProxyApi {
         getFrameOwner(params: Protocol.DOM.GetFrameOwnerRequest): Promise<Protocol.DOM.GetFrameOwnerResponse>;
 
         /**
-         * Returns the container of the given node based on container query conditions.
-         * If containerName is given, it will find the nearest container with a matching name;
-         * otherwise it will find the nearest container regardless of its container name.
+         * Returns the query container of the given node based on container query
+         * conditions: containerName, physical, and logical axes. If no axes are
+         * provided, the style container is returned, which is the direct parent or the
+         * closest element with a matching container-name.
          */
         getContainerForNode(params: Protocol.DOM.GetContainerForNodeRequest): Promise<Protocol.DOM.GetContainerForNodeResponse>;
 
@@ -1405,6 +1571,12 @@ export namespace ProtocolProxyApi {
          */
         getQueryingDescendantsForContainer(params: Protocol.DOM.GetQueryingDescendantsForContainerRequest): Promise<Protocol.DOM.GetQueryingDescendantsForContainerResponse>;
 
+        /**
+         * Returns the target anchor element of the given anchor query according to
+         * https://www.w3.org/TR/css-anchor-position-1/#target.
+         */
+        getAnchorElement(params: Protocol.DOM.GetAnchorElementRequest): Promise<Protocol.DOM.GetAnchorElementResponse>;
+
         /**
          * Fired when `Element`'s attribute is modified.
          */
@@ -1455,6 +1627,11 @@ export namespace ProtocolProxyApi {
          */
         on(event: 'pseudoElementAdded', listener: (params: Protocol.DOM.PseudoElementAddedEvent) => void): void;
 
+        /**
+         * Called when top layer elements are changed.
+         */
+        on(event: 'topLayerElementsUpdated', listener: () => void): void;
+
         /**
          * Called when a pseudo element is removed from an element.
          */
@@ -1531,6 +1708,24 @@ export namespace ProtocolProxyApi {
 
     }
 
+    export interface EventBreakpointsApi {
+        /**
+         * Sets breakpoint on particular native event.
+         */
+        setInstrumentationBreakpoint(params: Protocol.EventBreakpoints.SetInstrumentationBreakpointRequest): Promise<void>;
+
+        /**
+         * Removes breakpoint on particular native event.
+         */
+        removeInstrumentationBreakpoint(params: Protocol.EventBreakpoints.RemoveInstrumentationBreakpointRequest): Promise<void>;
+
+        /**
+         * Removes all breakpoints
+         */
+        disable(): Promise<void>;
+
+    }
+
     export interface DOMSnapshotApi {
         /**
          * Disables DOM snapshot agent for the given page.
@@ -1670,6 +1865,20 @@ export namespace ProtocolProxyApi {
          */
         setDeviceMetricsOverride(params: Protocol.Emulation.SetDeviceMetricsOverrideRequest): Promise<void>;
 
+        /**
+         * Start reporting the given posture value to the Device Posture API.
+         * This override can also be set in setDeviceMetricsOverride().
+         */
+        setDevicePostureOverride(params: Protocol.Emulation.SetDevicePostureOverrideRequest): Promise<void>;
+
+        /**
+         * Clears a device posture override set with either setDeviceMetricsOverride()
+         * or setDevicePostureOverride() and starts using posture information from the
+         * platform again.
+         * Does nothing if no override is set.
+         */
+        clearDevicePostureOverride(): Promise<void>;
+
         setScrollbarsHidden(params: Protocol.Emulation.SetScrollbarsHiddenRequest): Promise<void>;
 
         setDocumentCookieDisabled(params: Protocol.Emulation.SetDocumentCookieDisabledRequest): Promise<void>;
@@ -1692,6 +1901,38 @@ export namespace ProtocolProxyApi {
          */
         setGeolocationOverride(params: Protocol.Emulation.SetGeolocationOverrideRequest): Promise<void>;
 
+        getOverriddenSensorInformation(params: Protocol.Emulation.GetOverriddenSensorInformationRequest): Promise<Protocol.Emulation.GetOverriddenSensorInformationResponse>;
+
+        /**
+         * Overrides a platform sensor of a given type. If |enabled| is true, calls to
+         * Sensor.start() will use a virtual sensor as backend rather than fetching
+         * data from a real hardware sensor. Otherwise, existing virtual
+         * sensor-backend Sensor objects will fire an error event and new calls to
+         * Sensor.start() will attempt to use a real sensor instead.
+         */
+        setSensorOverrideEnabled(params: Protocol.Emulation.SetSensorOverrideEnabledRequest): Promise<void>;
+
+        /**
+         * Updates the sensor readings reported by a sensor type previously overridden
+         * by setSensorOverrideEnabled.
+         */
+        setSensorOverrideReadings(params: Protocol.Emulation.SetSensorOverrideReadingsRequest): Promise<void>;
+
+        /**
+         * Overrides a pressure source of a given type, as used by the Compute
+         * Pressure API, so that updates to PressureObserver.observe() are provided
+         * via setPressureStateOverride instead of being retrieved from
+         * platform-provided telemetry data.
+         */
+        setPressureSourceOverrideEnabled(params: Protocol.Emulation.SetPressureSourceOverrideEnabledRequest): Promise<void>;
+
+        /**
+         * Provides a given pressure state that will be processed and eventually be
+         * delivered to PressureObserver users. |source| must have been previously
+         * overridden by setPressureSourceOverrideEnabled.
+         */
+        setPressureStateOverride(params: Protocol.Emulation.SetPressureStateOverrideRequest): Promise<void>;
+
         /**
          * Overrides the Idle state.
          */
@@ -1747,11 +1988,19 @@ export namespace ProtocolProxyApi {
 
         setDisabledImageTypes(params: Protocol.Emulation.SetDisabledImageTypesRequest): Promise<void>;
 
+        setHardwareConcurrencyOverride(params: Protocol.Emulation.SetHardwareConcurrencyOverrideRequest): Promise<void>;
+
         /**
          * Allows overriding user agent with the given string.
+         * `userAgentMetadata` must be set for Client Hint headers to be sent.
          */
         setUserAgentOverride(params: Protocol.Emulation.SetUserAgentOverrideRequest): Promise<void>;
 
+        /**
+         * Allows overriding the automation flag.
+         */
+        setAutomationOverride(params: Protocol.Emulation.SetAutomationOverrideRequest): Promise<void>;
+
         /**
          * Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
          */
@@ -1764,7 +2013,7 @@ export namespace ProtocolProxyApi {
          * Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
          * screenshot from the resulting frame. Requires that the target was created with enabled
          * BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
-         * https://goo.gl/3zHXhB for more background.
+         * https://goo.gle/chrome-headless-rendering for more background.
          */
         beginFrame(params: Protocol.HeadlessExperimental.BeginFrameRequest): Promise<Protocol.HeadlessExperimental.BeginFrameResponse>;
 
@@ -1778,13 +2027,6 @@ export namespace ProtocolProxyApi {
          */
         enable(): Promise<void>;
 
-        /**
-         * Issued when the target starts or stops needing BeginFrames.
-         * Deprecated. Issue beginFrame unconditionally instead and use result from
-         * beginFrame to detect whether the frames were suppressed.
-         */
-        on(event: 'needsBeginFramesChanged', listener: (params: Protocol.HeadlessExperimental.NeedsBeginFramesChangedEvent) => void): void;
-
     }
 
     export interface IOApi {
@@ -1805,6 +2047,11 @@ export namespace ProtocolProxyApi {
 
     }
 
+    export interface FileSystemApi {
+        getDirectory(params: Protocol.FileSystem.GetDirectoryRequest): Promise<Protocol.FileSystem.GetDirectoryResponse>;
+
+    }
+
     export interface IndexedDBApi {
         /**
          * Clears all entries from an object store.
@@ -1837,7 +2084,7 @@ export namespace ProtocolProxyApi {
         requestData(params: Protocol.IndexedDB.RequestDataRequest): Promise<Protocol.IndexedDB.RequestDataResponse>;
 
         /**
-         * Gets metadata of an object store
+         * Gets metadata of an object store.
          */
         getMetadata(params: Protocol.IndexedDB.GetMetadataRequest): Promise<Protocol.IndexedDB.GetMetadataResponse>;
 
@@ -1871,7 +2118,7 @@ export namespace ProtocolProxyApi {
         insertText(params: Protocol.Input.InsertTextRequest): Promise<void>;
 
         /**
-         * This method sets the current candidate text for ime.
+         * This method sets the current candidate text for IME.
          * Use imeCommitComposition to commit the final text.
          * Use imeSetComposition with empty string as text to cancel composition.
          */
@@ -1887,6 +2134,11 @@ export namespace ProtocolProxyApi {
          */
         dispatchTouchEvent(params: Protocol.Input.DispatchTouchEventRequest): Promise<void>;
 
+        /**
+         * Cancels any active dragging in the page.
+         */
+        cancelDragging(): Promise<void>;
+
         /**
          * Emulates touch event from the mouse event parameters.
          */
@@ -2133,7 +2385,7 @@ export namespace ProtocolProxyApi {
         continueInterceptedRequest(params: Protocol.Network.ContinueInterceptedRequestRequest): Promise<void>;
 
         /**
-         * Deletes browser cookies with matching name and url or domain/path pair.
+         * Deletes browser cookies with matching name and url or domain/path/partitionKey pair.
          */
         deleteCookies(params: Protocol.Network.DeleteCookiesRequest): Promise<void>;
 
@@ -2155,6 +2407,7 @@ export namespace ProtocolProxyApi {
         /**
          * Returns all browser cookies. Depending on the backend support, will return detailed cookie
          * information in the `cookies` field.
+         * Deprecated. Use Storage.getCookies instead.
          */
         getAllCookies(): Promise<Protocol.Network.GetAllCookiesResponse>;
 
@@ -2250,6 +2503,12 @@ export namespace ProtocolProxyApi {
          */
         setUserAgentOverride(params: Protocol.Network.SetUserAgentOverrideRequest): Promise<void>;
 
+        /**
+         * Enables streaming of the response for the given requestId.
+         * If enabled, the dataReceived event contains the data that was received during streaming.
+         */
+        streamResourceContent(params: Protocol.Network.StreamResourceContentRequest): Promise<Protocol.Network.StreamResourceContentResponse>;
+
         /**
          * Returns information about the COEP/COOP isolation status.
          */
@@ -2383,6 +2642,13 @@ export namespace ProtocolProxyApi {
          */
         on(event: 'responseReceivedExtraInfo', listener: (params: Protocol.Network.ResponseReceivedExtraInfoEvent) => void): void;
 
+        /**
+         * Fired when 103 Early Hints headers is received in addition to the common response.
+         * Not every responseReceived event will have an responseReceivedEarlyHints fired.
+         * Only one responseReceivedEarlyHints may be fired for eached responseReceived event.
+         */
+        on(event: 'responseReceivedEarlyHints', listener: (params: Protocol.Network.ResponseReceivedEarlyHintsEvent) => void): void;
+
         /**
          * Fired exactly once for each Trust Token operation. Depending on
          * the type of the operation and whether the operation succeeded or
@@ -2391,6 +2657,11 @@ export namespace ProtocolProxyApi {
          */
         on(event: 'trustTokenOperationDone', listener: (params: Protocol.Network.TrustTokenOperationDoneEvent) => void): void;
 
+        /**
+         * Fired once security policy has been updated.
+         */
+        on(event: 'policyUpdated', listener: () => void): void;
+
         /**
          * Fired once when parsing the .wbn file has succeeded.
          * The event contains the information about the web bundle contents.
@@ -2421,6 +2692,8 @@ export namespace ProtocolProxyApi {
 
         on(event: 'reportingApiReportUpdated', listener: (params: Protocol.Network.ReportingApiReportUpdatedEvent) => void): void;
 
+        on(event: 'reportingApiEndpointsChangedForOrigin', listener: (params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent) => void): void;
+
     }
 
     export interface OverlayApi {
@@ -2456,8 +2729,8 @@ export namespace ProtocolProxyApi {
 
         /**
          * Highlights owner element of the frame with given id.
-         * Deprecated: Doesn't work reliablity and cannot be fixed due to process
-         * separatation (the owner node might be in a different process). Determine
+         * Deprecated: Doesn't work reliably and cannot be fixed due to process
+         * separation (the owner node might be in a different process). Determine
          * the owner node in the client and use highlightNode.
          */
         highlightFrame(params: Protocol.Overlay.HighlightFrameRequest): Promise<void>;
@@ -2534,7 +2807,7 @@ export namespace ProtocolProxyApi {
         setShowScrollBottleneckRects(params: Protocol.Overlay.SetShowScrollBottleneckRectsRequest): Promise<void>;
 
         /**
-         * Requests that backend shows hit-test borders on layers
+         * Deprecated, no longer has any effect.
          */
         setShowHitTestBorders(params: Protocol.Overlay.SetShowHitTestBordersRequest): Promise<void>;
 
@@ -2558,6 +2831,11 @@ export namespace ProtocolProxyApi {
          */
         setShowIsolatedElements(params: Protocol.Overlay.SetShowIsolatedElementsRequest): Promise<void>;
 
+        /**
+         * Show Window Controls Overlay for PWA
+         */
+        setShowWindowControlsOverlay(params: Protocol.Overlay.SetShowWindowControlsOverlayRequest): Promise<void>;
+
         /**
          * Fired when the node should be inspected. This happens after call to `setInspectMode` or when
          * user manually inspects an element.
@@ -2643,10 +2921,20 @@ export namespace ProtocolProxyApi {
          */
         enable(): Promise<void>;
 
-        getAppManifest(): Promise<Protocol.Page.GetAppManifestResponse>;
+        /**
+         * Gets the processed manifest for this current document.
+         *   This API always waits for the manifest to be loaded.
+         *   If manifestId is provided, and it does not match the manifest of the
+         *     current document, this API errors out.
+         *   If there is not a loaded page, this API errors out immediately.
+         */
+        getAppManifest(params: Protocol.Page.GetAppManifestRequest): Promise<Protocol.Page.GetAppManifestResponse>;
 
         getInstallabilityErrors(): Promise<Protocol.Page.GetInstallabilityErrorsResponse>;
 
+        /**
+         * Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.
+         */
         getManifestIcons(): Promise<Protocol.Page.GetManifestIconsResponse>;
 
         /**
@@ -2655,11 +2943,7 @@ export namespace ProtocolProxyApi {
          */
         getAppId(): Promise<Protocol.Page.GetAppIdResponse>;
 
-        /**
-         * Returns all browser cookies. Depending on the backend support, will return detailed cookie
-         * information in the `cookies` field.
-         */
-        getCookies(): Promise<Protocol.Page.GetCookiesResponse>;
+        getAdScriptId(params: Protocol.Page.GetAdScriptIdRequest): Promise<Protocol.Page.GetAdScriptIdResponse>;
 
         /**
          * Returns present frame tree structure.
@@ -2836,19 +3120,10 @@ export namespace ProtocolProxyApi {
          */
         stopScreencast(): Promise<void>;
 
-        /**
-         * Forces compilation cache to be generated for every subresource script.
-         * See also: `Page.produceCompilationCache`.
-         */
-        setProduceCompilationCache(params: Protocol.Page.SetProduceCompilationCacheRequest): Promise<void>;
-
         /**
          * Requests backend to produce compilation cache for the specified scripts.
-         * Unlike setProduceCompilationCache, this allows client to only produce cache
-         * for specific scripts. `scripts` are appeneded to the list of scripts
-         * for which the cache for would produced. Disabling compilation cache with
-         * `setProduceCompilationCache` would reset all pending cache requests.
-         * The list may also be reset during page navigation.
+         * `scripts` are appended to the list of scripts for which the cache
+         * would be produced. The list may be reset during page navigation.
          * When script with a matching URL is encountered, the cache is optionally
          * produced upon backend discretion, based on internal heuristics.
          * See also: `Page.compilationCacheProduced`.
@@ -2866,6 +3141,18 @@ export namespace ProtocolProxyApi {
          */
         clearCompilationCache(): Promise<void>;
 
+        /**
+         * Sets the Secure Payment Confirmation transaction mode.
+         * https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
+         */
+        setSPCTransactionMode(params: Protocol.Page.SetSPCTransactionModeRequest): Promise<void>;
+
+        /**
+         * Extensions for Custom Handlers API:
+         * https://html.spec.whatwg.org/multipage/system-state.html#rph-automation
+         */
+        setRPHRegistrationMode(params: Protocol.Page.SetRPHRegistrationModeRequest): Promise<void>;
+
         /**
          * Generates a report for testing.
          */
@@ -2883,6 +3170,17 @@ export namespace ProtocolProxyApi {
          */
         setInterceptFileChooserDialog(params: Protocol.Page.SetInterceptFileChooserDialogRequest): Promise<void>;
 
+        /**
+         * Enable/disable prerendering manually.
+         * 
+         * This command is a short-term solution for https://crbug.com/1440085.
+         * See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
+         * for more details.
+         * 
+         * TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.
+         */
+        setPrerenderingAllowed(params: Protocol.Page.SetPrerenderingAllowedRequest): Promise<void>;
+
         on(event: 'domContentEventFired', listener: (params: Protocol.Page.DomContentEventFiredEvent) => void): void;
 
         /**
@@ -3101,7 +3399,7 @@ export namespace ProtocolProxyApi {
         on(event: 'visibleSecurityStateChanged', listener: (params: Protocol.Security.VisibleSecurityStateChangedEvent) => void): void;
 
         /**
-         * The security state of the page changed.
+         * The security state of the page changed. No longer being sent.
          */
         on(event: 'securityStateChanged', listener: (params: Protocol.Security.SecurityStateChangedEvent) => void): void;
 
@@ -3143,11 +3441,21 @@ export namespace ProtocolProxyApi {
     }
 
     export interface StorageApi {
+        /**
+         * Returns a storage key given a frame id.
+         */
+        getStorageKeyForFrame(params: Protocol.Storage.GetStorageKeyForFrameRequest): Promise<Protocol.Storage.GetStorageKeyForFrameResponse>;
+
         /**
          * Clears storage for origin.
          */
         clearDataForOrigin(params: Protocol.Storage.ClearDataForOriginRequest): Promise<void>;
 
+        /**
+         * Clears storage for storage key.
+         */
+        clearDataForStorageKey(params: Protocol.Storage.ClearDataForStorageKeyRequest): Promise<void>;
+
         /**
          * Returns all browser cookies.
          */
@@ -3178,21 +3486,41 @@ export namespace ProtocolProxyApi {
          */
         trackCacheStorageForOrigin(params: Protocol.Storage.TrackCacheStorageForOriginRequest): Promise<void>;
 
+        /**
+         * Registers storage key to be notified when an update occurs to its cache storage list.
+         */
+        trackCacheStorageForStorageKey(params: Protocol.Storage.TrackCacheStorageForStorageKeyRequest): Promise<void>;
+
         /**
          * Registers origin to be notified when an update occurs to its IndexedDB.
          */
         trackIndexedDBForOrigin(params: Protocol.Storage.TrackIndexedDBForOriginRequest): Promise<void>;
 
+        /**
+         * Registers storage key to be notified when an update occurs to its IndexedDB.
+         */
+        trackIndexedDBForStorageKey(params: Protocol.Storage.TrackIndexedDBForStorageKeyRequest): Promise<void>;
+
         /**
          * Unregisters origin from receiving notifications for cache storage.
          */
         untrackCacheStorageForOrigin(params: Protocol.Storage.UntrackCacheStorageForOriginRequest): Promise<void>;
 
+        /**
+         * Unregisters storage key from receiving notifications for cache storage.
+         */
+        untrackCacheStorageForStorageKey(params: Protocol.Storage.UntrackCacheStorageForStorageKeyRequest): Promise<void>;
+
         /**
          * Unregisters origin from receiving notifications for IndexedDB.
          */
         untrackIndexedDBForOrigin(params: Protocol.Storage.UntrackIndexedDBForOriginRequest): Promise<void>;
 
+        /**
+         * Unregisters storage key from receiving notifications for IndexedDB.
+         */
+        untrackIndexedDBForStorageKey(params: Protocol.Storage.UntrackIndexedDBForStorageKeyRequest): Promise<void>;
+
         /**
          * Returns the number of stored Trust Tokens per issuer for the
          * current browsing context.
@@ -3205,6 +3533,94 @@ export namespace ProtocolProxyApi {
          */
         clearTrustTokens(params: Protocol.Storage.ClearTrustTokensRequest): Promise<Protocol.Storage.ClearTrustTokensResponse>;
 
+        /**
+         * Gets details for a named interest group.
+         */
+        getInterestGroupDetails(params: Protocol.Storage.GetInterestGroupDetailsRequest): Promise<Protocol.Storage.GetInterestGroupDetailsResponse>;
+
+        /**
+         * Enables/Disables issuing of interestGroupAccessed events.
+         */
+        setInterestGroupTracking(params: Protocol.Storage.SetInterestGroupTrackingRequest): Promise<void>;
+
+        /**
+         * Enables/Disables issuing of interestGroupAuctionEventOccurred and
+         * interestGroupAuctionNetworkRequestCreated.
+         */
+        setInterestGroupAuctionTracking(params: Protocol.Storage.SetInterestGroupAuctionTrackingRequest): Promise<void>;
+
+        /**
+         * Gets metadata for an origin's shared storage.
+         */
+        getSharedStorageMetadata(params: Protocol.Storage.GetSharedStorageMetadataRequest): Promise<Protocol.Storage.GetSharedStorageMetadataResponse>;
+
+        /**
+         * Gets the entries in an given origin's shared storage.
+         */
+        getSharedStorageEntries(params: Protocol.Storage.GetSharedStorageEntriesRequest): Promise<Protocol.Storage.GetSharedStorageEntriesResponse>;
+
+        /**
+         * Sets entry with `key` and `value` for a given origin's shared storage.
+         */
+        setSharedStorageEntry(params: Protocol.Storage.SetSharedStorageEntryRequest): Promise<void>;
+
+        /**
+         * Deletes entry for `key` (if it exists) for a given origin's shared storage.
+         */
+        deleteSharedStorageEntry(params: Protocol.Storage.DeleteSharedStorageEntryRequest): Promise<void>;
+
+        /**
+         * Clears all entries for a given origin's shared storage.
+         */
+        clearSharedStorageEntries(params: Protocol.Storage.ClearSharedStorageEntriesRequest): Promise<void>;
+
+        /**
+         * Resets the budget for `ownerOrigin` by clearing all budget withdrawals.
+         */
+        resetSharedStorageBudget(params: Protocol.Storage.ResetSharedStorageBudgetRequest): Promise<void>;
+
+        /**
+         * Enables/disables issuing of sharedStorageAccessed events.
+         */
+        setSharedStorageTracking(params: Protocol.Storage.SetSharedStorageTrackingRequest): Promise<void>;
+
+        /**
+         * Set tracking for a storage key's buckets.
+         */
+        setStorageBucketTracking(params: Protocol.Storage.SetStorageBucketTrackingRequest): Promise<void>;
+
+        /**
+         * Deletes the Storage Bucket with the given storage key and bucket name.
+         */
+        deleteStorageBucket(params: Protocol.Storage.DeleteStorageBucketRequest): Promise<void>;
+
+        /**
+         * Deletes state for sites identified as potential bounce trackers, immediately.
+         */
+        runBounceTrackingMitigations(): Promise<Protocol.Storage.RunBounceTrackingMitigationsResponse>;
+
+        /**
+         * https://wicg.github.io/attribution-reporting-api/
+         */
+        setAttributionReportingLocalTestingMode(params: Protocol.Storage.SetAttributionReportingLocalTestingModeRequest): Promise<void>;
+
+        /**
+         * Enables/disables issuing of Attribution Reporting events.
+         */
+        setAttributionReportingTracking(params: Protocol.Storage.SetAttributionReportingTrackingRequest): Promise<void>;
+
+        /**
+         * Sends all pending Attribution Reports immediately, regardless of their
+         * scheduled report time.
+         */
+        sendPendingAttributionReports(): Promise<Protocol.Storage.SendPendingAttributionReportsResponse>;
+
+        /**
+         * Returns the effective Related Website Sets in use by this profile for the browser
+         * session. The effective Related Website Sets will not change during a browser session.
+         */
+        getRelatedWebsiteSets(): Promise<Protocol.Storage.GetRelatedWebsiteSetsResponse>;
+
         /**
          * A cache's contents have been modified.
          */
@@ -3225,6 +3641,40 @@ export namespace ProtocolProxyApi {
          */
         on(event: 'indexedDBListUpdated', listener: (params: Protocol.Storage.IndexedDBListUpdatedEvent) => void): void;
 
+        /**
+         * One of the interest groups was accessed. Note that these events are global
+         * to all targets sharing an interest group store.
+         */
+        on(event: 'interestGroupAccessed', listener: (params: Protocol.Storage.InterestGroupAccessedEvent) => void): void;
+
+        /**
+         * An auction involving interest groups is taking place. These events are
+         * target-specific.
+         */
+        on(event: 'interestGroupAuctionEventOccurred', listener: (params: Protocol.Storage.InterestGroupAuctionEventOccurredEvent) => void): void;
+
+        /**
+         * Specifies which auctions a particular network fetch may be related to, and
+         * in what role. Note that it is not ordered with respect to
+         * Network.requestWillBeSent (but will happen before loadingFinished
+         * loadingFailed).
+         */
+        on(event: 'interestGroupAuctionNetworkRequestCreated', listener: (params: Protocol.Storage.InterestGroupAuctionNetworkRequestCreatedEvent) => void): void;
+
+        /**
+         * Shared storage was accessed by the associated page.
+         * The following parameters are included in all events.
+         */
+        on(event: 'sharedStorageAccessed', listener: (params: Protocol.Storage.SharedStorageAccessedEvent) => void): void;
+
+        on(event: 'storageBucketCreatedOrUpdated', listener: (params: Protocol.Storage.StorageBucketCreatedOrUpdatedEvent) => void): void;
+
+        on(event: 'storageBucketDeleted', listener: (params: Protocol.Storage.StorageBucketDeletedEvent) => void): void;
+
+        on(event: 'attributionReportingSourceRegistered', listener: (params: Protocol.Storage.AttributionReportingSourceRegisteredEvent) => void): void;
+
+        on(event: 'attributionReportingTriggerRegistered', listener: (params: Protocol.Storage.AttributionReportingTriggerRegisteredEvent) => void): void;
+
     }
 
     export interface SystemInfoApi {
@@ -3233,6 +3683,11 @@ export namespace ProtocolProxyApi {
          */
         getInfo(): Promise<Protocol.SystemInfo.GetInfoResponse>;
 
+        /**
+         * Returns information about the feature state.
+         */
+        getFeatureState(params: Protocol.SystemInfo.GetFeatureStateRequest): Promise<Protocol.SystemInfo.GetFeatureStateResponse>;
+
         /**
          * Returns information about all running processes.
          */
@@ -3267,7 +3722,7 @@ export namespace ProtocolProxyApi {
          * 
          * Injected object will be available as `window[bindingName]`.
          * 
-         * The object has the follwing API:
+         * The object has the following API:
          * - `binding.send(json)` - a method to send messages over the remote debugging protocol
          * - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
          */
@@ -3308,7 +3763,7 @@ export namespace ProtocolProxyApi {
         /**
          * Retrieves a list of available targets.
          */
-        getTargets(): Promise<Protocol.Target.GetTargetsResponse>;
+        getTargets(params: Protocol.Target.GetTargetsRequest): Promise<Protocol.Target.GetTargetsResponse>;
 
         /**
          * Sends protocol message over session with given id.
@@ -3434,8 +3889,8 @@ export namespace ProtocolProxyApi {
         on(event: 'bufferUsage', listener: (params: Protocol.Tracing.BufferUsageEvent) => void): void;
 
         /**
-         * Contains an bucket of collected trace events. When tracing is stopped collected events will be
-         * send as a sequence of dataCollected events followed by tracingComplete event.
+         * Contains a bucket of collected trace events. When tracing is stopped collected events will be
+         * sent as a sequence of dataCollected events followed by tracingComplete event.
          */
         on(event: 'dataCollected', listener: (params: Protocol.Tracing.DataCollectedEvent) => void): void;
 
@@ -3493,6 +3948,10 @@ export namespace ProtocolProxyApi {
          * takeResponseBodyForInterceptionAsStream. Calling other methods that
          * affect the request or disabling fetch domain before body is received
          * results in an undefined behavior.
+         * Note that the response body is not available for redirects. Requests
+         * paused in the _redirect received_ state may be differentiated by
+         * `responseCode` and presence of `location` response header, see
+         * comments to `requestPaused` for details.
          */
         getResponseBody(params: Protocol.Fetch.GetResponseBodyRequest): Promise<Protocol.Fetch.GetResponseBodyResponse>;
 
@@ -3517,6 +3976,11 @@ export namespace ProtocolProxyApi {
          * The stage of the request can be determined by presence of responseErrorReason
          * and responseStatusCode -- the request is at the response stage if either
          * of these fields is present and in the request stage otherwise.
+         * Redirect responses and subsequent requests are reported similarly to regular
+         * responses and requests. Redirect responses may be distinguished by the value
+         * of `responseStatusCode` (which is one of 301, 302, 303, 307, 308) along with
+         * presence of the `location` header. Requests resulting from a redirect will
+         * have `redirectedRequestId` field set.
          */
         on(event: 'requestPaused', listener: (params: Protocol.Fetch.RequestPausedEvent) => void): void;
 
@@ -3616,7 +4080,7 @@ export namespace ProtocolProxyApi {
          * Enable the WebAuthn domain and start intercepting credential storage and
          * retrieval with a virtual authenticator.
          */
-        enable(): Promise<void>;
+        enable(params: Protocol.WebAuthn.EnableRequest): Promise<void>;
 
         /**
          * Disable the WebAuthn domain.
@@ -3628,6 +4092,11 @@ export namespace ProtocolProxyApi {
          */
         addVirtualAuthenticator(params: Protocol.WebAuthn.AddVirtualAuthenticatorRequest): Promise<Protocol.WebAuthn.AddVirtualAuthenticatorResponse>;
 
+        /**
+         * Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present.
+         */
+        setResponseOverrideBits(params: Protocol.WebAuthn.SetResponseOverrideBitsRequest): Promise<void>;
+
         /**
          * Removes the given authenticator.
          */
@@ -3671,6 +4140,22 @@ export namespace ProtocolProxyApi {
          */
         setAutomaticPresenceSimulation(params: Protocol.WebAuthn.SetAutomaticPresenceSimulationRequest): Promise<void>;
 
+        /**
+         * Allows setting credential properties.
+         * https://w3c.github.io/webauthn/#sctn-automation-set-credential-properties
+         */
+        setCredentialProperties(params: Protocol.WebAuthn.SetCredentialPropertiesRequest): Promise<void>;
+
+        /**
+         * Triggered when a credential is added to an authenticator.
+         */
+        on(event: 'credentialAdded', listener: (params: Protocol.WebAuthn.CredentialAddedEvent) => void): void;
+
+        /**
+         * Triggered when a credential is used in a webauthn assertion.
+         */
+        on(event: 'credentialAsserted', listener: (params: Protocol.WebAuthn.CredentialAssertedEvent) => void): void;
+
     }
 
     export interface MediaApi {
@@ -3714,6 +4199,194 @@ export namespace ProtocolProxyApi {
         on(event: 'playersCreated', listener: (params: Protocol.Media.PlayersCreatedEvent) => void): void;
 
     }
+
+    export interface DeviceAccessApi {
+        /**
+         * Enable events in this domain.
+         */
+        enable(): Promise<void>;
+
+        /**
+         * Disable events in this domain.
+         */
+        disable(): Promise<void>;
+
+        /**
+         * Select a device in response to a DeviceAccess.deviceRequestPrompted event.
+         */
+        selectPrompt(params: Protocol.DeviceAccess.SelectPromptRequest): Promise<void>;
+
+        /**
+         * Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event.
+         */
+        cancelPrompt(params: Protocol.DeviceAccess.CancelPromptRequest): Promise<void>;
+
+        /**
+         * A device request opened a user prompt to select a device. Respond with the
+         * selectPrompt or cancelPrompt command.
+         */
+        on(event: 'deviceRequestPrompted', listener: (params: Protocol.DeviceAccess.DeviceRequestPromptedEvent) => void): void;
+
+    }
+
+    export interface PreloadApi {
+        enable(): Promise<void>;
+
+        disable(): Promise<void>;
+
+        /**
+         * Upsert. Currently, it is only emitted when a rule set added.
+         */
+        on(event: 'ruleSetUpdated', listener: (params: Protocol.Preload.RuleSetUpdatedEvent) => void): void;
+
+        on(event: 'ruleSetRemoved', listener: (params: Protocol.Preload.RuleSetRemovedEvent) => void): void;
+
+        /**
+         * Fired when a preload enabled state is updated.
+         */
+        on(event: 'preloadEnabledStateUpdated', listener: (params: Protocol.Preload.PreloadEnabledStateUpdatedEvent) => void): void;
+
+        /**
+         * Fired when a prefetch attempt is updated.
+         */
+        on(event: 'prefetchStatusUpdated', listener: (params: Protocol.Preload.PrefetchStatusUpdatedEvent) => void): void;
+
+        /**
+         * Fired when a prerender attempt is updated.
+         */
+        on(event: 'prerenderStatusUpdated', listener: (params: Protocol.Preload.PrerenderStatusUpdatedEvent) => void): void;
+
+        /**
+         * Send a list of sources for all preloading attempts in a document.
+         */
+        on(event: 'preloadingAttemptSourcesUpdated', listener: (params: Protocol.Preload.PreloadingAttemptSourcesUpdatedEvent) => void): void;
+
+    }
+
+    export interface FedCmApi {
+        enable(params: Protocol.FedCm.EnableRequest): Promise<void>;
+
+        disable(): Promise<void>;
+
+        selectAccount(params: Protocol.FedCm.SelectAccountRequest): Promise<void>;
+
+        clickDialogButton(params: Protocol.FedCm.ClickDialogButtonRequest): Promise<void>;
+
+        openUrl(params: Protocol.FedCm.OpenUrlRequest): Promise<void>;
+
+        dismissDialog(params: Protocol.FedCm.DismissDialogRequest): Promise<void>;
+
+        /**
+         * Resets the cooldown time, if any, to allow the next FedCM call to show
+         * a dialog even if one was recently dismissed by the user.
+         */
+        resetCooldown(): Promise<void>;
+
+        on(event: 'dialogShown', listener: (params: Protocol.FedCm.DialogShownEvent) => void): void;
+
+        /**
+         * Triggered when a dialog is closed, either by user action, JS abort,
+         * or a command below.
+         */
+        on(event: 'dialogClosed', listener: (params: Protocol.FedCm.DialogClosedEvent) => void): void;
+
+    }
+
+    export interface PWAApi {
+        /**
+         * Returns the following OS state for the given manifest id.
+         */
+        getOsAppState(params: Protocol.PWA.GetOsAppStateRequest): Promise<Protocol.PWA.GetOsAppStateResponse>;
+
+        /**
+         * Installs the given manifest identity, optionally using the given install_url
+         * or IWA bundle location.
+         * 
+         * TODO(crbug.com/337872319) Support IWA to meet the following specific
+         * requirement.
+         * IWA-specific install description: If the manifest_id is isolated-app://,
+         * install_url_or_bundle_url is required, and can be either an http(s) URL or
+         * file:// URL pointing to a signed web bundle (.swbn). The .swbn file's
+         * signing key must correspond to manifest_id. If Chrome is not in IWA dev
+         * mode, the installation will fail, regardless of the state of the allowlist.
+         */
+        install(params: Protocol.PWA.InstallRequest): Promise<void>;
+
+        /**
+         * Uninstalls the given manifest_id and closes any opened app windows.
+         */
+        uninstall(params: Protocol.PWA.UninstallRequest): Promise<void>;
+
+        /**
+         * Launches the installed web app, or an url in the same web app instead of the
+         * default start url if it is provided. Returns a page Target.TargetID which
+         * can be used to attach to via Target.attachToTarget or similar APIs.
+         */
+        launch(params: Protocol.PWA.LaunchRequest): Promise<Protocol.PWA.LaunchResponse>;
+
+        /**
+         * Opens one or more local files from an installed web app identified by its
+         * manifestId. The web app needs to have file handlers registered to process
+         * the files. The API returns one or more page Target.TargetIDs which can be
+         * used to attach to via Target.attachToTarget or similar APIs.
+         * If some files in the parameters cannot be handled by the web app, they will
+         * be ignored. If none of the files can be handled, this API returns an error.
+         * If no files are provided as the parameter, this API also returns an error.
+         * 
+         * According to the definition of the file handlers in the manifest file, one
+         * Target.TargetID may represent a page handling one or more files. The order
+         * of the returned Target.TargetIDs is not guaranteed.
+         * 
+         * TODO(crbug.com/339454034): Check the existences of the input files.
+         */
+        launchFilesInApp(params: Protocol.PWA.LaunchFilesInAppRequest): Promise<Protocol.PWA.LaunchFilesInAppResponse>;
+
+        /**
+         * Opens the current page in its web app identified by the manifest id, needs
+         * to be called on a page target. This function returns immediately without
+         * waiting for the app to finish loading.
+         */
+        openCurrentPageInApp(params: Protocol.PWA.OpenCurrentPageInAppRequest): Promise<void>;
+
+        /**
+         * Changes user settings of the web app identified by its manifestId. If the
+         * app was not installed, this command returns an error. Unset parameters will
+         * be ignored; unrecognized values will cause an error.
+         * 
+         * Unlike the ones defined in the manifest files of the web apps, these
+         * settings are provided by the browser and controlled by the users, they
+         * impact the way the browser handling the web apps.
+         * 
+         * See the comment of each parameter.
+         */
+        changeAppUserSettings(params: Protocol.PWA.ChangeAppUserSettingsRequest): Promise<void>;
+
+    }
+
+    export interface BluetoothEmulationApi {
+        /**
+         * Enable the BluetoothEmulation domain.
+         */
+        enable(params: Protocol.BluetoothEmulation.EnableRequest): Promise<void>;
+
+        /**
+         * Disable the BluetoothEmulation domain.
+         */
+        disable(): Promise<void>;
+
+        /**
+         * Simulates a peripheral with |address|, |name| and |knownServiceUuids|
+         * that has already been connected to the system.
+         */
+        simulatePreconnectedPeripheral(params: Protocol.BluetoothEmulation.SimulatePreconnectedPeripheralRequest): Promise<void>;
+
+        /**
+         * Simulates an advertisement packet described in |entry| being received by
+         * the central.
+         */
+        simulateAdvertisement(params: Protocol.BluetoothEmulation.SimulateAdvertisementRequest): Promise<void>;
+
+    }
 }
 
 export default ProtocolProxyApi;
diff --git a/node_modules/devtools-protocol/types/protocol-tests-proxy-api.d.ts b/node_modules/devtools-protocol/types/protocol-tests-proxy-api.d.ts
new file mode 100644
index 0000000..dedec6d
--- /dev/null
+++ b/node_modules/devtools-protocol/types/protocol-tests-proxy-api.d.ts
@@ -0,0 +1,4778 @@
+/**********************************************************************
+ * Auto-generated by protocol-dts-generator.ts, do not edit manually. *
+ **********************************************************************/
+
+import Protocol from './protocol'
+
+/**
+ * API generated from Protocol commands and events.
+ */
+export namespace ProtocolTestsProxyApi {
+
+    export interface ProtocolApi {
+        Console: ConsoleApi;
+
+        Debugger: DebuggerApi;
+
+        HeapProfiler: HeapProfilerApi;
+
+        Profiler: ProfilerApi;
+
+        Runtime: RuntimeApi;
+
+        Schema: SchemaApi;
+
+        Accessibility: AccessibilityApi;
+
+        Animation: AnimationApi;
+
+        Audits: AuditsApi;
+
+        Extensions: ExtensionsApi;
+
+        Autofill: AutofillApi;
+
+        BackgroundService: BackgroundServiceApi;
+
+        Browser: BrowserApi;
+
+        CSS: CSSApi;
+
+        CacheStorage: CacheStorageApi;
+
+        Cast: CastApi;
+
+        DOM: DOMApi;
+
+        DOMDebugger: DOMDebuggerApi;
+
+        EventBreakpoints: EventBreakpointsApi;
+
+        DOMSnapshot: DOMSnapshotApi;
+
+        DOMStorage: DOMStorageApi;
+
+        Database: DatabaseApi;
+
+        DeviceOrientation: DeviceOrientationApi;
+
+        Emulation: EmulationApi;
+
+        HeadlessExperimental: HeadlessExperimentalApi;
+
+        IO: IOApi;
+
+        FileSystem: FileSystemApi;
+
+        IndexedDB: IndexedDBApi;
+
+        Input: InputApi;
+
+        Inspector: InspectorApi;
+
+        LayerTree: LayerTreeApi;
+
+        Log: LogApi;
+
+        Memory: MemoryApi;
+
+        Network: NetworkApi;
+
+        Overlay: OverlayApi;
+
+        Page: PageApi;
+
+        Performance: PerformanceApi;
+
+        PerformanceTimeline: PerformanceTimelineApi;
+
+        Security: SecurityApi;
+
+        ServiceWorker: ServiceWorkerApi;
+
+        Storage: StorageApi;
+
+        SystemInfo: SystemInfoApi;
+
+        Target: TargetApi;
+
+        Tethering: TetheringApi;
+
+        Tracing: TracingApi;
+
+        Fetch: FetchApi;
+
+        WebAudio: WebAudioApi;
+
+        WebAuthn: WebAuthnApi;
+
+        Media: MediaApi;
+
+        DeviceAccess: DeviceAccessApi;
+
+        Preload: PreloadApi;
+
+        FedCm: FedCmApi;
+
+        PWA: PWAApi;
+
+        BluetoothEmulation: BluetoothEmulationApi;
+
+    }
+
+
+    export interface ConsoleApi {
+        /**
+         * Does nothing.
+         */
+        clearMessages(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables console domain, prevents further console messages from being reported to the client.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables console domain, sends the messages collected so far to the client by means of the
+         * `messageAdded` notification.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Issued when new console message is added.
+         */
+        onMessageAdded(listener: (event: { params: Protocol.Console.MessageAddedEvent }) => void): void;
+        offMessageAdded(listener: (event: { params: Protocol.Console.MessageAddedEvent }) => void): void;
+        onceMessageAdded(eventMatcher?: (event: { params: Protocol.Console.MessageAddedEvent }) => boolean): Promise<{ params: Protocol.Console.MessageAddedEvent }>;
+
+    }
+
+    export interface DebuggerApi {
+        /**
+         * Continues execution until specific location is reached.
+         */
+        continueToLocation(params: Protocol.Debugger.ContinueToLocationRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables debugger for given page.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables debugger for the given page. Clients should not assume that the debugging has been
+         * enabled until the result for this command is received.
+         */
+        enable(params: Protocol.Debugger.EnableRequest): Promise<{id: number, result: Protocol.Debugger.EnableResponse, sessionId: string}>;
+
+        /**
+         * Evaluates expression on a given call frame.
+         */
+        evaluateOnCallFrame(params: Protocol.Debugger.EvaluateOnCallFrameRequest): Promise<{id: number, result: Protocol.Debugger.EvaluateOnCallFrameResponse, sessionId: string}>;
+
+        /**
+         * Returns possible locations for breakpoint. scriptId in start and end range locations should be
+         * the same.
+         */
+        getPossibleBreakpoints(params: Protocol.Debugger.GetPossibleBreakpointsRequest): Promise<{id: number, result: Protocol.Debugger.GetPossibleBreakpointsResponse, sessionId: string}>;
+
+        /**
+         * Returns source for the script with given id.
+         */
+        getScriptSource(params: Protocol.Debugger.GetScriptSourceRequest): Promise<{id: number, result: Protocol.Debugger.GetScriptSourceResponse, sessionId: string}>;
+
+        disassembleWasmModule(params: Protocol.Debugger.DisassembleWasmModuleRequest): Promise<{id: number, result: Protocol.Debugger.DisassembleWasmModuleResponse, sessionId: string}>;
+
+        /**
+         * Disassemble the next chunk of lines for the module corresponding to the
+         * stream. If disassembly is complete, this API will invalidate the streamId
+         * and return an empty chunk. Any subsequent calls for the now invalid stream
+         * will return errors.
+         */
+        nextWasmDisassemblyChunk(params: Protocol.Debugger.NextWasmDisassemblyChunkRequest): Promise<{id: number, result: Protocol.Debugger.NextWasmDisassemblyChunkResponse, sessionId: string}>;
+
+        /**
+         * This command is deprecated. Use getScriptSource instead.
+         */
+        getWasmBytecode(params: Protocol.Debugger.GetWasmBytecodeRequest): Promise<{id: number, result: Protocol.Debugger.GetWasmBytecodeResponse, sessionId: string}>;
+
+        /**
+         * Returns stack trace with given `stackTraceId`.
+         */
+        getStackTrace(params: Protocol.Debugger.GetStackTraceRequest): Promise<{id: number, result: Protocol.Debugger.GetStackTraceResponse, sessionId: string}>;
+
+        /**
+         * Stops on the next JavaScript statement.
+         */
+        pause(): Promise<{id: number, result: void, sessionId: string}>;
+
+        pauseOnAsyncCall(params: Protocol.Debugger.PauseOnAsyncCallRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Removes JavaScript breakpoint.
+         */
+        removeBreakpoint(params: Protocol.Debugger.RemoveBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Restarts particular call frame from the beginning. The old, deprecated
+         * behavior of `restartFrame` is to stay paused and allow further CDP commands
+         * after a restart was scheduled. This can cause problems with restarting, so
+         * we now continue execution immediatly after it has been scheduled until we
+         * reach the beginning of the restarted frame.
+         * 
+         * To stay back-wards compatible, `restartFrame` now expects a `mode`
+         * parameter to be present. If the `mode` parameter is missing, `restartFrame`
+         * errors out.
+         * 
+         * The various return values are deprecated and `callFrames` is always empty.
+         * Use the call frames from the `Debugger#paused` events instead, that fires
+         * once V8 pauses at the beginning of the restarted function.
+         */
+        restartFrame(params: Protocol.Debugger.RestartFrameRequest): Promise<{id: number, result: Protocol.Debugger.RestartFrameResponse, sessionId: string}>;
+
+        /**
+         * Resumes JavaScript execution.
+         */
+        resume(params: Protocol.Debugger.ResumeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Searches for given string in script content.
+         */
+        searchInContent(params: Protocol.Debugger.SearchInContentRequest): Promise<{id: number, result: Protocol.Debugger.SearchInContentResponse, sessionId: string}>;
+
+        /**
+         * Enables or disables async call stacks tracking.
+         */
+        setAsyncCallStackDepth(params: Protocol.Debugger.SetAsyncCallStackDepthRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
+         * scripts with url matching one of the patterns. VM will try to leave blackboxed script by
+         * performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
+         */
+        setBlackboxPatterns(params: Protocol.Debugger.SetBlackboxPatternsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
+         * scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
+         * Positions array contains positions where blackbox state is changed. First interval isn't
+         * blackboxed. Array should be sorted.
+         */
+        setBlackboxedRanges(params: Protocol.Debugger.SetBlackboxedRangesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets JavaScript breakpoint at a given location.
+         */
+        setBreakpoint(params: Protocol.Debugger.SetBreakpointRequest): Promise<{id: number, result: Protocol.Debugger.SetBreakpointResponse, sessionId: string}>;
+
+        /**
+         * Sets instrumentation breakpoint.
+         */
+        setInstrumentationBreakpoint(params: Protocol.Debugger.SetInstrumentationBreakpointRequest): Promise<{id: number, result: Protocol.Debugger.SetInstrumentationBreakpointResponse, sessionId: string}>;
+
+        /**
+         * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
+         * command is issued, all existing parsed scripts will have breakpoints resolved and returned in
+         * `locations` property. Further matching script parsing will result in subsequent
+         * `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
+         */
+        setBreakpointByUrl(params: Protocol.Debugger.SetBreakpointByUrlRequest): Promise<{id: number, result: Protocol.Debugger.SetBreakpointByUrlResponse, sessionId: string}>;
+
+        /**
+         * Sets JavaScript breakpoint before each call to the given function.
+         * If another function was created from the same source as a given one,
+         * calling it will also trigger the breakpoint.
+         */
+        setBreakpointOnFunctionCall(params: Protocol.Debugger.SetBreakpointOnFunctionCallRequest): Promise<{id: number, result: Protocol.Debugger.SetBreakpointOnFunctionCallResponse, sessionId: string}>;
+
+        /**
+         * Activates / deactivates all breakpoints on the page.
+         */
+        setBreakpointsActive(params: Protocol.Debugger.SetBreakpointsActiveRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
+         * or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
+         */
+        setPauseOnExceptions(params: Protocol.Debugger.SetPauseOnExceptionsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Changes return value in top frame. Available only at return break position.
+         */
+        setReturnValue(params: Protocol.Debugger.SetReturnValueRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Edits JavaScript source live.
+         * 
+         * In general, functions that are currently on the stack can not be edited with
+         * a single exception: If the edited function is the top-most stack frame and
+         * that is the only activation of that function on the stack. In this case
+         * the live edit will be successful and a `Debugger.restartFrame` for the
+         * top-most function is automatically triggered.
+         */
+        setScriptSource(params: Protocol.Debugger.SetScriptSourceRequest): Promise<{id: number, result: Protocol.Debugger.SetScriptSourceResponse, sessionId: string}>;
+
+        /**
+         * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
+         */
+        setSkipAllPauses(params: Protocol.Debugger.SetSkipAllPausesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Changes value of variable in a callframe. Object-based scopes are not supported and must be
+         * mutated manually.
+         */
+        setVariableValue(params: Protocol.Debugger.SetVariableValueRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Steps into the function call.
+         */
+        stepInto(params: Protocol.Debugger.StepIntoRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Steps out of the function call.
+         */
+        stepOut(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Steps over the statement.
+         */
+        stepOver(params: Protocol.Debugger.StepOverRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Fired when breakpoint is resolved to an actual script and location.
+         */
+        onBreakpointResolved(listener: (event: { params: Protocol.Debugger.BreakpointResolvedEvent }) => void): void;
+        offBreakpointResolved(listener: (event: { params: Protocol.Debugger.BreakpointResolvedEvent }) => void): void;
+        onceBreakpointResolved(eventMatcher?: (event: { params: Protocol.Debugger.BreakpointResolvedEvent }) => boolean): Promise<{ params: Protocol.Debugger.BreakpointResolvedEvent }>;
+
+        /**
+         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
+         */
+        onPaused(listener: (event: { params: Protocol.Debugger.PausedEvent }) => void): void;
+        offPaused(listener: (event: { params: Protocol.Debugger.PausedEvent }) => void): void;
+        oncePaused(eventMatcher?: (event: { params: Protocol.Debugger.PausedEvent }) => boolean): Promise<{ params: Protocol.Debugger.PausedEvent }>;
+
+        /**
+         * Fired when the virtual machine resumed execution.
+         */
+        onResumed(listener: (event: ) => void): void;
+        offResumed(listener: (event: ) => void): void;
+        onceResumed(eventMatcher?: (event: ) => boolean): Promise<>;
+
+        /**
+         * Fired when virtual machine fails to parse the script.
+         */
+        onScriptFailedToParse(listener: (event: { params: Protocol.Debugger.ScriptFailedToParseEvent }) => void): void;
+        offScriptFailedToParse(listener: (event: { params: Protocol.Debugger.ScriptFailedToParseEvent }) => void): void;
+        onceScriptFailedToParse(eventMatcher?: (event: { params: Protocol.Debugger.ScriptFailedToParseEvent }) => boolean): Promise<{ params: Protocol.Debugger.ScriptFailedToParseEvent }>;
+
+        /**
+         * Fired when virtual machine parses script. This event is also fired for all known and uncollected
+         * scripts upon enabling debugger.
+         */
+        onScriptParsed(listener: (event: { params: Protocol.Debugger.ScriptParsedEvent }) => void): void;
+        offScriptParsed(listener: (event: { params: Protocol.Debugger.ScriptParsedEvent }) => void): void;
+        onceScriptParsed(eventMatcher?: (event: { params: Protocol.Debugger.ScriptParsedEvent }) => boolean): Promise<{ params: Protocol.Debugger.ScriptParsedEvent }>;
+
+    }
+
+    export interface HeapProfilerApi {
+        /**
+         * Enables console to refer to the node with given id via $x (see Command Line API for more details
+         * $x functions).
+         */
+        addInspectedHeapObject(params: Protocol.HeapProfiler.AddInspectedHeapObjectRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        collectGarbage(): Promise<{id: number, result: void, sessionId: string}>;
+
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        getHeapObjectId(params: Protocol.HeapProfiler.GetHeapObjectIdRequest): Promise<{id: number, result: Protocol.HeapProfiler.GetHeapObjectIdResponse, sessionId: string}>;
+
+        getObjectByHeapObjectId(params: Protocol.HeapProfiler.GetObjectByHeapObjectIdRequest): Promise<{id: number, result: Protocol.HeapProfiler.GetObjectByHeapObjectIdResponse, sessionId: string}>;
+
+        getSamplingProfile(): Promise<{id: number, result: Protocol.HeapProfiler.GetSamplingProfileResponse, sessionId: string}>;
+
+        startSampling(params: Protocol.HeapProfiler.StartSamplingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        startTrackingHeapObjects(params: Protocol.HeapProfiler.StartTrackingHeapObjectsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        stopSampling(): Promise<{id: number, result: Protocol.HeapProfiler.StopSamplingResponse, sessionId: string}>;
+
+        stopTrackingHeapObjects(params: Protocol.HeapProfiler.StopTrackingHeapObjectsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        takeHeapSnapshot(params: Protocol.HeapProfiler.TakeHeapSnapshotRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        onAddHeapSnapshotChunk(listener: (event: { params: Protocol.HeapProfiler.AddHeapSnapshotChunkEvent }) => void): void;
+        offAddHeapSnapshotChunk(listener: (event: { params: Protocol.HeapProfiler.AddHeapSnapshotChunkEvent }) => void): void;
+        onceAddHeapSnapshotChunk(eventMatcher?: (event: { params: Protocol.HeapProfiler.AddHeapSnapshotChunkEvent }) => boolean): Promise<{ params: Protocol.HeapProfiler.AddHeapSnapshotChunkEvent }>;
+
+        /**
+         * If heap objects tracking has been started then backend may send update for one or more fragments
+         */
+        onHeapStatsUpdate(listener: (event: { params: Protocol.HeapProfiler.HeapStatsUpdateEvent }) => void): void;
+        offHeapStatsUpdate(listener: (event: { params: Protocol.HeapProfiler.HeapStatsUpdateEvent }) => void): void;
+        onceHeapStatsUpdate(eventMatcher?: (event: { params: Protocol.HeapProfiler.HeapStatsUpdateEvent }) => boolean): Promise<{ params: Protocol.HeapProfiler.HeapStatsUpdateEvent }>;
+
+        /**
+         * If heap objects tracking has been started then backend regularly sends a current value for last
+         * seen object id and corresponding timestamp. If the were changes in the heap since last event
+         * then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
+         */
+        onLastSeenObjectId(listener: (event: { params: Protocol.HeapProfiler.LastSeenObjectIdEvent }) => void): void;
+        offLastSeenObjectId(listener: (event: { params: Protocol.HeapProfiler.LastSeenObjectIdEvent }) => void): void;
+        onceLastSeenObjectId(eventMatcher?: (event: { params: Protocol.HeapProfiler.LastSeenObjectIdEvent }) => boolean): Promise<{ params: Protocol.HeapProfiler.LastSeenObjectIdEvent }>;
+
+        onReportHeapSnapshotProgress(listener: (event: { params: Protocol.HeapProfiler.ReportHeapSnapshotProgressEvent }) => void): void;
+        offReportHeapSnapshotProgress(listener: (event: { params: Protocol.HeapProfiler.ReportHeapSnapshotProgressEvent }) => void): void;
+        onceReportHeapSnapshotProgress(eventMatcher?: (event: { params: Protocol.HeapProfiler.ReportHeapSnapshotProgressEvent }) => boolean): Promise<{ params: Protocol.HeapProfiler.ReportHeapSnapshotProgressEvent }>;
+
+        onResetProfiles(listener: (event: ) => void): void;
+        offResetProfiles(listener: (event: ) => void): void;
+        onceResetProfiles(eventMatcher?: (event: ) => boolean): Promise<>;
+
+    }
+
+    export interface ProfilerApi {
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Collect coverage data for the current isolate. The coverage data may be incomplete due to
+         * garbage collection.
+         */
+        getBestEffortCoverage(): Promise<{id: number, result: Protocol.Profiler.GetBestEffortCoverageResponse, sessionId: string}>;
+
+        /**
+         * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
+         */
+        setSamplingInterval(params: Protocol.Profiler.SetSamplingIntervalRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        start(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
+         * coverage may be incomplete. Enabling prevents running optimized code and resets execution
+         * counters.
+         */
+        startPreciseCoverage(params: Protocol.Profiler.StartPreciseCoverageRequest): Promise<{id: number, result: Protocol.Profiler.StartPreciseCoverageResponse, sessionId: string}>;
+
+        stop(): Promise<{id: number, result: Protocol.Profiler.StopResponse, sessionId: string}>;
+
+        /**
+         * Disable precise code coverage. Disabling releases unnecessary execution count records and allows
+         * executing optimized code.
+         */
+        stopPreciseCoverage(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Collect coverage data for the current isolate, and resets execution counters. Precise code
+         * coverage needs to have started.
+         */
+        takePreciseCoverage(): Promise<{id: number, result: Protocol.Profiler.TakePreciseCoverageResponse, sessionId: string}>;
+
+        onConsoleProfileFinished(listener: (event: { params: Protocol.Profiler.ConsoleProfileFinishedEvent }) => void): void;
+        offConsoleProfileFinished(listener: (event: { params: Protocol.Profiler.ConsoleProfileFinishedEvent }) => void): void;
+        onceConsoleProfileFinished(eventMatcher?: (event: { params: Protocol.Profiler.ConsoleProfileFinishedEvent }) => boolean): Promise<{ params: Protocol.Profiler.ConsoleProfileFinishedEvent }>;
+
+        /**
+         * Sent when new profile recording is started using console.profile() call.
+         */
+        onConsoleProfileStarted(listener: (event: { params: Protocol.Profiler.ConsoleProfileStartedEvent }) => void): void;
+        offConsoleProfileStarted(listener: (event: { params: Protocol.Profiler.ConsoleProfileStartedEvent }) => void): void;
+        onceConsoleProfileStarted(eventMatcher?: (event: { params: Protocol.Profiler.ConsoleProfileStartedEvent }) => boolean): Promise<{ params: Protocol.Profiler.ConsoleProfileStartedEvent }>;
+
+        /**
+         * Reports coverage delta since the last poll (either from an event like this, or from
+         * `takePreciseCoverage` for the current isolate. May only be sent if precise code
+         * coverage has been started. This event can be trigged by the embedder to, for example,
+         * trigger collection of coverage data immediately at a certain point in time.
+         */
+        onPreciseCoverageDeltaUpdate(listener: (event: { params: Protocol.Profiler.PreciseCoverageDeltaUpdateEvent }) => void): void;
+        offPreciseCoverageDeltaUpdate(listener: (event: { params: Protocol.Profiler.PreciseCoverageDeltaUpdateEvent }) => void): void;
+        oncePreciseCoverageDeltaUpdate(eventMatcher?: (event: { params: Protocol.Profiler.PreciseCoverageDeltaUpdateEvent }) => boolean): Promise<{ params: Protocol.Profiler.PreciseCoverageDeltaUpdateEvent }>;
+
+    }
+
+    export interface RuntimeApi {
+        /**
+         * Add handler to promise with given promise object id.
+         */
+        awaitPromise(params: Protocol.Runtime.AwaitPromiseRequest): Promise<{id: number, result: Protocol.Runtime.AwaitPromiseResponse, sessionId: string}>;
+
+        /**
+         * Calls function with given declaration on the given object. Object group of the result is
+         * inherited from the target object.
+         */
+        callFunctionOn(params: Protocol.Runtime.CallFunctionOnRequest): Promise<{id: number, result: Protocol.Runtime.CallFunctionOnResponse, sessionId: string}>;
+
+        /**
+         * Compiles expression.
+         */
+        compileScript(params: Protocol.Runtime.CompileScriptRequest): Promise<{id: number, result: Protocol.Runtime.CompileScriptResponse, sessionId: string}>;
+
+        /**
+         * Disables reporting of execution contexts creation.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Discards collected exceptions and console API calls.
+         */
+        discardConsoleEntries(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables reporting of execution contexts creation by means of `executionContextCreated` event.
+         * When the reporting gets enabled the event will be sent immediately for each existing execution
+         * context.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Evaluates expression on global object.
+         */
+        evaluate(params: Protocol.Runtime.EvaluateRequest): Promise<{id: number, result: Protocol.Runtime.EvaluateResponse, sessionId: string}>;
+
+        /**
+         * Returns the isolate id.
+         */
+        getIsolateId(): Promise<{id: number, result: Protocol.Runtime.GetIsolateIdResponse, sessionId: string}>;
+
+        /**
+         * Returns the JavaScript heap usage.
+         * It is the total usage of the corresponding isolate not scoped to a particular Runtime.
+         */
+        getHeapUsage(): Promise<{id: number, result: Protocol.Runtime.GetHeapUsageResponse, sessionId: string}>;
+
+        /**
+         * Returns properties of a given object. Object group of the result is inherited from the target
+         * object.
+         */
+        getProperties(params: Protocol.Runtime.GetPropertiesRequest): Promise<{id: number, result: Protocol.Runtime.GetPropertiesResponse, sessionId: string}>;
+
+        /**
+         * Returns all let, const and class variables from global scope.
+         */
+        globalLexicalScopeNames(params: Protocol.Runtime.GlobalLexicalScopeNamesRequest): Promise<{id: number, result: Protocol.Runtime.GlobalLexicalScopeNamesResponse, sessionId: string}>;
+
+        queryObjects(params: Protocol.Runtime.QueryObjectsRequest): Promise<{id: number, result: Protocol.Runtime.QueryObjectsResponse, sessionId: string}>;
+
+        /**
+         * Releases remote object with given id.
+         */
+        releaseObject(params: Protocol.Runtime.ReleaseObjectRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Releases all remote objects that belong to a given group.
+         */
+        releaseObjectGroup(params: Protocol.Runtime.ReleaseObjectGroupRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Tells inspected instance to run if it was waiting for debugger to attach.
+         */
+        runIfWaitingForDebugger(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Runs script with given id in a given context.
+         */
+        runScript(params: Protocol.Runtime.RunScriptRequest): Promise<{id: number, result: Protocol.Runtime.RunScriptResponse, sessionId: string}>;
+
+        /**
+         * Enables or disables async call stacks tracking.
+         */
+        setAsyncCallStackDepth(params: Protocol.Runtime.SetAsyncCallStackDepthRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setCustomObjectFormatterEnabled(params: Protocol.Runtime.SetCustomObjectFormatterEnabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setMaxCallStackSizeToCapture(params: Protocol.Runtime.SetMaxCallStackSizeToCaptureRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Terminate current or next JavaScript execution.
+         * Will cancel the termination when the outer-most script execution ends.
+         */
+        terminateExecution(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * If executionContextId is empty, adds binding with the given name on the
+         * global objects of all inspected contexts, including those created later,
+         * bindings survive reloads.
+         * Binding function takes exactly one argument, this argument should be string,
+         * in case of any other input, function throws an exception.
+         * Each binding function call produces Runtime.bindingCalled notification.
+         */
+        addBinding(params: Protocol.Runtime.AddBindingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * This method does not remove binding function from global object but
+         * unsubscribes current runtime agent from Runtime.bindingCalled notifications.
+         */
+        removeBinding(params: Protocol.Runtime.RemoveBindingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * This method tries to lookup and populate exception details for a
+         * JavaScript Error object.
+         * Note that the stackTrace portion of the resulting exceptionDetails will
+         * only be populated if the Runtime domain was enabled at the time when the
+         * Error was thrown.
+         */
+        getExceptionDetails(params: Protocol.Runtime.GetExceptionDetailsRequest): Promise<{id: number, result: Protocol.Runtime.GetExceptionDetailsResponse, sessionId: string}>;
+
+        /**
+         * Notification is issued every time when binding is called.
+         */
+        onBindingCalled(listener: (event: { params: Protocol.Runtime.BindingCalledEvent }) => void): void;
+        offBindingCalled(listener: (event: { params: Protocol.Runtime.BindingCalledEvent }) => void): void;
+        onceBindingCalled(eventMatcher?: (event: { params: Protocol.Runtime.BindingCalledEvent }) => boolean): Promise<{ params: Protocol.Runtime.BindingCalledEvent }>;
+
+        /**
+         * Issued when console API was called.
+         */
+        onConsoleAPICalled(listener: (event: { params: Protocol.Runtime.ConsoleAPICalledEvent }) => void): void;
+        offConsoleAPICalled(listener: (event: { params: Protocol.Runtime.ConsoleAPICalledEvent }) => void): void;
+        onceConsoleAPICalled(eventMatcher?: (event: { params: Protocol.Runtime.ConsoleAPICalledEvent }) => boolean): Promise<{ params: Protocol.Runtime.ConsoleAPICalledEvent }>;
+
+        /**
+         * Issued when unhandled exception was revoked.
+         */
+        onExceptionRevoked(listener: (event: { params: Protocol.Runtime.ExceptionRevokedEvent }) => void): void;
+        offExceptionRevoked(listener: (event: { params: Protocol.Runtime.ExceptionRevokedEvent }) => void): void;
+        onceExceptionRevoked(eventMatcher?: (event: { params: Protocol.Runtime.ExceptionRevokedEvent }) => boolean): Promise<{ params: Protocol.Runtime.ExceptionRevokedEvent }>;
+
+        /**
+         * Issued when exception was thrown and unhandled.
+         */
+        onExceptionThrown(listener: (event: { params: Protocol.Runtime.ExceptionThrownEvent }) => void): void;
+        offExceptionThrown(listener: (event: { params: Protocol.Runtime.ExceptionThrownEvent }) => void): void;
+        onceExceptionThrown(eventMatcher?: (event: { params: Protocol.Runtime.ExceptionThrownEvent }) => boolean): Promise<{ params: Protocol.Runtime.ExceptionThrownEvent }>;
+
+        /**
+         * Issued when new execution context is created.
+         */
+        onExecutionContextCreated(listener: (event: { params: Protocol.Runtime.ExecutionContextCreatedEvent }) => void): void;
+        offExecutionContextCreated(listener: (event: { params: Protocol.Runtime.ExecutionContextCreatedEvent }) => void): void;
+        onceExecutionContextCreated(eventMatcher?: (event: { params: Protocol.Runtime.ExecutionContextCreatedEvent }) => boolean): Promise<{ params: Protocol.Runtime.ExecutionContextCreatedEvent }>;
+
+        /**
+         * Issued when execution context is destroyed.
+         */
+        onExecutionContextDestroyed(listener: (event: { params: Protocol.Runtime.ExecutionContextDestroyedEvent }) => void): void;
+        offExecutionContextDestroyed(listener: (event: { params: Protocol.Runtime.ExecutionContextDestroyedEvent }) => void): void;
+        onceExecutionContextDestroyed(eventMatcher?: (event: { params: Protocol.Runtime.ExecutionContextDestroyedEvent }) => boolean): Promise<{ params: Protocol.Runtime.ExecutionContextDestroyedEvent }>;
+
+        /**
+         * Issued when all executionContexts were cleared in browser
+         */
+        onExecutionContextsCleared(listener: (event: ) => void): void;
+        offExecutionContextsCleared(listener: (event: ) => void): void;
+        onceExecutionContextsCleared(eventMatcher?: (event: ) => boolean): Promise<>;
+
+        /**
+         * Issued when object should be inspected (for example, as a result of inspect() command line API
+         * call).
+         */
+        onInspectRequested(listener: (event: { params: Protocol.Runtime.InspectRequestedEvent }) => void): void;
+        offInspectRequested(listener: (event: { params: Protocol.Runtime.InspectRequestedEvent }) => void): void;
+        onceInspectRequested(eventMatcher?: (event: { params: Protocol.Runtime.InspectRequestedEvent }) => boolean): Promise<{ params: Protocol.Runtime.InspectRequestedEvent }>;
+
+    }
+
+    export interface SchemaApi {
+        /**
+         * Returns supported domains.
+         */
+        getDomains(): Promise<{id: number, result: Protocol.Schema.GetDomainsResponse, sessionId: string}>;
+
+    }
+
+    export interface AccessibilityApi {
+        /**
+         * Disables the accessibility domain.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
+         * This turns on accessibility for the page, which can impact performance until accessibility is disabled.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
+         */
+        getPartialAXTree(params: Protocol.Accessibility.GetPartialAXTreeRequest): Promise<{id: number, result: Protocol.Accessibility.GetPartialAXTreeResponse, sessionId: string}>;
+
+        /**
+         * Fetches the entire accessibility tree for the root Document
+         */
+        getFullAXTree(params: Protocol.Accessibility.GetFullAXTreeRequest): Promise<{id: number, result: Protocol.Accessibility.GetFullAXTreeResponse, sessionId: string}>;
+
+        /**
+         * Fetches the root node.
+         * Requires `enable()` to have been called previously.
+         */
+        getRootAXNode(params: Protocol.Accessibility.GetRootAXNodeRequest): Promise<{id: number, result: Protocol.Accessibility.GetRootAXNodeResponse, sessionId: string}>;
+
+        /**
+         * Fetches a node and all ancestors up to and including the root.
+         * Requires `enable()` to have been called previously.
+         */
+        getAXNodeAndAncestors(params: Protocol.Accessibility.GetAXNodeAndAncestorsRequest): Promise<{id: number, result: Protocol.Accessibility.GetAXNodeAndAncestorsResponse, sessionId: string}>;
+
+        /**
+         * Fetches a particular accessibility node by AXNodeId.
+         * Requires `enable()` to have been called previously.
+         */
+        getChildAXNodes(params: Protocol.Accessibility.GetChildAXNodesRequest): Promise<{id: number, result: Protocol.Accessibility.GetChildAXNodesResponse, sessionId: string}>;
+
+        /**
+         * Query a DOM node's accessibility subtree for accessible name and role.
+         * This command computes the name and role for all nodes in the subtree, including those that are
+         * ignored for accessibility, and returns those that match the specified name and role. If no DOM
+         * node is specified, or the DOM node does not exist, the command returns an error. If neither
+         * `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
+         */
+        queryAXTree(params: Protocol.Accessibility.QueryAXTreeRequest): Promise<{id: number, result: Protocol.Accessibility.QueryAXTreeResponse, sessionId: string}>;
+
+        /**
+         * The loadComplete event mirrors the load complete event sent by the browser to assistive
+         * technology when the web page has finished loading.
+         */
+        onLoadComplete(listener: (event: { params: Protocol.Accessibility.LoadCompleteEvent }) => void): void;
+        offLoadComplete(listener: (event: { params: Protocol.Accessibility.LoadCompleteEvent }) => void): void;
+        onceLoadComplete(eventMatcher?: (event: { params: Protocol.Accessibility.LoadCompleteEvent }) => boolean): Promise<{ params: Protocol.Accessibility.LoadCompleteEvent }>;
+
+        /**
+         * The nodesUpdated event is sent every time a previously requested node has changed the in tree.
+         */
+        onNodesUpdated(listener: (event: { params: Protocol.Accessibility.NodesUpdatedEvent }) => void): void;
+        offNodesUpdated(listener: (event: { params: Protocol.Accessibility.NodesUpdatedEvent }) => void): void;
+        onceNodesUpdated(eventMatcher?: (event: { params: Protocol.Accessibility.NodesUpdatedEvent }) => boolean): Promise<{ params: Protocol.Accessibility.NodesUpdatedEvent }>;
+
+    }
+
+    export interface AnimationApi {
+        /**
+         * Disables animation domain notifications.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables animation domain notifications.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns the current time of the an animation.
+         */
+        getCurrentTime(params: Protocol.Animation.GetCurrentTimeRequest): Promise<{id: number, result: Protocol.Animation.GetCurrentTimeResponse, sessionId: string}>;
+
+        /**
+         * Gets the playback rate of the document timeline.
+         */
+        getPlaybackRate(): Promise<{id: number, result: Protocol.Animation.GetPlaybackRateResponse, sessionId: string}>;
+
+        /**
+         * Releases a set of animations to no longer be manipulated.
+         */
+        releaseAnimations(params: Protocol.Animation.ReleaseAnimationsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Gets the remote object of the Animation.
+         */
+        resolveAnimation(params: Protocol.Animation.ResolveAnimationRequest): Promise<{id: number, result: Protocol.Animation.ResolveAnimationResponse, sessionId: string}>;
+
+        /**
+         * Seek a set of animations to a particular time within each animation.
+         */
+        seekAnimations(params: Protocol.Animation.SeekAnimationsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets the paused state of a set of animations.
+         */
+        setPaused(params: Protocol.Animation.SetPausedRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets the playback rate of the document timeline.
+         */
+        setPlaybackRate(params: Protocol.Animation.SetPlaybackRateRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets the timing of an animation node.
+         */
+        setTiming(params: Protocol.Animation.SetTimingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Event for when an animation has been cancelled.
+         */
+        onAnimationCanceled(listener: (event: { params: Protocol.Animation.AnimationCanceledEvent }) => void): void;
+        offAnimationCanceled(listener: (event: { params: Protocol.Animation.AnimationCanceledEvent }) => void): void;
+        onceAnimationCanceled(eventMatcher?: (event: { params: Protocol.Animation.AnimationCanceledEvent }) => boolean): Promise<{ params: Protocol.Animation.AnimationCanceledEvent }>;
+
+        /**
+         * Event for each animation that has been created.
+         */
+        onAnimationCreated(listener: (event: { params: Protocol.Animation.AnimationCreatedEvent }) => void): void;
+        offAnimationCreated(listener: (event: { params: Protocol.Animation.AnimationCreatedEvent }) => void): void;
+        onceAnimationCreated(eventMatcher?: (event: { params: Protocol.Animation.AnimationCreatedEvent }) => boolean): Promise<{ params: Protocol.Animation.AnimationCreatedEvent }>;
+
+        /**
+         * Event for animation that has been started.
+         */
+        onAnimationStarted(listener: (event: { params: Protocol.Animation.AnimationStartedEvent }) => void): void;
+        offAnimationStarted(listener: (event: { params: Protocol.Animation.AnimationStartedEvent }) => void): void;
+        onceAnimationStarted(eventMatcher?: (event: { params: Protocol.Animation.AnimationStartedEvent }) => boolean): Promise<{ params: Protocol.Animation.AnimationStartedEvent }>;
+
+        /**
+         * Event for animation that has been updated.
+         */
+        onAnimationUpdated(listener: (event: { params: Protocol.Animation.AnimationUpdatedEvent }) => void): void;
+        offAnimationUpdated(listener: (event: { params: Protocol.Animation.AnimationUpdatedEvent }) => void): void;
+        onceAnimationUpdated(eventMatcher?: (event: { params: Protocol.Animation.AnimationUpdatedEvent }) => boolean): Promise<{ params: Protocol.Animation.AnimationUpdatedEvent }>;
+
+    }
+
+    export interface AuditsApi {
+        /**
+         * Returns the response body and size if it were re-encoded with the specified settings. Only
+         * applies to images.
+         */
+        getEncodedResponse(params: Protocol.Audits.GetEncodedResponseRequest): Promise<{id: number, result: Protocol.Audits.GetEncodedResponseResponse, sessionId: string}>;
+
+        /**
+         * Disables issues domain, prevents further issues from being reported to the client.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables issues domain, sends the issues collected so far to the client by means of the
+         * `issueAdded` event.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Runs the contrast check for the target page. Found issues are reported
+         * using Audits.issueAdded event.
+         */
+        checkContrast(params: Protocol.Audits.CheckContrastRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Runs the form issues check for the target page. Found issues are reported
+         * using Audits.issueAdded event.
+         */
+        checkFormsIssues(): Promise<{id: number, result: Protocol.Audits.CheckFormsIssuesResponse, sessionId: string}>;
+
+        onIssueAdded(listener: (event: { params: Protocol.Audits.IssueAddedEvent }) => void): void;
+        offIssueAdded(listener: (event: { params: Protocol.Audits.IssueAddedEvent }) => void): void;
+        onceIssueAdded(eventMatcher?: (event: { params: Protocol.Audits.IssueAddedEvent }) => boolean): Promise<{ params: Protocol.Audits.IssueAddedEvent }>;
+
+    }
+
+    export interface ExtensionsApi {
+        /**
+         * Installs an unpacked extension from the filesystem similar to
+         * --load-extension CLI flags. Returns extension ID once the extension
+         * has been installed. Available if the client is connected using the
+         * --remote-debugging-pipe flag and the --enable-unsafe-extension-debugging
+         * flag is set.
+         */
+        loadUnpacked(params: Protocol.Extensions.LoadUnpackedRequest): Promise<{id: number, result: Protocol.Extensions.LoadUnpackedResponse, sessionId: string}>;
+
+        /**
+         * Gets data from extension storage in the given `storageArea`. If `keys` is
+         * specified, these are used to filter the result.
+         */
+        getStorageItems(params: Protocol.Extensions.GetStorageItemsRequest): Promise<{id: number, result: Protocol.Extensions.GetStorageItemsResponse, sessionId: string}>;
+
+        /**
+         * Removes `keys` from extension storage in the given `storageArea`.
+         */
+        removeStorageItems(params: Protocol.Extensions.RemoveStorageItemsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears extension storage in the given `storageArea`.
+         */
+        clearStorageItems(params: Protocol.Extensions.ClearStorageItemsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets `values` in extension storage in the given `storageArea`. The provided `values`
+         * will be merged with existing values in the storage area.
+         */
+        setStorageItems(params: Protocol.Extensions.SetStorageItemsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+    }
+
+    export interface AutofillApi {
+        /**
+         * Trigger autofill on a form identified by the fieldId.
+         * If the field and related form cannot be autofilled, returns an error.
+         */
+        trigger(params: Protocol.Autofill.TriggerRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Set addresses so that developers can verify their forms implementation.
+         */
+        setAddresses(params: Protocol.Autofill.SetAddressesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables autofill domain notifications.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables autofill domain notifications.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Emitted when an address form is filled.
+         */
+        onAddressFormFilled(listener: (event: { params: Protocol.Autofill.AddressFormFilledEvent }) => void): void;
+        offAddressFormFilled(listener: (event: { params: Protocol.Autofill.AddressFormFilledEvent }) => void): void;
+        onceAddressFormFilled(eventMatcher?: (event: { params: Protocol.Autofill.AddressFormFilledEvent }) => boolean): Promise<{ params: Protocol.Autofill.AddressFormFilledEvent }>;
+
+    }
+
+    export interface BackgroundServiceApi {
+        /**
+         * Enables event updates for the service.
+         */
+        startObserving(params: Protocol.BackgroundService.StartObservingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables event updates for the service.
+         */
+        stopObserving(params: Protocol.BackgroundService.StopObservingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Set the recording state for the service.
+         */
+        setRecording(params: Protocol.BackgroundService.SetRecordingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears all stored data for the service.
+         */
+        clearEvents(params: Protocol.BackgroundService.ClearEventsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Called when the recording state for the service has been updated.
+         */
+        onRecordingStateChanged(listener: (event: { params: Protocol.BackgroundService.RecordingStateChangedEvent }) => void): void;
+        offRecordingStateChanged(listener: (event: { params: Protocol.BackgroundService.RecordingStateChangedEvent }) => void): void;
+        onceRecordingStateChanged(eventMatcher?: (event: { params: Protocol.BackgroundService.RecordingStateChangedEvent }) => boolean): Promise<{ params: Protocol.BackgroundService.RecordingStateChangedEvent }>;
+
+        /**
+         * Called with all existing backgroundServiceEvents when enabled, and all new
+         * events afterwards if enabled and recording.
+         */
+        onBackgroundServiceEventReceived(listener: (event: { params: Protocol.BackgroundService.BackgroundServiceEventReceivedEvent }) => void): void;
+        offBackgroundServiceEventReceived(listener: (event: { params: Protocol.BackgroundService.BackgroundServiceEventReceivedEvent }) => void): void;
+        onceBackgroundServiceEventReceived(eventMatcher?: (event: { params: Protocol.BackgroundService.BackgroundServiceEventReceivedEvent }) => boolean): Promise<{ params: Protocol.BackgroundService.BackgroundServiceEventReceivedEvent }>;
+
+    }
+
+    export interface BrowserApi {
+        /**
+         * Set permission settings for given origin.
+         */
+        setPermission(params: Protocol.Browser.SetPermissionRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Grant specific permissions to the given origin and reject all others.
+         */
+        grantPermissions(params: Protocol.Browser.GrantPermissionsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Reset all permission management for all origins.
+         */
+        resetPermissions(params: Protocol.Browser.ResetPermissionsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Set the behavior when downloading a file.
+         */
+        setDownloadBehavior(params: Protocol.Browser.SetDownloadBehaviorRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Cancel a download if in progress
+         */
+        cancelDownload(params: Protocol.Browser.CancelDownloadRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Close browser gracefully.
+         */
+        close(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Crashes browser on the main thread.
+         */
+        crash(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Crashes GPU process.
+         */
+        crashGpuProcess(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns version information.
+         */
+        getVersion(): Promise<{id: number, result: Protocol.Browser.GetVersionResponse, sessionId: string}>;
+
+        /**
+         * Returns the command line switches for the browser process if, and only if
+         * --enable-automation is on the commandline.
+         */
+        getBrowserCommandLine(): Promise<{id: number, result: Protocol.Browser.GetBrowserCommandLineResponse, sessionId: string}>;
+
+        /**
+         * Get Chrome histograms.
+         */
+        getHistograms(params: Protocol.Browser.GetHistogramsRequest): Promise<{id: number, result: Protocol.Browser.GetHistogramsResponse, sessionId: string}>;
+
+        /**
+         * Get a Chrome histogram by name.
+         */
+        getHistogram(params: Protocol.Browser.GetHistogramRequest): Promise<{id: number, result: Protocol.Browser.GetHistogramResponse, sessionId: string}>;
+
+        /**
+         * Get position and size of the browser window.
+         */
+        getWindowBounds(params: Protocol.Browser.GetWindowBoundsRequest): Promise<{id: number, result: Protocol.Browser.GetWindowBoundsResponse, sessionId: string}>;
+
+        /**
+         * Get the browser window that contains the devtools target.
+         */
+        getWindowForTarget(params: Protocol.Browser.GetWindowForTargetRequest): Promise<{id: number, result: Protocol.Browser.GetWindowForTargetResponse, sessionId: string}>;
+
+        /**
+         * Set position and/or size of the browser window.
+         */
+        setWindowBounds(params: Protocol.Browser.SetWindowBoundsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Set dock tile details, platform-specific.
+         */
+        setDockTile(params: Protocol.Browser.SetDockTileRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Invoke custom browser commands used by telemetry.
+         */
+        executeBrowserCommand(params: Protocol.Browser.ExecuteBrowserCommandRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Allows a site to use privacy sandbox features that require enrollment
+         * without the site actually being enrolled. Only supported on page targets.
+         */
+        addPrivacySandboxEnrollmentOverride(params: Protocol.Browser.AddPrivacySandboxEnrollmentOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Fired when page is about to start a download.
+         */
+        onDownloadWillBegin(listener: (event: { params: Protocol.Browser.DownloadWillBeginEvent }) => void): void;
+        offDownloadWillBegin(listener: (event: { params: Protocol.Browser.DownloadWillBeginEvent }) => void): void;
+        onceDownloadWillBegin(eventMatcher?: (event: { params: Protocol.Browser.DownloadWillBeginEvent }) => boolean): Promise<{ params: Protocol.Browser.DownloadWillBeginEvent }>;
+
+        /**
+         * Fired when download makes progress. Last call has |done| == true.
+         */
+        onDownloadProgress(listener: (event: { params: Protocol.Browser.DownloadProgressEvent }) => void): void;
+        offDownloadProgress(listener: (event: { params: Protocol.Browser.DownloadProgressEvent }) => void): void;
+        onceDownloadProgress(eventMatcher?: (event: { params: Protocol.Browser.DownloadProgressEvent }) => boolean): Promise<{ params: Protocol.Browser.DownloadProgressEvent }>;
+
+    }
+
+    export interface CSSApi {
+        /**
+         * Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
+         * position specified by `location`.
+         */
+        addRule(params: Protocol.CSS.AddRuleRequest): Promise<{id: number, result: Protocol.CSS.AddRuleResponse, sessionId: string}>;
+
+        /**
+         * Returns all class names from specified stylesheet.
+         */
+        collectClassNames(params: Protocol.CSS.CollectClassNamesRequest): Promise<{id: number, result: Protocol.CSS.CollectClassNamesResponse, sessionId: string}>;
+
+        /**
+         * Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
+         */
+        createStyleSheet(params: Protocol.CSS.CreateStyleSheetRequest): Promise<{id: number, result: Protocol.CSS.CreateStyleSheetResponse, sessionId: string}>;
+
+        /**
+         * Disables the CSS agent for the given page.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
+         * enabled until the result of this command is received.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Ensures that the given node will have specified pseudo-classes whenever its style is computed by
+         * the browser.
+         */
+        forcePseudoState(params: Protocol.CSS.ForcePseudoStateRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        getBackgroundColors(params: Protocol.CSS.GetBackgroundColorsRequest): Promise<{id: number, result: Protocol.CSS.GetBackgroundColorsResponse, sessionId: string}>;
+
+        /**
+         * Returns the computed style for a DOM node identified by `nodeId`.
+         */
+        getComputedStyleForNode(params: Protocol.CSS.GetComputedStyleForNodeRequest): Promise<{id: number, result: Protocol.CSS.GetComputedStyleForNodeResponse, sessionId: string}>;
+
+        /**
+         * Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
+         * attributes) for a DOM node identified by `nodeId`.
+         */
+        getInlineStylesForNode(params: Protocol.CSS.GetInlineStylesForNodeRequest): Promise<{id: number, result: Protocol.CSS.GetInlineStylesForNodeResponse, sessionId: string}>;
+
+        /**
+         * Returns requested styles for a DOM node identified by `nodeId`.
+         */
+        getMatchedStylesForNode(params: Protocol.CSS.GetMatchedStylesForNodeRequest): Promise<{id: number, result: Protocol.CSS.GetMatchedStylesForNodeResponse, sessionId: string}>;
+
+        /**
+         * Returns all media queries parsed by the rendering engine.
+         */
+        getMediaQueries(): Promise<{id: number, result: Protocol.CSS.GetMediaQueriesResponse, sessionId: string}>;
+
+        /**
+         * Requests information about platform fonts which we used to render child TextNodes in the given
+         * node.
+         */
+        getPlatformFontsForNode(params: Protocol.CSS.GetPlatformFontsForNodeRequest): Promise<{id: number, result: Protocol.CSS.GetPlatformFontsForNodeResponse, sessionId: string}>;
+
+        /**
+         * Returns the current textual content for a stylesheet.
+         */
+        getStyleSheetText(params: Protocol.CSS.GetStyleSheetTextRequest): Promise<{id: number, result: Protocol.CSS.GetStyleSheetTextResponse, sessionId: string}>;
+
+        /**
+         * Returns all layers parsed by the rendering engine for the tree scope of a node.
+         * Given a DOM element identified by nodeId, getLayersForNode returns the root
+         * layer for the nearest ancestor document or shadow root. The layer root contains
+         * the full layer tree for the tree scope and their ordering.
+         */
+        getLayersForNode(params: Protocol.CSS.GetLayersForNodeRequest): Promise<{id: number, result: Protocol.CSS.GetLayersForNodeResponse, sessionId: string}>;
+
+        /**
+         * Given a CSS selector text and a style sheet ID, getLocationForSelector
+         * returns an array of locations of the CSS selector in the style sheet.
+         */
+        getLocationForSelector(params: Protocol.CSS.GetLocationForSelectorRequest): Promise<{id: number, result: Protocol.CSS.GetLocationForSelectorResponse, sessionId: string}>;
+
+        /**
+         * Starts tracking the given computed styles for updates. The specified array of properties
+         * replaces the one previously specified. Pass empty array to disable tracking.
+         * Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
+         * The changes to computed style properties are only tracked for nodes pushed to the front-end
+         * by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
+         * to the front-end, no updates will be issued for the node.
+         */
+        trackComputedStyleUpdates(params: Protocol.CSS.TrackComputedStyleUpdatesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Polls the next batch of computed style updates.
+         */
+        takeComputedStyleUpdates(): Promise<{id: number, result: Protocol.CSS.TakeComputedStyleUpdatesResponse, sessionId: string}>;
+
+        /**
+         * Find a rule with the given active property for the given node and set the new value for this
+         * property
+         */
+        setEffectivePropertyValueForNode(params: Protocol.CSS.SetEffectivePropertyValueForNodeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Modifies the property rule property name.
+         */
+        setPropertyRulePropertyName(params: Protocol.CSS.SetPropertyRulePropertyNameRequest): Promise<{id: number, result: Protocol.CSS.SetPropertyRulePropertyNameResponse, sessionId: string}>;
+
+        /**
+         * Modifies the keyframe rule key text.
+         */
+        setKeyframeKey(params: Protocol.CSS.SetKeyframeKeyRequest): Promise<{id: number, result: Protocol.CSS.SetKeyframeKeyResponse, sessionId: string}>;
+
+        /**
+         * Modifies the rule selector.
+         */
+        setMediaText(params: Protocol.CSS.SetMediaTextRequest): Promise<{id: number, result: Protocol.CSS.SetMediaTextResponse, sessionId: string}>;
+
+        /**
+         * Modifies the expression of a container query.
+         */
+        setContainerQueryText(params: Protocol.CSS.SetContainerQueryTextRequest): Promise<{id: number, result: Protocol.CSS.SetContainerQueryTextResponse, sessionId: string}>;
+
+        /**
+         * Modifies the expression of a supports at-rule.
+         */
+        setSupportsText(params: Protocol.CSS.SetSupportsTextRequest): Promise<{id: number, result: Protocol.CSS.SetSupportsTextResponse, sessionId: string}>;
+
+        /**
+         * Modifies the expression of a scope at-rule.
+         */
+        setScopeText(params: Protocol.CSS.SetScopeTextRequest): Promise<{id: number, result: Protocol.CSS.SetScopeTextResponse, sessionId: string}>;
+
+        /**
+         * Modifies the rule selector.
+         */
+        setRuleSelector(params: Protocol.CSS.SetRuleSelectorRequest): Promise<{id: number, result: Protocol.CSS.SetRuleSelectorResponse, sessionId: string}>;
+
+        /**
+         * Sets the new stylesheet text.
+         */
+        setStyleSheetText(params: Protocol.CSS.SetStyleSheetTextRequest): Promise<{id: number, result: Protocol.CSS.SetStyleSheetTextResponse, sessionId: string}>;
+
+        /**
+         * Applies specified style edits one after another in the given order.
+         */
+        setStyleTexts(params: Protocol.CSS.SetStyleTextsRequest): Promise<{id: number, result: Protocol.CSS.SetStyleTextsResponse, sessionId: string}>;
+
+        /**
+         * Enables the selector recording.
+         */
+        startRuleUsageTracking(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Stop tracking rule usage and return the list of rules that were used since last call to
+         * `takeCoverageDelta` (or since start of coverage instrumentation).
+         */
+        stopRuleUsageTracking(): Promise<{id: number, result: Protocol.CSS.StopRuleUsageTrackingResponse, sessionId: string}>;
+
+        /**
+         * Obtain list of rules that became used since last call to this method (or since start of coverage
+         * instrumentation).
+         */
+        takeCoverageDelta(): Promise<{id: number, result: Protocol.CSS.TakeCoverageDeltaResponse, sessionId: string}>;
+
+        /**
+         * Enables/disables rendering of local CSS fonts (enabled by default).
+         */
+        setLocalFontsEnabled(params: Protocol.CSS.SetLocalFontsEnabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
+         * web font.
+         */
+        onFontsUpdated(listener: (event: { params: Protocol.CSS.FontsUpdatedEvent }) => void): void;
+        offFontsUpdated(listener: (event: { params: Protocol.CSS.FontsUpdatedEvent }) => void): void;
+        onceFontsUpdated(eventMatcher?: (event: { params: Protocol.CSS.FontsUpdatedEvent }) => boolean): Promise<{ params: Protocol.CSS.FontsUpdatedEvent }>;
+
+        /**
+         * Fires whenever a MediaQuery result changes (for example, after a browser window has been
+         * resized.) The current implementation considers only viewport-dependent media features.
+         */
+        onMediaQueryResultChanged(listener: (event: ) => void): void;
+        offMediaQueryResultChanged(listener: (event: ) => void): void;
+        onceMediaQueryResultChanged(eventMatcher?: (event: ) => boolean): Promise<>;
+
+        /**
+         * Fired whenever an active document stylesheet is added.
+         */
+        onStyleSheetAdded(listener: (event: { params: Protocol.CSS.StyleSheetAddedEvent }) => void): void;
+        offStyleSheetAdded(listener: (event: { params: Protocol.CSS.StyleSheetAddedEvent }) => void): void;
+        onceStyleSheetAdded(eventMatcher?: (event: { params: Protocol.CSS.StyleSheetAddedEvent }) => boolean): Promise<{ params: Protocol.CSS.StyleSheetAddedEvent }>;
+
+        /**
+         * Fired whenever a stylesheet is changed as a result of the client operation.
+         */
+        onStyleSheetChanged(listener: (event: { params: Protocol.CSS.StyleSheetChangedEvent }) => void): void;
+        offStyleSheetChanged(listener: (event: { params: Protocol.CSS.StyleSheetChangedEvent }) => void): void;
+        onceStyleSheetChanged(eventMatcher?: (event: { params: Protocol.CSS.StyleSheetChangedEvent }) => boolean): Promise<{ params: Protocol.CSS.StyleSheetChangedEvent }>;
+
+        /**
+         * Fired whenever an active document stylesheet is removed.
+         */
+        onStyleSheetRemoved(listener: (event: { params: Protocol.CSS.StyleSheetRemovedEvent }) => void): void;
+        offStyleSheetRemoved(listener: (event: { params: Protocol.CSS.StyleSheetRemovedEvent }) => void): void;
+        onceStyleSheetRemoved(eventMatcher?: (event: { params: Protocol.CSS.StyleSheetRemovedEvent }) => boolean): Promise<{ params: Protocol.CSS.StyleSheetRemovedEvent }>;
+
+    }
+
+    export interface CacheStorageApi {
+        /**
+         * Deletes a cache.
+         */
+        deleteCache(params: Protocol.CacheStorage.DeleteCacheRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Deletes a cache entry.
+         */
+        deleteEntry(params: Protocol.CacheStorage.DeleteEntryRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests cache names.
+         */
+        requestCacheNames(params: Protocol.CacheStorage.RequestCacheNamesRequest): Promise<{id: number, result: Protocol.CacheStorage.RequestCacheNamesResponse, sessionId: string}>;
+
+        /**
+         * Fetches cache entry.
+         */
+        requestCachedResponse(params: Protocol.CacheStorage.RequestCachedResponseRequest): Promise<{id: number, result: Protocol.CacheStorage.RequestCachedResponseResponse, sessionId: string}>;
+
+        /**
+         * Requests data from cache.
+         */
+        requestEntries(params: Protocol.CacheStorage.RequestEntriesRequest): Promise<{id: number, result: Protocol.CacheStorage.RequestEntriesResponse, sessionId: string}>;
+
+    }
+
+    export interface CastApi {
+        /**
+         * Starts observing for sinks that can be used for tab mirroring, and if set,
+         * sinks compatible with |presentationUrl| as well. When sinks are found, a
+         * |sinksUpdated| event is fired.
+         * Also starts observing for issue messages. When an issue is added or removed,
+         * an |issueUpdated| event is fired.
+         */
+        enable(params: Protocol.Cast.EnableRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Stops observing for sinks and issues.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets a sink to be used when the web page requests the browser to choose a
+         * sink via Presentation API, Remote Playback API, or Cast SDK.
+         */
+        setSinkToUse(params: Protocol.Cast.SetSinkToUseRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Starts mirroring the desktop to the sink.
+         */
+        startDesktopMirroring(params: Protocol.Cast.StartDesktopMirroringRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Starts mirroring the tab to the sink.
+         */
+        startTabMirroring(params: Protocol.Cast.StartTabMirroringRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Stops the active Cast session on the sink.
+         */
+        stopCasting(params: Protocol.Cast.StopCastingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * This is fired whenever the list of available sinks changes. A sink is a
+         * device or a software surface that you can cast to.
+         */
+        onSinksUpdated(listener: (event: { params: Protocol.Cast.SinksUpdatedEvent }) => void): void;
+        offSinksUpdated(listener: (event: { params: Protocol.Cast.SinksUpdatedEvent }) => void): void;
+        onceSinksUpdated(eventMatcher?: (event: { params: Protocol.Cast.SinksUpdatedEvent }) => boolean): Promise<{ params: Protocol.Cast.SinksUpdatedEvent }>;
+
+        /**
+         * This is fired whenever the outstanding issue/error message changes.
+         * |issueMessage| is empty if there is no issue.
+         */
+        onIssueUpdated(listener: (event: { params: Protocol.Cast.IssueUpdatedEvent }) => void): void;
+        offIssueUpdated(listener: (event: { params: Protocol.Cast.IssueUpdatedEvent }) => void): void;
+        onceIssueUpdated(eventMatcher?: (event: { params: Protocol.Cast.IssueUpdatedEvent }) => boolean): Promise<{ params: Protocol.Cast.IssueUpdatedEvent }>;
+
+    }
+
+    export interface DOMApi {
+        /**
+         * Collects class names for the node with given id and all of it's child nodes.
+         */
+        collectClassNamesFromSubtree(params: Protocol.DOM.CollectClassNamesFromSubtreeRequest): Promise<{id: number, result: Protocol.DOM.CollectClassNamesFromSubtreeResponse, sessionId: string}>;
+
+        /**
+         * Creates a deep copy of the specified node and places it into the target container before the
+         * given anchor.
+         */
+        copyTo(params: Protocol.DOM.CopyToRequest): Promise<{id: number, result: Protocol.DOM.CopyToResponse, sessionId: string}>;
+
+        /**
+         * Describes node given its id, does not require domain to be enabled. Does not start tracking any
+         * objects, can be used for automation.
+         */
+        describeNode(params: Protocol.DOM.DescribeNodeRequest): Promise<{id: number, result: Protocol.DOM.DescribeNodeResponse, sessionId: string}>;
+
+        /**
+         * Scrolls the specified rect of the given node into view if not already visible.
+         * Note: exactly one between nodeId, backendNodeId and objectId should be passed
+         * to identify the node.
+         */
+        scrollIntoViewIfNeeded(params: Protocol.DOM.ScrollIntoViewIfNeededRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables DOM agent for the given page.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Discards search results from the session with the given id. `getSearchResults` should no longer
+         * be called for that search.
+         */
+        discardSearchResults(params: Protocol.DOM.DiscardSearchResultsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables DOM agent for the given page.
+         */
+        enable(params: Protocol.DOM.EnableRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Focuses the given element.
+         */
+        focus(params: Protocol.DOM.FocusRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns attributes for the specified node.
+         */
+        getAttributes(params: Protocol.DOM.GetAttributesRequest): Promise<{id: number, result: Protocol.DOM.GetAttributesResponse, sessionId: string}>;
+
+        /**
+         * Returns boxes for the given node.
+         */
+        getBoxModel(params: Protocol.DOM.GetBoxModelRequest): Promise<{id: number, result: Protocol.DOM.GetBoxModelResponse, sessionId: string}>;
+
+        /**
+         * Returns quads that describe node position on the page. This method
+         * might return multiple quads for inline nodes.
+         */
+        getContentQuads(params: Protocol.DOM.GetContentQuadsRequest): Promise<{id: number, result: Protocol.DOM.GetContentQuadsResponse, sessionId: string}>;
+
+        /**
+         * Returns the root DOM node (and optionally the subtree) to the caller.
+         * Implicitly enables the DOM domain events for the current target.
+         */
+        getDocument(params: Protocol.DOM.GetDocumentRequest): Promise<{id: number, result: Protocol.DOM.GetDocumentResponse, sessionId: string}>;
+
+        /**
+         * Returns the root DOM node (and optionally the subtree) to the caller.
+         * Deprecated, as it is not designed to work well with the rest of the DOM agent.
+         * Use DOMSnapshot.captureSnapshot instead.
+         */
+        getFlattenedDocument(params: Protocol.DOM.GetFlattenedDocumentRequest): Promise<{id: number, result: Protocol.DOM.GetFlattenedDocumentResponse, sessionId: string}>;
+
+        /**
+         * Finds nodes with a given computed style in a subtree.
+         */
+        getNodesForSubtreeByStyle(params: Protocol.DOM.GetNodesForSubtreeByStyleRequest): Promise<{id: number, result: Protocol.DOM.GetNodesForSubtreeByStyleResponse, sessionId: string}>;
+
+        /**
+         * Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
+         * either returned or not.
+         */
+        getNodeForLocation(params: Protocol.DOM.GetNodeForLocationRequest): Promise<{id: number, result: Protocol.DOM.GetNodeForLocationResponse, sessionId: string}>;
+
+        /**
+         * Returns node's HTML markup.
+         */
+        getOuterHTML(params: Protocol.DOM.GetOuterHTMLRequest): Promise<{id: number, result: Protocol.DOM.GetOuterHTMLResponse, sessionId: string}>;
+
+        /**
+         * Returns the id of the nearest ancestor that is a relayout boundary.
+         */
+        getRelayoutBoundary(params: Protocol.DOM.GetRelayoutBoundaryRequest): Promise<{id: number, result: Protocol.DOM.GetRelayoutBoundaryResponse, sessionId: string}>;
+
+        /**
+         * Returns search results from given `fromIndex` to given `toIndex` from the search with the given
+         * identifier.
+         */
+        getSearchResults(params: Protocol.DOM.GetSearchResultsRequest): Promise<{id: number, result: Protocol.DOM.GetSearchResultsResponse, sessionId: string}>;
+
+        /**
+         * Hides any highlight.
+         */
+        hideHighlight(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Highlights DOM node.
+         */
+        highlightNode(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Highlights given rectangle.
+         */
+        highlightRect(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Marks last undoable state.
+         */
+        markUndoableState(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Moves node into the new container, places it before the given anchor.
+         */
+        moveTo(params: Protocol.DOM.MoveToRequest): Promise<{id: number, result: Protocol.DOM.MoveToResponse, sessionId: string}>;
+
+        /**
+         * Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
+         * `cancelSearch` to end this search session.
+         */
+        performSearch(params: Protocol.DOM.PerformSearchRequest): Promise<{id: number, result: Protocol.DOM.PerformSearchResponse, sessionId: string}>;
+
+        /**
+         * Requests that the node is sent to the caller given its path. // FIXME, use XPath
+         */
+        pushNodeByPathToFrontend(params: Protocol.DOM.PushNodeByPathToFrontendRequest): Promise<{id: number, result: Protocol.DOM.PushNodeByPathToFrontendResponse, sessionId: string}>;
+
+        /**
+         * Requests that a batch of nodes is sent to the caller given their backend node ids.
+         */
+        pushNodesByBackendIdsToFrontend(params: Protocol.DOM.PushNodesByBackendIdsToFrontendRequest): Promise<{id: number, result: Protocol.DOM.PushNodesByBackendIdsToFrontendResponse, sessionId: string}>;
+
+        /**
+         * Executes `querySelector` on a given node.
+         */
+        querySelector(params: Protocol.DOM.QuerySelectorRequest): Promise<{id: number, result: Protocol.DOM.QuerySelectorResponse, sessionId: string}>;
+
+        /**
+         * Executes `querySelectorAll` on a given node.
+         */
+        querySelectorAll(params: Protocol.DOM.QuerySelectorAllRequest): Promise<{id: number, result: Protocol.DOM.QuerySelectorAllResponse, sessionId: string}>;
+
+        /**
+         * Returns NodeIds of current top layer elements.
+         * Top layer is rendered closest to the user within a viewport, therefore its elements always
+         * appear on top of all other content.
+         */
+        getTopLayerElements(): Promise<{id: number, result: Protocol.DOM.GetTopLayerElementsResponse, sessionId: string}>;
+
+        /**
+         * Returns the NodeId of the matched element according to certain relations.
+         */
+        getElementByRelation(params: Protocol.DOM.GetElementByRelationRequest): Promise<{id: number, result: Protocol.DOM.GetElementByRelationResponse, sessionId: string}>;
+
+        /**
+         * Re-does the last undone action.
+         */
+        redo(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Removes attribute with given name from an element with given id.
+         */
+        removeAttribute(params: Protocol.DOM.RemoveAttributeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Removes node with given id.
+         */
+        removeNode(params: Protocol.DOM.RemoveNodeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests that children of the node with given id are returned to the caller in form of
+         * `setChildNodes` events where not only immediate children are retrieved, but all children down to
+         * the specified depth.
+         */
+        requestChildNodes(params: Protocol.DOM.RequestChildNodesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests that the node is sent to the caller given the JavaScript node object reference. All
+         * nodes that form the path from the node to the root are also sent to the client as a series of
+         * `setChildNodes` notifications.
+         */
+        requestNode(params: Protocol.DOM.RequestNodeRequest): Promise<{id: number, result: Protocol.DOM.RequestNodeResponse, sessionId: string}>;
+
+        /**
+         * Resolves the JavaScript node object for a given NodeId or BackendNodeId.
+         */
+        resolveNode(params: Protocol.DOM.ResolveNodeRequest): Promise<{id: number, result: Protocol.DOM.ResolveNodeResponse, sessionId: string}>;
+
+        /**
+         * Sets attribute for an element with given id.
+         */
+        setAttributeValue(params: Protocol.DOM.SetAttributeValueRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets attributes on element with given id. This method is useful when user edits some existing
+         * attribute value and types in several attribute name/value pairs.
+         */
+        setAttributesAsText(params: Protocol.DOM.SetAttributesAsTextRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets files for the given file input element.
+         */
+        setFileInputFiles(params: Protocol.DOM.SetFileInputFilesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
+         */
+        setNodeStackTracesEnabled(params: Protocol.DOM.SetNodeStackTracesEnabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
+         */
+        getNodeStackTraces(params: Protocol.DOM.GetNodeStackTracesRequest): Promise<{id: number, result: Protocol.DOM.GetNodeStackTracesResponse, sessionId: string}>;
+
+        /**
+         * Returns file information for the given
+         * File wrapper.
+         */
+        getFileInfo(params: Protocol.DOM.GetFileInfoRequest): Promise<{id: number, result: Protocol.DOM.GetFileInfoResponse, sessionId: string}>;
+
+        /**
+         * Returns list of detached nodes
+         */
+        getDetachedDomNodes(): Promise<{id: number, result: Protocol.DOM.GetDetachedDomNodesResponse, sessionId: string}>;
+
+        /**
+         * Enables console to refer to the node with given id via $x (see Command Line API for more details
+         * $x functions).
+         */
+        setInspectedNode(params: Protocol.DOM.SetInspectedNodeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets node name for a node with given id.
+         */
+        setNodeName(params: Protocol.DOM.SetNodeNameRequest): Promise<{id: number, result: Protocol.DOM.SetNodeNameResponse, sessionId: string}>;
+
+        /**
+         * Sets node value for a node with given id.
+         */
+        setNodeValue(params: Protocol.DOM.SetNodeValueRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets node HTML markup, returns new node id.
+         */
+        setOuterHTML(params: Protocol.DOM.SetOuterHTMLRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Undoes the last performed action.
+         */
+        undo(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns iframe node that owns iframe with the given domain.
+         */
+        getFrameOwner(params: Protocol.DOM.GetFrameOwnerRequest): Promise<{id: number, result: Protocol.DOM.GetFrameOwnerResponse, sessionId: string}>;
+
+        /**
+         * Returns the query container of the given node based on container query
+         * conditions: containerName, physical, and logical axes. If no axes are
+         * provided, the style container is returned, which is the direct parent or the
+         * closest element with a matching container-name.
+         */
+        getContainerForNode(params: Protocol.DOM.GetContainerForNodeRequest): Promise<{id: number, result: Protocol.DOM.GetContainerForNodeResponse, sessionId: string}>;
+
+        /**
+         * Returns the descendants of a container query container that have
+         * container queries against this container.
+         */
+        getQueryingDescendantsForContainer(params: Protocol.DOM.GetQueryingDescendantsForContainerRequest): Promise<{id: number, result: Protocol.DOM.GetQueryingDescendantsForContainerResponse, sessionId: string}>;
+
+        /**
+         * Returns the target anchor element of the given anchor query according to
+         * https://www.w3.org/TR/css-anchor-position-1/#target.
+         */
+        getAnchorElement(params: Protocol.DOM.GetAnchorElementRequest): Promise<{id: number, result: Protocol.DOM.GetAnchorElementResponse, sessionId: string}>;
+
+        /**
+         * Fired when `Element`'s attribute is modified.
+         */
+        onAttributeModified(listener: (event: { params: Protocol.DOM.AttributeModifiedEvent }) => void): void;
+        offAttributeModified(listener: (event: { params: Protocol.DOM.AttributeModifiedEvent }) => void): void;
+        onceAttributeModified(eventMatcher?: (event: { params: Protocol.DOM.AttributeModifiedEvent }) => boolean): Promise<{ params: Protocol.DOM.AttributeModifiedEvent }>;
+
+        /**
+         * Fired when `Element`'s attribute is removed.
+         */
+        onAttributeRemoved(listener: (event: { params: Protocol.DOM.AttributeRemovedEvent }) => void): void;
+        offAttributeRemoved(listener: (event: { params: Protocol.DOM.AttributeRemovedEvent }) => void): void;
+        onceAttributeRemoved(eventMatcher?: (event: { params: Protocol.DOM.AttributeRemovedEvent }) => boolean): Promise<{ params: Protocol.DOM.AttributeRemovedEvent }>;
+
+        /**
+         * Mirrors `DOMCharacterDataModified` event.
+         */
+        onCharacterDataModified(listener: (event: { params: Protocol.DOM.CharacterDataModifiedEvent }) => void): void;
+        offCharacterDataModified(listener: (event: { params: Protocol.DOM.CharacterDataModifiedEvent }) => void): void;
+        onceCharacterDataModified(eventMatcher?: (event: { params: Protocol.DOM.CharacterDataModifiedEvent }) => boolean): Promise<{ params: Protocol.DOM.CharacterDataModifiedEvent }>;
+
+        /**
+         * Fired when `Container`'s child node count has changed.
+         */
+        onChildNodeCountUpdated(listener: (event: { params: Protocol.DOM.ChildNodeCountUpdatedEvent }) => void): void;
+        offChildNodeCountUpdated(listener: (event: { params: Protocol.DOM.ChildNodeCountUpdatedEvent }) => void): void;
+        onceChildNodeCountUpdated(eventMatcher?: (event: { params: Protocol.DOM.ChildNodeCountUpdatedEvent }) => boolean): Promise<{ params: Protocol.DOM.ChildNodeCountUpdatedEvent }>;
+
+        /**
+         * Mirrors `DOMNodeInserted` event.
+         */
+        onChildNodeInserted(listener: (event: { params: Protocol.DOM.ChildNodeInsertedEvent }) => void): void;
+        offChildNodeInserted(listener: (event: { params: Protocol.DOM.ChildNodeInsertedEvent }) => void): void;
+        onceChildNodeInserted(eventMatcher?: (event: { params: Protocol.DOM.ChildNodeInsertedEvent }) => boolean): Promise<{ params: Protocol.DOM.ChildNodeInsertedEvent }>;
+
+        /**
+         * Mirrors `DOMNodeRemoved` event.
+         */
+        onChildNodeRemoved(listener: (event: { params: Protocol.DOM.ChildNodeRemovedEvent }) => void): void;
+        offChildNodeRemoved(listener: (event: { params: Protocol.DOM.ChildNodeRemovedEvent }) => void): void;
+        onceChildNodeRemoved(eventMatcher?: (event: { params: Protocol.DOM.ChildNodeRemovedEvent }) => boolean): Promise<{ params: Protocol.DOM.ChildNodeRemovedEvent }>;
+
+        /**
+         * Called when distribution is changed.
+         */
+        onDistributedNodesUpdated(listener: (event: { params: Protocol.DOM.DistributedNodesUpdatedEvent }) => void): void;
+        offDistributedNodesUpdated(listener: (event: { params: Protocol.DOM.DistributedNodesUpdatedEvent }) => void): void;
+        onceDistributedNodesUpdated(eventMatcher?: (event: { params: Protocol.DOM.DistributedNodesUpdatedEvent }) => boolean): Promise<{ params: Protocol.DOM.DistributedNodesUpdatedEvent }>;
+
+        /**
+         * Fired when `Document` has been totally updated. Node ids are no longer valid.
+         */
+        onDocumentUpdated(listener: (event: ) => void): void;
+        offDocumentUpdated(listener: (event: ) => void): void;
+        onceDocumentUpdated(eventMatcher?: (event: ) => boolean): Promise<>;
+
+        /**
+         * Fired when `Element`'s inline style is modified via a CSS property modification.
+         */
+        onInlineStyleInvalidated(listener: (event: { params: Protocol.DOM.InlineStyleInvalidatedEvent }) => void): void;
+        offInlineStyleInvalidated(listener: (event: { params: Protocol.DOM.InlineStyleInvalidatedEvent }) => void): void;
+        onceInlineStyleInvalidated(eventMatcher?: (event: { params: Protocol.DOM.InlineStyleInvalidatedEvent }) => boolean): Promise<{ params: Protocol.DOM.InlineStyleInvalidatedEvent }>;
+
+        /**
+         * Called when a pseudo element is added to an element.
+         */
+        onPseudoElementAdded(listener: (event: { params: Protocol.DOM.PseudoElementAddedEvent }) => void): void;
+        offPseudoElementAdded(listener: (event: { params: Protocol.DOM.PseudoElementAddedEvent }) => void): void;
+        oncePseudoElementAdded(eventMatcher?: (event: { params: Protocol.DOM.PseudoElementAddedEvent }) => boolean): Promise<{ params: Protocol.DOM.PseudoElementAddedEvent }>;
+
+        /**
+         * Called when top layer elements are changed.
+         */
+        onTopLayerElementsUpdated(listener: (event: ) => void): void;
+        offTopLayerElementsUpdated(listener: (event: ) => void): void;
+        onceTopLayerElementsUpdated(eventMatcher?: (event: ) => boolean): Promise<>;
+
+        /**
+         * Called when a pseudo element is removed from an element.
+         */
+        onPseudoElementRemoved(listener: (event: { params: Protocol.DOM.PseudoElementRemovedEvent }) => void): void;
+        offPseudoElementRemoved(listener: (event: { params: Protocol.DOM.PseudoElementRemovedEvent }) => void): void;
+        oncePseudoElementRemoved(eventMatcher?: (event: { params: Protocol.DOM.PseudoElementRemovedEvent }) => boolean): Promise<{ params: Protocol.DOM.PseudoElementRemovedEvent }>;
+
+        /**
+         * Fired when backend wants to provide client with the missing DOM structure. This happens upon
+         * most of the calls requesting node ids.
+         */
+        onSetChildNodes(listener: (event: { params: Protocol.DOM.SetChildNodesEvent }) => void): void;
+        offSetChildNodes(listener: (event: { params: Protocol.DOM.SetChildNodesEvent }) => void): void;
+        onceSetChildNodes(eventMatcher?: (event: { params: Protocol.DOM.SetChildNodesEvent }) => boolean): Promise<{ params: Protocol.DOM.SetChildNodesEvent }>;
+
+        /**
+         * Called when shadow root is popped from the element.
+         */
+        onShadowRootPopped(listener: (event: { params: Protocol.DOM.ShadowRootPoppedEvent }) => void): void;
+        offShadowRootPopped(listener: (event: { params: Protocol.DOM.ShadowRootPoppedEvent }) => void): void;
+        onceShadowRootPopped(eventMatcher?: (event: { params: Protocol.DOM.ShadowRootPoppedEvent }) => boolean): Promise<{ params: Protocol.DOM.ShadowRootPoppedEvent }>;
+
+        /**
+         * Called when shadow root is pushed into the element.
+         */
+        onShadowRootPushed(listener: (event: { params: Protocol.DOM.ShadowRootPushedEvent }) => void): void;
+        offShadowRootPushed(listener: (event: { params: Protocol.DOM.ShadowRootPushedEvent }) => void): void;
+        onceShadowRootPushed(eventMatcher?: (event: { params: Protocol.DOM.ShadowRootPushedEvent }) => boolean): Promise<{ params: Protocol.DOM.ShadowRootPushedEvent }>;
+
+    }
+
+    export interface DOMDebuggerApi {
+        /**
+         * Returns event listeners of the given object.
+         */
+        getEventListeners(params: Protocol.DOMDebugger.GetEventListenersRequest): Promise<{id: number, result: Protocol.DOMDebugger.GetEventListenersResponse, sessionId: string}>;
+
+        /**
+         * Removes DOM breakpoint that was set using `setDOMBreakpoint`.
+         */
+        removeDOMBreakpoint(params: Protocol.DOMDebugger.RemoveDOMBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Removes breakpoint on particular DOM event.
+         */
+        removeEventListenerBreakpoint(params: Protocol.DOMDebugger.RemoveEventListenerBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Removes breakpoint on particular native event.
+         */
+        removeInstrumentationBreakpoint(params: Protocol.DOMDebugger.RemoveInstrumentationBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Removes breakpoint from XMLHttpRequest.
+         */
+        removeXHRBreakpoint(params: Protocol.DOMDebugger.RemoveXHRBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets breakpoint on particular CSP violations.
+         */
+        setBreakOnCSPViolation(params: Protocol.DOMDebugger.SetBreakOnCSPViolationRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets breakpoint on particular operation with DOM.
+         */
+        setDOMBreakpoint(params: Protocol.DOMDebugger.SetDOMBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets breakpoint on particular DOM event.
+         */
+        setEventListenerBreakpoint(params: Protocol.DOMDebugger.SetEventListenerBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets breakpoint on particular native event.
+         */
+        setInstrumentationBreakpoint(params: Protocol.DOMDebugger.SetInstrumentationBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets breakpoint on XMLHttpRequest.
+         */
+        setXHRBreakpoint(params: Protocol.DOMDebugger.SetXHRBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+    }
+
+    export interface EventBreakpointsApi {
+        /**
+         * Sets breakpoint on particular native event.
+         */
+        setInstrumentationBreakpoint(params: Protocol.EventBreakpoints.SetInstrumentationBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Removes breakpoint on particular native event.
+         */
+        removeInstrumentationBreakpoint(params: Protocol.EventBreakpoints.RemoveInstrumentationBreakpointRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Removes all breakpoints
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+    }
+
+    export interface DOMSnapshotApi {
+        /**
+         * Disables DOM snapshot agent for the given page.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables DOM snapshot agent for the given page.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns a document snapshot, including the full DOM tree of the root node (including iframes,
+         * template contents, and imported documents) in a flattened array, as well as layout and
+         * white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
+         * flattened.
+         */
+        getSnapshot(params: Protocol.DOMSnapshot.GetSnapshotRequest): Promise<{id: number, result: Protocol.DOMSnapshot.GetSnapshotResponse, sessionId: string}>;
+
+        /**
+         * Returns a document snapshot, including the full DOM tree of the root node (including iframes,
+         * template contents, and imported documents) in a flattened array, as well as layout and
+         * white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
+         * flattened.
+         */
+        captureSnapshot(params: Protocol.DOMSnapshot.CaptureSnapshotRequest): Promise<{id: number, result: Protocol.DOMSnapshot.CaptureSnapshotResponse, sessionId: string}>;
+
+    }
+
+    export interface DOMStorageApi {
+        clear(params: Protocol.DOMStorage.ClearRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables storage tracking, prevents storage events from being sent to the client.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables storage tracking, storage events will now be delivered to the client.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        getDOMStorageItems(params: Protocol.DOMStorage.GetDOMStorageItemsRequest): Promise<{id: number, result: Protocol.DOMStorage.GetDOMStorageItemsResponse, sessionId: string}>;
+
+        removeDOMStorageItem(params: Protocol.DOMStorage.RemoveDOMStorageItemRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setDOMStorageItem(params: Protocol.DOMStorage.SetDOMStorageItemRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        onDomStorageItemAdded(listener: (event: { params: Protocol.DOMStorage.DomStorageItemAddedEvent }) => void): void;
+        offDomStorageItemAdded(listener: (event: { params: Protocol.DOMStorage.DomStorageItemAddedEvent }) => void): void;
+        onceDomStorageItemAdded(eventMatcher?: (event: { params: Protocol.DOMStorage.DomStorageItemAddedEvent }) => boolean): Promise<{ params: Protocol.DOMStorage.DomStorageItemAddedEvent }>;
+
+        onDomStorageItemRemoved(listener: (event: { params: Protocol.DOMStorage.DomStorageItemRemovedEvent }) => void): void;
+        offDomStorageItemRemoved(listener: (event: { params: Protocol.DOMStorage.DomStorageItemRemovedEvent }) => void): void;
+        onceDomStorageItemRemoved(eventMatcher?: (event: { params: Protocol.DOMStorage.DomStorageItemRemovedEvent }) => boolean): Promise<{ params: Protocol.DOMStorage.DomStorageItemRemovedEvent }>;
+
+        onDomStorageItemUpdated(listener: (event: { params: Protocol.DOMStorage.DomStorageItemUpdatedEvent }) => void): void;
+        offDomStorageItemUpdated(listener: (event: { params: Protocol.DOMStorage.DomStorageItemUpdatedEvent }) => void): void;
+        onceDomStorageItemUpdated(eventMatcher?: (event: { params: Protocol.DOMStorage.DomStorageItemUpdatedEvent }) => boolean): Promise<{ params: Protocol.DOMStorage.DomStorageItemUpdatedEvent }>;
+
+        onDomStorageItemsCleared(listener: (event: { params: Protocol.DOMStorage.DomStorageItemsClearedEvent }) => void): void;
+        offDomStorageItemsCleared(listener: (event: { params: Protocol.DOMStorage.DomStorageItemsClearedEvent }) => void): void;
+        onceDomStorageItemsCleared(eventMatcher?: (event: { params: Protocol.DOMStorage.DomStorageItemsClearedEvent }) => boolean): Promise<{ params: Protocol.DOMStorage.DomStorageItemsClearedEvent }>;
+
+    }
+
+    export interface DatabaseApi {
+        /**
+         * Disables database tracking, prevents database events from being sent to the client.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables database tracking, database events will now be delivered to the client.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        executeSQL(params: Protocol.Database.ExecuteSQLRequest): Promise<{id: number, result: Protocol.Database.ExecuteSQLResponse, sessionId: string}>;
+
+        getDatabaseTableNames(params: Protocol.Database.GetDatabaseTableNamesRequest): Promise<{id: number, result: Protocol.Database.GetDatabaseTableNamesResponse, sessionId: string}>;
+
+        onAddDatabase(listener: (event: { params: Protocol.Database.AddDatabaseEvent }) => void): void;
+        offAddDatabase(listener: (event: { params: Protocol.Database.AddDatabaseEvent }) => void): void;
+        onceAddDatabase(eventMatcher?: (event: { params: Protocol.Database.AddDatabaseEvent }) => boolean): Promise<{ params: Protocol.Database.AddDatabaseEvent }>;
+
+    }
+
+    export interface DeviceOrientationApi {
+        /**
+         * Clears the overridden Device Orientation.
+         */
+        clearDeviceOrientationOverride(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Overrides the Device Orientation.
+         */
+        setDeviceOrientationOverride(params: Protocol.DeviceOrientation.SetDeviceOrientationOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+    }
+
+    export interface EmulationApi {
+        /**
+         * Tells whether emulation is supported.
+         */
+        canEmulate(): Promise<{id: number, result: Protocol.Emulation.CanEmulateResponse, sessionId: string}>;
+
+        /**
+         * Clears the overridden device metrics.
+         */
+        clearDeviceMetricsOverride(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears the overridden Geolocation Position and Error.
+         */
+        clearGeolocationOverride(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests that page scale factor is reset to initial values.
+         */
+        resetPageScaleFactor(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables or disables simulating a focused and active page.
+         */
+        setFocusEmulationEnabled(params: Protocol.Emulation.SetFocusEmulationEnabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Automatically render all web contents using a dark theme.
+         */
+        setAutoDarkModeOverride(params: Protocol.Emulation.SetAutoDarkModeOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables CPU throttling to emulate slow CPUs.
+         */
+        setCPUThrottlingRate(params: Protocol.Emulation.SetCPUThrottlingRateRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets or clears an override of the default background color of the frame. This override is used
+         * if the content does not specify one.
+         */
+        setDefaultBackgroundColorOverride(params: Protocol.Emulation.SetDefaultBackgroundColorOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
+         * window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
+         * query results).
+         */
+        setDeviceMetricsOverride(params: Protocol.Emulation.SetDeviceMetricsOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Start reporting the given posture value to the Device Posture API.
+         * This override can also be set in setDeviceMetricsOverride().
+         */
+        setDevicePostureOverride(params: Protocol.Emulation.SetDevicePostureOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears a device posture override set with either setDeviceMetricsOverride()
+         * or setDevicePostureOverride() and starts using posture information from the
+         * platform again.
+         * Does nothing if no override is set.
+         */
+        clearDevicePostureOverride(): Promise<{id: number, result: void, sessionId: string}>;
+
+        setScrollbarsHidden(params: Protocol.Emulation.SetScrollbarsHiddenRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setDocumentCookieDisabled(params: Protocol.Emulation.SetDocumentCookieDisabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setEmitTouchEventsForMouse(params: Protocol.Emulation.SetEmitTouchEventsForMouseRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Emulates the given media type or media feature for CSS media queries.
+         */
+        setEmulatedMedia(params: Protocol.Emulation.SetEmulatedMediaRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Emulates the given vision deficiency.
+         */
+        setEmulatedVisionDeficiency(params: Protocol.Emulation.SetEmulatedVisionDeficiencyRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
+         * unavailable.
+         */
+        setGeolocationOverride(params: Protocol.Emulation.SetGeolocationOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        getOverriddenSensorInformation(params: Protocol.Emulation.GetOverriddenSensorInformationRequest): Promise<{id: number, result: Protocol.Emulation.GetOverriddenSensorInformationResponse, sessionId: string}>;
+
+        /**
+         * Overrides a platform sensor of a given type. If |enabled| is true, calls to
+         * Sensor.start() will use a virtual sensor as backend rather than fetching
+         * data from a real hardware sensor. Otherwise, existing virtual
+         * sensor-backend Sensor objects will fire an error event and new calls to
+         * Sensor.start() will attempt to use a real sensor instead.
+         */
+        setSensorOverrideEnabled(params: Protocol.Emulation.SetSensorOverrideEnabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Updates the sensor readings reported by a sensor type previously overridden
+         * by setSensorOverrideEnabled.
+         */
+        setSensorOverrideReadings(params: Protocol.Emulation.SetSensorOverrideReadingsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Overrides a pressure source of a given type, as used by the Compute
+         * Pressure API, so that updates to PressureObserver.observe() are provided
+         * via setPressureStateOverride instead of being retrieved from
+         * platform-provided telemetry data.
+         */
+        setPressureSourceOverrideEnabled(params: Protocol.Emulation.SetPressureSourceOverrideEnabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Provides a given pressure state that will be processed and eventually be
+         * delivered to PressureObserver users. |source| must have been previously
+         * overridden by setPressureSourceOverrideEnabled.
+         */
+        setPressureStateOverride(params: Protocol.Emulation.SetPressureStateOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Overrides the Idle state.
+         */
+        setIdleOverride(params: Protocol.Emulation.SetIdleOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears Idle state overrides.
+         */
+        clearIdleOverride(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Overrides value returned by the javascript navigator object.
+         */
+        setNavigatorOverrides(params: Protocol.Emulation.SetNavigatorOverridesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets a specified page scale factor.
+         */
+        setPageScaleFactor(params: Protocol.Emulation.SetPageScaleFactorRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Switches script execution in the page.
+         */
+        setScriptExecutionDisabled(params: Protocol.Emulation.SetScriptExecutionDisabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables touch on platforms which do not support them.
+         */
+        setTouchEmulationEnabled(params: Protocol.Emulation.SetTouchEmulationEnabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
+         * the current virtual time policy.  Note this supersedes any previous time budget.
+         */
+        setVirtualTimePolicy(params: Protocol.Emulation.SetVirtualTimePolicyRequest): Promise<{id: number, result: Protocol.Emulation.SetVirtualTimePolicyResponse, sessionId: string}>;
+
+        /**
+         * Overrides default host system locale with the specified one.
+         */
+        setLocaleOverride(params: Protocol.Emulation.SetLocaleOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Overrides default host system timezone with the specified one.
+         */
+        setTimezoneOverride(params: Protocol.Emulation.SetTimezoneOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Resizes the frame/viewport of the page. Note that this does not affect the frame's container
+         * (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
+         * on Android.
+         */
+        setVisibleSize(params: Protocol.Emulation.SetVisibleSizeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setDisabledImageTypes(params: Protocol.Emulation.SetDisabledImageTypesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setHardwareConcurrencyOverride(params: Protocol.Emulation.SetHardwareConcurrencyOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Allows overriding user agent with the given string.
+         * `userAgentMetadata` must be set for Client Hint headers to be sent.
+         */
+        setUserAgentOverride(params: Protocol.Emulation.SetUserAgentOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Allows overriding the automation flag.
+         */
+        setAutomationOverride(params: Protocol.Emulation.SetAutomationOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
+         */
+        onVirtualTimeBudgetExpired(listener: (event: ) => void): void;
+        offVirtualTimeBudgetExpired(listener: (event: ) => void): void;
+        onceVirtualTimeBudgetExpired(eventMatcher?: (event: ) => boolean): Promise<>;
+
+    }
+
+    export interface HeadlessExperimentalApi {
+        /**
+         * Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
+         * screenshot from the resulting frame. Requires that the target was created with enabled
+         * BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
+         * https://goo.gle/chrome-headless-rendering for more background.
+         */
+        beginFrame(params: Protocol.HeadlessExperimental.BeginFrameRequest): Promise<{id: number, result: Protocol.HeadlessExperimental.BeginFrameResponse, sessionId: string}>;
+
+        /**
+         * Disables headless events for the target.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables headless events for the target.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+    }
+
+    export interface IOApi {
+        /**
+         * Close the stream, discard any temporary backing storage.
+         */
+        close(params: Protocol.IO.CloseRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Read a chunk of the stream
+         */
+        read(params: Protocol.IO.ReadRequest): Promise<{id: number, result: Protocol.IO.ReadResponse, sessionId: string}>;
+
+        /**
+         * Return UUID of Blob object specified by a remote object id.
+         */
+        resolveBlob(params: Protocol.IO.ResolveBlobRequest): Promise<{id: number, result: Protocol.IO.ResolveBlobResponse, sessionId: string}>;
+
+    }
+
+    export interface FileSystemApi {
+        getDirectory(params: Protocol.FileSystem.GetDirectoryRequest): Promise<{id: number, result: Protocol.FileSystem.GetDirectoryResponse, sessionId: string}>;
+
+    }
+
+    export interface IndexedDBApi {
+        /**
+         * Clears all entries from an object store.
+         */
+        clearObjectStore(params: Protocol.IndexedDB.ClearObjectStoreRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Deletes a database.
+         */
+        deleteDatabase(params: Protocol.IndexedDB.DeleteDatabaseRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Delete a range of entries from an object store
+         */
+        deleteObjectStoreEntries(params: Protocol.IndexedDB.DeleteObjectStoreEntriesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables events from backend.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables events from backend.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests data from object store or index.
+         */
+        requestData(params: Protocol.IndexedDB.RequestDataRequest): Promise<{id: number, result: Protocol.IndexedDB.RequestDataResponse, sessionId: string}>;
+
+        /**
+         * Gets metadata of an object store.
+         */
+        getMetadata(params: Protocol.IndexedDB.GetMetadataRequest): Promise<{id: number, result: Protocol.IndexedDB.GetMetadataResponse, sessionId: string}>;
+
+        /**
+         * Requests database with given name in given frame.
+         */
+        requestDatabase(params: Protocol.IndexedDB.RequestDatabaseRequest): Promise<{id: number, result: Protocol.IndexedDB.RequestDatabaseResponse, sessionId: string}>;
+
+        /**
+         * Requests database names for given security origin.
+         */
+        requestDatabaseNames(params: Protocol.IndexedDB.RequestDatabaseNamesRequest): Promise<{id: number, result: Protocol.IndexedDB.RequestDatabaseNamesResponse, sessionId: string}>;
+
+    }
+
+    export interface InputApi {
+        /**
+         * Dispatches a drag event into the page.
+         */
+        dispatchDragEvent(params: Protocol.Input.DispatchDragEventRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Dispatches a key event to the page.
+         */
+        dispatchKeyEvent(params: Protocol.Input.DispatchKeyEventRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * This method emulates inserting text that doesn't come from a key press,
+         * for example an emoji keyboard or an IME.
+         */
+        insertText(params: Protocol.Input.InsertTextRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * This method sets the current candidate text for IME.
+         * Use imeCommitComposition to commit the final text.
+         * Use imeSetComposition with empty string as text to cancel composition.
+         */
+        imeSetComposition(params: Protocol.Input.ImeSetCompositionRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Dispatches a mouse event to the page.
+         */
+        dispatchMouseEvent(params: Protocol.Input.DispatchMouseEventRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Dispatches a touch event to the page.
+         */
+        dispatchTouchEvent(params: Protocol.Input.DispatchTouchEventRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Cancels any active dragging in the page.
+         */
+        cancelDragging(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Emulates touch event from the mouse event parameters.
+         */
+        emulateTouchFromMouseEvent(params: Protocol.Input.EmulateTouchFromMouseEventRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Ignores input events (useful while auditing page).
+         */
+        setIgnoreInputEvents(params: Protocol.Input.SetIgnoreInputEventsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
+         * Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
+         */
+        setInterceptDrags(params: Protocol.Input.SetInterceptDragsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
+         */
+        synthesizePinchGesture(params: Protocol.Input.SynthesizePinchGestureRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
+         */
+        synthesizeScrollGesture(params: Protocol.Input.SynthesizeScrollGestureRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Synthesizes a tap gesture over a time period by issuing appropriate touch events.
+         */
+        synthesizeTapGesture(params: Protocol.Input.SynthesizeTapGestureRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to
+         * restore normal drag and drop behavior.
+         */
+        onDragIntercepted(listener: (event: { params: Protocol.Input.DragInterceptedEvent }) => void): void;
+        offDragIntercepted(listener: (event: { params: Protocol.Input.DragInterceptedEvent }) => void): void;
+        onceDragIntercepted(eventMatcher?: (event: { params: Protocol.Input.DragInterceptedEvent }) => boolean): Promise<{ params: Protocol.Input.DragInterceptedEvent }>;
+
+    }
+
+    export interface InspectorApi {
+        /**
+         * Disables inspector domain notifications.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables inspector domain notifications.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Fired when remote debugging connection is about to be terminated. Contains detach reason.
+         */
+        onDetached(listener: (event: { params: Protocol.Inspector.DetachedEvent }) => void): void;
+        offDetached(listener: (event: { params: Protocol.Inspector.DetachedEvent }) => void): void;
+        onceDetached(eventMatcher?: (event: { params: Protocol.Inspector.DetachedEvent }) => boolean): Promise<{ params: Protocol.Inspector.DetachedEvent }>;
+
+        /**
+         * Fired when debugging target has crashed
+         */
+        onTargetCrashed(listener: (event: ) => void): void;
+        offTargetCrashed(listener: (event: ) => void): void;
+        onceTargetCrashed(eventMatcher?: (event: ) => boolean): Promise<>;
+
+        /**
+         * Fired when debugging target has reloaded after crash
+         */
+        onTargetReloadedAfterCrash(listener: (event: ) => void): void;
+        offTargetReloadedAfterCrash(listener: (event: ) => void): void;
+        onceTargetReloadedAfterCrash(eventMatcher?: (event: ) => boolean): Promise<>;
+
+    }
+
+    export interface LayerTreeApi {
+        /**
+         * Provides the reasons why the given layer was composited.
+         */
+        compositingReasons(params: Protocol.LayerTree.CompositingReasonsRequest): Promise<{id: number, result: Protocol.LayerTree.CompositingReasonsResponse, sessionId: string}>;
+
+        /**
+         * Disables compositing tree inspection.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables compositing tree inspection.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns the snapshot identifier.
+         */
+        loadSnapshot(params: Protocol.LayerTree.LoadSnapshotRequest): Promise<{id: number, result: Protocol.LayerTree.LoadSnapshotResponse, sessionId: string}>;
+
+        /**
+         * Returns the layer snapshot identifier.
+         */
+        makeSnapshot(params: Protocol.LayerTree.MakeSnapshotRequest): Promise<{id: number, result: Protocol.LayerTree.MakeSnapshotResponse, sessionId: string}>;
+
+        profileSnapshot(params: Protocol.LayerTree.ProfileSnapshotRequest): Promise<{id: number, result: Protocol.LayerTree.ProfileSnapshotResponse, sessionId: string}>;
+
+        /**
+         * Releases layer snapshot captured by the back-end.
+         */
+        releaseSnapshot(params: Protocol.LayerTree.ReleaseSnapshotRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Replays the layer snapshot and returns the resulting bitmap.
+         */
+        replaySnapshot(params: Protocol.LayerTree.ReplaySnapshotRequest): Promise<{id: number, result: Protocol.LayerTree.ReplaySnapshotResponse, sessionId: string}>;
+
+        /**
+         * Replays the layer snapshot and returns canvas log.
+         */
+        snapshotCommandLog(params: Protocol.LayerTree.SnapshotCommandLogRequest): Promise<{id: number, result: Protocol.LayerTree.SnapshotCommandLogResponse, sessionId: string}>;
+
+        onLayerPainted(listener: (event: { params: Protocol.LayerTree.LayerPaintedEvent }) => void): void;
+        offLayerPainted(listener: (event: { params: Protocol.LayerTree.LayerPaintedEvent }) => void): void;
+        onceLayerPainted(eventMatcher?: (event: { params: Protocol.LayerTree.LayerPaintedEvent }) => boolean): Promise<{ params: Protocol.LayerTree.LayerPaintedEvent }>;
+
+        onLayerTreeDidChange(listener: (event: { params: Protocol.LayerTree.LayerTreeDidChangeEvent }) => void): void;
+        offLayerTreeDidChange(listener: (event: { params: Protocol.LayerTree.LayerTreeDidChangeEvent }) => void): void;
+        onceLayerTreeDidChange(eventMatcher?: (event: { params: Protocol.LayerTree.LayerTreeDidChangeEvent }) => boolean): Promise<{ params: Protocol.LayerTree.LayerTreeDidChangeEvent }>;
+
+    }
+
+    export interface LogApi {
+        /**
+         * Clears the log.
+         */
+        clear(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables log domain, prevents further log entries from being reported to the client.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables log domain, sends the entries collected so far to the client by means of the
+         * `entryAdded` notification.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * start violation reporting.
+         */
+        startViolationsReport(params: Protocol.Log.StartViolationsReportRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Stop violation reporting.
+         */
+        stopViolationsReport(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Issued when new message was logged.
+         */
+        onEntryAdded(listener: (event: { params: Protocol.Log.EntryAddedEvent }) => void): void;
+        offEntryAdded(listener: (event: { params: Protocol.Log.EntryAddedEvent }) => void): void;
+        onceEntryAdded(eventMatcher?: (event: { params: Protocol.Log.EntryAddedEvent }) => boolean): Promise<{ params: Protocol.Log.EntryAddedEvent }>;
+
+    }
+
+    export interface MemoryApi {
+        getDOMCounters(): Promise<{id: number, result: Protocol.Memory.GetDOMCountersResponse, sessionId: string}>;
+
+        prepareForLeakDetection(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Simulate OomIntervention by purging V8 memory.
+         */
+        forciblyPurgeJavaScriptMemory(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enable/disable suppressing memory pressure notifications in all processes.
+         */
+        setPressureNotificationsSuppressed(params: Protocol.Memory.SetPressureNotificationsSuppressedRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Simulate a memory pressure notification in all processes.
+         */
+        simulatePressureNotification(params: Protocol.Memory.SimulatePressureNotificationRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Start collecting native memory profile.
+         */
+        startSampling(params: Protocol.Memory.StartSamplingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Stop collecting native memory profile.
+         */
+        stopSampling(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Retrieve native memory allocations profile
+         * collected since renderer process startup.
+         */
+        getAllTimeSamplingProfile(): Promise<{id: number, result: Protocol.Memory.GetAllTimeSamplingProfileResponse, sessionId: string}>;
+
+        /**
+         * Retrieve native memory allocations profile
+         * collected since browser process startup.
+         */
+        getBrowserSamplingProfile(): Promise<{id: number, result: Protocol.Memory.GetBrowserSamplingProfileResponse, sessionId: string}>;
+
+        /**
+         * Retrieve native memory allocations profile collected since last
+         * `startSampling` call.
+         */
+        getSamplingProfile(): Promise<{id: number, result: Protocol.Memory.GetSamplingProfileResponse, sessionId: string}>;
+
+    }
+
+    export interface NetworkApi {
+        /**
+         * Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.
+         */
+        setAcceptedEncodings(params: Protocol.Network.SetAcceptedEncodingsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears accepted encodings set by setAcceptedEncodings
+         */
+        clearAcceptedEncodingsOverride(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Tells whether clearing browser cache is supported.
+         */
+        canClearBrowserCache(): Promise<{id: number, result: Protocol.Network.CanClearBrowserCacheResponse, sessionId: string}>;
+
+        /**
+         * Tells whether clearing browser cookies is supported.
+         */
+        canClearBrowserCookies(): Promise<{id: number, result: Protocol.Network.CanClearBrowserCookiesResponse, sessionId: string}>;
+
+        /**
+         * Tells whether emulation of network conditions is supported.
+         */
+        canEmulateNetworkConditions(): Promise<{id: number, result: Protocol.Network.CanEmulateNetworkConditionsResponse, sessionId: string}>;
+
+        /**
+         * Clears browser cache.
+         */
+        clearBrowserCache(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears browser cookies.
+         */
+        clearBrowserCookies(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Response to Network.requestIntercepted which either modifies the request to continue with any
+         * modifications, or blocks it, or completes it with the provided response bytes. If a network
+         * fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
+         * event will be sent with the same InterceptionId.
+         * Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
+         */
+        continueInterceptedRequest(params: Protocol.Network.ContinueInterceptedRequestRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Deletes browser cookies with matching name and url or domain/path/partitionKey pair.
+         */
+        deleteCookies(params: Protocol.Network.DeleteCookiesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables network tracking, prevents network events from being sent to the client.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Activates emulation of network conditions.
+         */
+        emulateNetworkConditions(params: Protocol.Network.EmulateNetworkConditionsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables network tracking, network events will now be delivered to the client.
+         */
+        enable(params: Protocol.Network.EnableRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns all browser cookies. Depending on the backend support, will return detailed cookie
+         * information in the `cookies` field.
+         * Deprecated. Use Storage.getCookies instead.
+         */
+        getAllCookies(): Promise<{id: number, result: Protocol.Network.GetAllCookiesResponse, sessionId: string}>;
+
+        /**
+         * Returns the DER-encoded certificate.
+         */
+        getCertificate(params: Protocol.Network.GetCertificateRequest): Promise<{id: number, result: Protocol.Network.GetCertificateResponse, sessionId: string}>;
+
+        /**
+         * Returns all browser cookies for the current URL. Depending on the backend support, will return
+         * detailed cookie information in the `cookies` field.
+         */
+        getCookies(params: Protocol.Network.GetCookiesRequest): Promise<{id: number, result: Protocol.Network.GetCookiesResponse, sessionId: string}>;
+
+        /**
+         * Returns content served for the given request.
+         */
+        getResponseBody(params: Protocol.Network.GetResponseBodyRequest): Promise<{id: number, result: Protocol.Network.GetResponseBodyResponse, sessionId: string}>;
+
+        /**
+         * Returns post data sent with the request. Returns an error when no data was sent with the request.
+         */
+        getRequestPostData(params: Protocol.Network.GetRequestPostDataRequest): Promise<{id: number, result: Protocol.Network.GetRequestPostDataResponse, sessionId: string}>;
+
+        /**
+         * Returns content served for the given currently intercepted request.
+         */
+        getResponseBodyForInterception(params: Protocol.Network.GetResponseBodyForInterceptionRequest): Promise<{id: number, result: Protocol.Network.GetResponseBodyForInterceptionResponse, sessionId: string}>;
+
+        /**
+         * Returns a handle to the stream representing the response body. Note that after this command,
+         * the intercepted request can't be continued as is -- you either need to cancel it or to provide
+         * the response body. The stream only supports sequential read, IO.read will fail if the position
+         * is specified.
+         */
+        takeResponseBodyForInterceptionAsStream(params: Protocol.Network.TakeResponseBodyForInterceptionAsStreamRequest): Promise<{id: number, result: Protocol.Network.TakeResponseBodyForInterceptionAsStreamResponse, sessionId: string}>;
+
+        /**
+         * This method sends a new XMLHttpRequest which is identical to the original one. The following
+         * parameters should be identical: method, url, async, request body, extra headers, withCredentials
+         * attribute, user, password.
+         */
+        replayXHR(params: Protocol.Network.ReplayXHRRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Searches for given string in response content.
+         */
+        searchInResponseBody(params: Protocol.Network.SearchInResponseBodyRequest): Promise<{id: number, result: Protocol.Network.SearchInResponseBodyResponse, sessionId: string}>;
+
+        /**
+         * Blocks URLs from loading.
+         */
+        setBlockedURLs(params: Protocol.Network.SetBlockedURLsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Toggles ignoring of service worker for each request.
+         */
+        setBypassServiceWorker(params: Protocol.Network.SetBypassServiceWorkerRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Toggles ignoring cache for each request. If `true`, cache will not be used.
+         */
+        setCacheDisabled(params: Protocol.Network.SetCacheDisabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
+         */
+        setCookie(params: Protocol.Network.SetCookieRequest): Promise<{id: number, result: Protocol.Network.SetCookieResponse, sessionId: string}>;
+
+        /**
+         * Sets given cookies.
+         */
+        setCookies(params: Protocol.Network.SetCookiesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Specifies whether to always send extra HTTP headers with the requests from this page.
+         */
+        setExtraHTTPHeaders(params: Protocol.Network.SetExtraHTTPHeadersRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Specifies whether to attach a page script stack id in requests
+         */
+        setAttachDebugStack(params: Protocol.Network.SetAttachDebugStackRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets the requests to intercept that match the provided patterns and optionally resource types.
+         * Deprecated, please use Fetch.enable instead.
+         */
+        setRequestInterception(params: Protocol.Network.SetRequestInterceptionRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Allows overriding user agent with the given string.
+         */
+        setUserAgentOverride(params: Protocol.Network.SetUserAgentOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables streaming of the response for the given requestId.
+         * If enabled, the dataReceived event contains the data that was received during streaming.
+         */
+        streamResourceContent(params: Protocol.Network.StreamResourceContentRequest): Promise<{id: number, result: Protocol.Network.StreamResourceContentResponse, sessionId: string}>;
+
+        /**
+         * Returns information about the COEP/COOP isolation status.
+         */
+        getSecurityIsolationStatus(params: Protocol.Network.GetSecurityIsolationStatusRequest): Promise<{id: number, result: Protocol.Network.GetSecurityIsolationStatusResponse, sessionId: string}>;
+
+        /**
+         * Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
+         * Enabling triggers 'reportingApiReportAdded' for all existing reports.
+         */
+        enableReportingApi(params: Protocol.Network.EnableReportingApiRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Fetches the resource and returns the content.
+         */
+        loadNetworkResource(params: Protocol.Network.LoadNetworkResourceRequest): Promise<{id: number, result: Protocol.Network.LoadNetworkResourceResponse, sessionId: string}>;
+
+        /**
+         * Fired when data chunk was received over the network.
+         */
+        onDataReceived(listener: (event: { params: Protocol.Network.DataReceivedEvent }) => void): void;
+        offDataReceived(listener: (event: { params: Protocol.Network.DataReceivedEvent }) => void): void;
+        onceDataReceived(eventMatcher?: (event: { params: Protocol.Network.DataReceivedEvent }) => boolean): Promise<{ params: Protocol.Network.DataReceivedEvent }>;
+
+        /**
+         * Fired when EventSource message is received.
+         */
+        onEventSourceMessageReceived(listener: (event: { params: Protocol.Network.EventSourceMessageReceivedEvent }) => void): void;
+        offEventSourceMessageReceived(listener: (event: { params: Protocol.Network.EventSourceMessageReceivedEvent }) => void): void;
+        onceEventSourceMessageReceived(eventMatcher?: (event: { params: Protocol.Network.EventSourceMessageReceivedEvent }) => boolean): Promise<{ params: Protocol.Network.EventSourceMessageReceivedEvent }>;
+
+        /**
+         * Fired when HTTP request has failed to load.
+         */
+        onLoadingFailed(listener: (event: { params: Protocol.Network.LoadingFailedEvent }) => void): void;
+        offLoadingFailed(listener: (event: { params: Protocol.Network.LoadingFailedEvent }) => void): void;
+        onceLoadingFailed(eventMatcher?: (event: { params: Protocol.Network.LoadingFailedEvent }) => boolean): Promise<{ params: Protocol.Network.LoadingFailedEvent }>;
+
+        /**
+         * Fired when HTTP request has finished loading.
+         */
+        onLoadingFinished(listener: (event: { params: Protocol.Network.LoadingFinishedEvent }) => void): void;
+        offLoadingFinished(listener: (event: { params: Protocol.Network.LoadingFinishedEvent }) => void): void;
+        onceLoadingFinished(eventMatcher?: (event: { params: Protocol.Network.LoadingFinishedEvent }) => boolean): Promise<{ params: Protocol.Network.LoadingFinishedEvent }>;
+
+        /**
+         * Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
+         * mocked.
+         * Deprecated, use Fetch.requestPaused instead.
+         */
+        onRequestIntercepted(listener: (event: { params: Protocol.Network.RequestInterceptedEvent }) => void): void;
+        offRequestIntercepted(listener: (event: { params: Protocol.Network.RequestInterceptedEvent }) => void): void;
+        onceRequestIntercepted(eventMatcher?: (event: { params: Protocol.Network.RequestInterceptedEvent }) => boolean): Promise<{ params: Protocol.Network.RequestInterceptedEvent }>;
+
+        /**
+         * Fired if request ended up loading from cache.
+         */
+        onRequestServedFromCache(listener: (event: { params: Protocol.Network.RequestServedFromCacheEvent }) => void): void;
+        offRequestServedFromCache(listener: (event: { params: Protocol.Network.RequestServedFromCacheEvent }) => void): void;
+        onceRequestServedFromCache(eventMatcher?: (event: { params: Protocol.Network.RequestServedFromCacheEvent }) => boolean): Promise<{ params: Protocol.Network.RequestServedFromCacheEvent }>;
+
+        /**
+         * Fired when page is about to send HTTP request.
+         */
+        onRequestWillBeSent(listener: (event: { params: Protocol.Network.RequestWillBeSentEvent }) => void): void;
+        offRequestWillBeSent(listener: (event: { params: Protocol.Network.RequestWillBeSentEvent }) => void): void;
+        onceRequestWillBeSent(eventMatcher?: (event: { params: Protocol.Network.RequestWillBeSentEvent }) => boolean): Promise<{ params: Protocol.Network.RequestWillBeSentEvent }>;
+
+        /**
+         * Fired when resource loading priority is changed
+         */
+        onResourceChangedPriority(listener: (event: { params: Protocol.Network.ResourceChangedPriorityEvent }) => void): void;
+        offResourceChangedPriority(listener: (event: { params: Protocol.Network.ResourceChangedPriorityEvent }) => void): void;
+        onceResourceChangedPriority(eventMatcher?: (event: { params: Protocol.Network.ResourceChangedPriorityEvent }) => boolean): Promise<{ params: Protocol.Network.ResourceChangedPriorityEvent }>;
+
+        /**
+         * Fired when a signed exchange was received over the network
+         */
+        onSignedExchangeReceived(listener: (event: { params: Protocol.Network.SignedExchangeReceivedEvent }) => void): void;
+        offSignedExchangeReceived(listener: (event: { params: Protocol.Network.SignedExchangeReceivedEvent }) => void): void;
+        onceSignedExchangeReceived(eventMatcher?: (event: { params: Protocol.Network.SignedExchangeReceivedEvent }) => boolean): Promise<{ params: Protocol.Network.SignedExchangeReceivedEvent }>;
+
+        /**
+         * Fired when HTTP response is available.
+         */
+        onResponseReceived(listener: (event: { params: Protocol.Network.ResponseReceivedEvent }) => void): void;
+        offResponseReceived(listener: (event: { params: Protocol.Network.ResponseReceivedEvent }) => void): void;
+        onceResponseReceived(eventMatcher?: (event: { params: Protocol.Network.ResponseReceivedEvent }) => boolean): Promise<{ params: Protocol.Network.ResponseReceivedEvent }>;
+
+        /**
+         * Fired when WebSocket is closed.
+         */
+        onWebSocketClosed(listener: (event: { params: Protocol.Network.WebSocketClosedEvent }) => void): void;
+        offWebSocketClosed(listener: (event: { params: Protocol.Network.WebSocketClosedEvent }) => void): void;
+        onceWebSocketClosed(eventMatcher?: (event: { params: Protocol.Network.WebSocketClosedEvent }) => boolean): Promise<{ params: Protocol.Network.WebSocketClosedEvent }>;
+
+        /**
+         * Fired upon WebSocket creation.
+         */
+        onWebSocketCreated(listener: (event: { params: Protocol.Network.WebSocketCreatedEvent }) => void): void;
+        offWebSocketCreated(listener: (event: { params: Protocol.Network.WebSocketCreatedEvent }) => void): void;
+        onceWebSocketCreated(eventMatcher?: (event: { params: Protocol.Network.WebSocketCreatedEvent }) => boolean): Promise<{ params: Protocol.Network.WebSocketCreatedEvent }>;
+
+        /**
+         * Fired when WebSocket message error occurs.
+         */
+        onWebSocketFrameError(listener: (event: { params: Protocol.Network.WebSocketFrameErrorEvent }) => void): void;
+        offWebSocketFrameError(listener: (event: { params: Protocol.Network.WebSocketFrameErrorEvent }) => void): void;
+        onceWebSocketFrameError(eventMatcher?: (event: { params: Protocol.Network.WebSocketFrameErrorEvent }) => boolean): Promise<{ params: Protocol.Network.WebSocketFrameErrorEvent }>;
+
+        /**
+         * Fired when WebSocket message is received.
+         */
+        onWebSocketFrameReceived(listener: (event: { params: Protocol.Network.WebSocketFrameReceivedEvent }) => void): void;
+        offWebSocketFrameReceived(listener: (event: { params: Protocol.Network.WebSocketFrameReceivedEvent }) => void): void;
+        onceWebSocketFrameReceived(eventMatcher?: (event: { params: Protocol.Network.WebSocketFrameReceivedEvent }) => boolean): Promise<{ params: Protocol.Network.WebSocketFrameReceivedEvent }>;
+
+        /**
+         * Fired when WebSocket message is sent.
+         */
+        onWebSocketFrameSent(listener: (event: { params: Protocol.Network.WebSocketFrameSentEvent }) => void): void;
+        offWebSocketFrameSent(listener: (event: { params: Protocol.Network.WebSocketFrameSentEvent }) => void): void;
+        onceWebSocketFrameSent(eventMatcher?: (event: { params: Protocol.Network.WebSocketFrameSentEvent }) => boolean): Promise<{ params: Protocol.Network.WebSocketFrameSentEvent }>;
+
+        /**
+         * Fired when WebSocket handshake response becomes available.
+         */
+        onWebSocketHandshakeResponseReceived(listener: (event: { params: Protocol.Network.WebSocketHandshakeResponseReceivedEvent }) => void): void;
+        offWebSocketHandshakeResponseReceived(listener: (event: { params: Protocol.Network.WebSocketHandshakeResponseReceivedEvent }) => void): void;
+        onceWebSocketHandshakeResponseReceived(eventMatcher?: (event: { params: Protocol.Network.WebSocketHandshakeResponseReceivedEvent }) => boolean): Promise<{ params: Protocol.Network.WebSocketHandshakeResponseReceivedEvent }>;
+
+        /**
+         * Fired when WebSocket is about to initiate handshake.
+         */
+        onWebSocketWillSendHandshakeRequest(listener: (event: { params: Protocol.Network.WebSocketWillSendHandshakeRequestEvent }) => void): void;
+        offWebSocketWillSendHandshakeRequest(listener: (event: { params: Protocol.Network.WebSocketWillSendHandshakeRequestEvent }) => void): void;
+        onceWebSocketWillSendHandshakeRequest(eventMatcher?: (event: { params: Protocol.Network.WebSocketWillSendHandshakeRequestEvent }) => boolean): Promise<{ params: Protocol.Network.WebSocketWillSendHandshakeRequestEvent }>;
+
+        /**
+         * Fired upon WebTransport creation.
+         */
+        onWebTransportCreated(listener: (event: { params: Protocol.Network.WebTransportCreatedEvent }) => void): void;
+        offWebTransportCreated(listener: (event: { params: Protocol.Network.WebTransportCreatedEvent }) => void): void;
+        onceWebTransportCreated(eventMatcher?: (event: { params: Protocol.Network.WebTransportCreatedEvent }) => boolean): Promise<{ params: Protocol.Network.WebTransportCreatedEvent }>;
+
+        /**
+         * Fired when WebTransport handshake is finished.
+         */
+        onWebTransportConnectionEstablished(listener: (event: { params: Protocol.Network.WebTransportConnectionEstablishedEvent }) => void): void;
+        offWebTransportConnectionEstablished(listener: (event: { params: Protocol.Network.WebTransportConnectionEstablishedEvent }) => void): void;
+        onceWebTransportConnectionEstablished(eventMatcher?: (event: { params: Protocol.Network.WebTransportConnectionEstablishedEvent }) => boolean): Promise<{ params: Protocol.Network.WebTransportConnectionEstablishedEvent }>;
+
+        /**
+         * Fired when WebTransport is disposed.
+         */
+        onWebTransportClosed(listener: (event: { params: Protocol.Network.WebTransportClosedEvent }) => void): void;
+        offWebTransportClosed(listener: (event: { params: Protocol.Network.WebTransportClosedEvent }) => void): void;
+        onceWebTransportClosed(eventMatcher?: (event: { params: Protocol.Network.WebTransportClosedEvent }) => boolean): Promise<{ params: Protocol.Network.WebTransportClosedEvent }>;
+
+        /**
+         * Fired when additional information about a requestWillBeSent event is available from the
+         * network stack. Not every requestWillBeSent event will have an additional
+         * requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
+         * or requestWillBeSentExtraInfo will be fired first for the same request.
+         */
+        onRequestWillBeSentExtraInfo(listener: (event: { params: Protocol.Network.RequestWillBeSentExtraInfoEvent }) => void): void;
+        offRequestWillBeSentExtraInfo(listener: (event: { params: Protocol.Network.RequestWillBeSentExtraInfoEvent }) => void): void;
+        onceRequestWillBeSentExtraInfo(eventMatcher?: (event: { params: Protocol.Network.RequestWillBeSentExtraInfoEvent }) => boolean): Promise<{ params: Protocol.Network.RequestWillBeSentExtraInfoEvent }>;
+
+        /**
+         * Fired when additional information about a responseReceived event is available from the network
+         * stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
+         * it, and responseReceivedExtraInfo may be fired before or after responseReceived.
+         */
+        onResponseReceivedExtraInfo(listener: (event: { params: Protocol.Network.ResponseReceivedExtraInfoEvent }) => void): void;
+        offResponseReceivedExtraInfo(listener: (event: { params: Protocol.Network.ResponseReceivedExtraInfoEvent }) => void): void;
+        onceResponseReceivedExtraInfo(eventMatcher?: (event: { params: Protocol.Network.ResponseReceivedExtraInfoEvent }) => boolean): Promise<{ params: Protocol.Network.ResponseReceivedExtraInfoEvent }>;
+
+        /**
+         * Fired when 103 Early Hints headers is received in addition to the common response.
+         * Not every responseReceived event will have an responseReceivedEarlyHints fired.
+         * Only one responseReceivedEarlyHints may be fired for eached responseReceived event.
+         */
+        onResponseReceivedEarlyHints(listener: (event: { params: Protocol.Network.ResponseReceivedEarlyHintsEvent }) => void): void;
+        offResponseReceivedEarlyHints(listener: (event: { params: Protocol.Network.ResponseReceivedEarlyHintsEvent }) => void): void;
+        onceResponseReceivedEarlyHints(eventMatcher?: (event: { params: Protocol.Network.ResponseReceivedEarlyHintsEvent }) => boolean): Promise<{ params: Protocol.Network.ResponseReceivedEarlyHintsEvent }>;
+
+        /**
+         * Fired exactly once for each Trust Token operation. Depending on
+         * the type of the operation and whether the operation succeeded or
+         * failed, the event is fired before the corresponding request was sent
+         * or after the response was received.
+         */
+        onTrustTokenOperationDone(listener: (event: { params: Protocol.Network.TrustTokenOperationDoneEvent }) => void): void;
+        offTrustTokenOperationDone(listener: (event: { params: Protocol.Network.TrustTokenOperationDoneEvent }) => void): void;
+        onceTrustTokenOperationDone(eventMatcher?: (event: { params: Protocol.Network.TrustTokenOperationDoneEvent }) => boolean): Promise<{ params: Protocol.Network.TrustTokenOperationDoneEvent }>;
+
+        /**
+         * Fired once security policy has been updated.
+         */
+        onPolicyUpdated(listener: (event: ) => void): void;
+        offPolicyUpdated(listener: (event: ) => void): void;
+        oncePolicyUpdated(eventMatcher?: (event: ) => boolean): Promise<>;
+
+        /**
+         * Fired once when parsing the .wbn file has succeeded.
+         * The event contains the information about the web bundle contents.
+         */
+        onSubresourceWebBundleMetadataReceived(listener: (event: { params: Protocol.Network.SubresourceWebBundleMetadataReceivedEvent }) => void): void;
+        offSubresourceWebBundleMetadataReceived(listener: (event: { params: Protocol.Network.SubresourceWebBundleMetadataReceivedEvent }) => void): void;
+        onceSubresourceWebBundleMetadataReceived(eventMatcher?: (event: { params: Protocol.Network.SubresourceWebBundleMetadataReceivedEvent }) => boolean): Promise<{ params: Protocol.Network.SubresourceWebBundleMetadataReceivedEvent }>;
+
+        /**
+         * Fired once when parsing the .wbn file has failed.
+         */
+        onSubresourceWebBundleMetadataError(listener: (event: { params: Protocol.Network.SubresourceWebBundleMetadataErrorEvent }) => void): void;
+        offSubresourceWebBundleMetadataError(listener: (event: { params: Protocol.Network.SubresourceWebBundleMetadataErrorEvent }) => void): void;
+        onceSubresourceWebBundleMetadataError(eventMatcher?: (event: { params: Protocol.Network.SubresourceWebBundleMetadataErrorEvent }) => boolean): Promise<{ params: Protocol.Network.SubresourceWebBundleMetadataErrorEvent }>;
+
+        /**
+         * Fired when handling requests for resources within a .wbn file.
+         * Note: this will only be fired for resources that are requested by the webpage.
+         */
+        onSubresourceWebBundleInnerResponseParsed(listener: (event: { params: Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent }) => void): void;
+        offSubresourceWebBundleInnerResponseParsed(listener: (event: { params: Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent }) => void): void;
+        onceSubresourceWebBundleInnerResponseParsed(eventMatcher?: (event: { params: Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent }) => boolean): Promise<{ params: Protocol.Network.SubresourceWebBundleInnerResponseParsedEvent }>;
+
+        /**
+         * Fired when request for resources within a .wbn file failed.
+         */
+        onSubresourceWebBundleInnerResponseError(listener: (event: { params: Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent }) => void): void;
+        offSubresourceWebBundleInnerResponseError(listener: (event: { params: Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent }) => void): void;
+        onceSubresourceWebBundleInnerResponseError(eventMatcher?: (event: { params: Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent }) => boolean): Promise<{ params: Protocol.Network.SubresourceWebBundleInnerResponseErrorEvent }>;
+
+        /**
+         * Is sent whenever a new report is added.
+         * And after 'enableReportingApi' for all existing reports.
+         */
+        onReportingApiReportAdded(listener: (event: { params: Protocol.Network.ReportingApiReportAddedEvent }) => void): void;
+        offReportingApiReportAdded(listener: (event: { params: Protocol.Network.ReportingApiReportAddedEvent }) => void): void;
+        onceReportingApiReportAdded(eventMatcher?: (event: { params: Protocol.Network.ReportingApiReportAddedEvent }) => boolean): Promise<{ params: Protocol.Network.ReportingApiReportAddedEvent }>;
+
+        onReportingApiReportUpdated(listener: (event: { params: Protocol.Network.ReportingApiReportUpdatedEvent }) => void): void;
+        offReportingApiReportUpdated(listener: (event: { params: Protocol.Network.ReportingApiReportUpdatedEvent }) => void): void;
+        onceReportingApiReportUpdated(eventMatcher?: (event: { params: Protocol.Network.ReportingApiReportUpdatedEvent }) => boolean): Promise<{ params: Protocol.Network.ReportingApiReportUpdatedEvent }>;
+
+        onReportingApiEndpointsChangedForOrigin(listener: (event: { params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent }) => void): void;
+        offReportingApiEndpointsChangedForOrigin(listener: (event: { params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent }) => void): void;
+        onceReportingApiEndpointsChangedForOrigin(eventMatcher?: (event: { params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent }) => boolean): Promise<{ params: Protocol.Network.ReportingApiEndpointsChangedForOriginEvent }>;
+
+    }
+
+    export interface OverlayApi {
+        /**
+         * Disables domain notifications.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables domain notifications.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * For testing.
+         */
+        getHighlightObjectForTest(params: Protocol.Overlay.GetHighlightObjectForTestRequest): Promise<{id: number, result: Protocol.Overlay.GetHighlightObjectForTestResponse, sessionId: string}>;
+
+        /**
+         * For Persistent Grid testing.
+         */
+        getGridHighlightObjectsForTest(params: Protocol.Overlay.GetGridHighlightObjectsForTestRequest): Promise<{id: number, result: Protocol.Overlay.GetGridHighlightObjectsForTestResponse, sessionId: string}>;
+
+        /**
+         * For Source Order Viewer testing.
+         */
+        getSourceOrderHighlightObjectForTest(params: Protocol.Overlay.GetSourceOrderHighlightObjectForTestRequest): Promise<{id: number, result: Protocol.Overlay.GetSourceOrderHighlightObjectForTestResponse, sessionId: string}>;
+
+        /**
+         * Hides any highlight.
+         */
+        hideHighlight(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Highlights owner element of the frame with given id.
+         * Deprecated: Doesn't work reliably and cannot be fixed due to process
+         * separation (the owner node might be in a different process). Determine
+         * the owner node in the client and use highlightNode.
+         */
+        highlightFrame(params: Protocol.Overlay.HighlightFrameRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
+         * objectId must be specified.
+         */
+        highlightNode(params: Protocol.Overlay.HighlightNodeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
+         */
+        highlightQuad(params: Protocol.Overlay.HighlightQuadRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
+         */
+        highlightRect(params: Protocol.Overlay.HighlightRectRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Highlights the source order of the children of the DOM node with given id or with the given
+         * JavaScript object wrapper. Either nodeId or objectId must be specified.
+         */
+        highlightSourceOrder(params: Protocol.Overlay.HighlightSourceOrderRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
+         * Backend then generates 'inspectNodeRequested' event upon element selection.
+         */
+        setInspectMode(params: Protocol.Overlay.SetInspectModeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Highlights owner element of all frames detected to be ads.
+         */
+        setShowAdHighlights(params: Protocol.Overlay.SetShowAdHighlightsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setPausedInDebuggerMessage(params: Protocol.Overlay.SetPausedInDebuggerMessageRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests that backend shows debug borders on layers
+         */
+        setShowDebugBorders(params: Protocol.Overlay.SetShowDebugBordersRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests that backend shows the FPS counter
+         */
+        setShowFPSCounter(params: Protocol.Overlay.SetShowFPSCounterRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Highlight multiple elements with the CSS Grid overlay.
+         */
+        setShowGridOverlays(params: Protocol.Overlay.SetShowGridOverlaysRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setShowFlexOverlays(params: Protocol.Overlay.SetShowFlexOverlaysRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setShowScrollSnapOverlays(params: Protocol.Overlay.SetShowScrollSnapOverlaysRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setShowContainerQueryOverlays(params: Protocol.Overlay.SetShowContainerQueryOverlaysRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests that backend shows paint rectangles
+         */
+        setShowPaintRects(params: Protocol.Overlay.SetShowPaintRectsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests that backend shows layout shift regions
+         */
+        setShowLayoutShiftRegions(params: Protocol.Overlay.SetShowLayoutShiftRegionsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests that backend shows scroll bottleneck rects
+         */
+        setShowScrollBottleneckRects(params: Protocol.Overlay.SetShowScrollBottleneckRectsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Deprecated, no longer has any effect.
+         */
+        setShowHitTestBorders(params: Protocol.Overlay.SetShowHitTestBordersRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Request that backend shows an overlay with web vital metrics.
+         */
+        setShowWebVitals(params: Protocol.Overlay.SetShowWebVitalsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Paints viewport size upon main frame resize.
+         */
+        setShowViewportSizeOnResize(params: Protocol.Overlay.SetShowViewportSizeOnResizeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Add a dual screen device hinge
+         */
+        setShowHinge(params: Protocol.Overlay.SetShowHingeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Show elements in isolation mode with overlays.
+         */
+        setShowIsolatedElements(params: Protocol.Overlay.SetShowIsolatedElementsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Show Window Controls Overlay for PWA
+         */
+        setShowWindowControlsOverlay(params: Protocol.Overlay.SetShowWindowControlsOverlayRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Fired when the node should be inspected. This happens after call to `setInspectMode` or when
+         * user manually inspects an element.
+         */
+        onInspectNodeRequested(listener: (event: { params: Protocol.Overlay.InspectNodeRequestedEvent }) => void): void;
+        offInspectNodeRequested(listener: (event: { params: Protocol.Overlay.InspectNodeRequestedEvent }) => void): void;
+        onceInspectNodeRequested(eventMatcher?: (event: { params: Protocol.Overlay.InspectNodeRequestedEvent }) => boolean): Promise<{ params: Protocol.Overlay.InspectNodeRequestedEvent }>;
+
+        /**
+         * Fired when the node should be highlighted. This happens after call to `setInspectMode`.
+         */
+        onNodeHighlightRequested(listener: (event: { params: Protocol.Overlay.NodeHighlightRequestedEvent }) => void): void;
+        offNodeHighlightRequested(listener: (event: { params: Protocol.Overlay.NodeHighlightRequestedEvent }) => void): void;
+        onceNodeHighlightRequested(eventMatcher?: (event: { params: Protocol.Overlay.NodeHighlightRequestedEvent }) => boolean): Promise<{ params: Protocol.Overlay.NodeHighlightRequestedEvent }>;
+
+        /**
+         * Fired when user asks to capture screenshot of some area on the page.
+         */
+        onScreenshotRequested(listener: (event: { params: Protocol.Overlay.ScreenshotRequestedEvent }) => void): void;
+        offScreenshotRequested(listener: (event: { params: Protocol.Overlay.ScreenshotRequestedEvent }) => void): void;
+        onceScreenshotRequested(eventMatcher?: (event: { params: Protocol.Overlay.ScreenshotRequestedEvent }) => boolean): Promise<{ params: Protocol.Overlay.ScreenshotRequestedEvent }>;
+
+        /**
+         * Fired when user cancels the inspect mode.
+         */
+        onInspectModeCanceled(listener: (event: ) => void): void;
+        offInspectModeCanceled(listener: (event: ) => void): void;
+        onceInspectModeCanceled(eventMatcher?: (event: ) => boolean): Promise<>;
+
+    }
+
+    export interface PageApi {
+        /**
+         * Deprecated, please use addScriptToEvaluateOnNewDocument instead.
+         */
+        addScriptToEvaluateOnLoad(params: Protocol.Page.AddScriptToEvaluateOnLoadRequest): Promise<{id: number, result: Protocol.Page.AddScriptToEvaluateOnLoadResponse, sessionId: string}>;
+
+        /**
+         * Evaluates given script in every frame upon creation (before loading frame's scripts).
+         */
+        addScriptToEvaluateOnNewDocument(params: Protocol.Page.AddScriptToEvaluateOnNewDocumentRequest): Promise<{id: number, result: Protocol.Page.AddScriptToEvaluateOnNewDocumentResponse, sessionId: string}>;
+
+        /**
+         * Brings page to front (activates tab).
+         */
+        bringToFront(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Capture page screenshot.
+         */
+        captureScreenshot(params: Protocol.Page.CaptureScreenshotRequest): Promise<{id: number, result: Protocol.Page.CaptureScreenshotResponse, sessionId: string}>;
+
+        /**
+         * Returns a snapshot of the page as a string. For MHTML format, the serialization includes
+         * iframes, shadow DOM, external resources, and element-inline styles.
+         */
+        captureSnapshot(params: Protocol.Page.CaptureSnapshotRequest): Promise<{id: number, result: Protocol.Page.CaptureSnapshotResponse, sessionId: string}>;
+
+        /**
+         * Clears the overridden device metrics.
+         */
+        clearDeviceMetricsOverride(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears the overridden Device Orientation.
+         */
+        clearDeviceOrientationOverride(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears the overridden Geolocation Position and Error.
+         */
+        clearGeolocationOverride(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Creates an isolated world for the given frame.
+         */
+        createIsolatedWorld(params: Protocol.Page.CreateIsolatedWorldRequest): Promise<{id: number, result: Protocol.Page.CreateIsolatedWorldResponse, sessionId: string}>;
+
+        /**
+         * Deletes browser cookie with given name, domain and path.
+         */
+        deleteCookie(params: Protocol.Page.DeleteCookieRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables page domain notifications.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables page domain notifications.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Gets the processed manifest for this current document.
+         *   This API always waits for the manifest to be loaded.
+         *   If manifestId is provided, and it does not match the manifest of the
+         *     current document, this API errors out.
+         *   If there is not a loaded page, this API errors out immediately.
+         */
+        getAppManifest(params: Protocol.Page.GetAppManifestRequest): Promise<{id: number, result: Protocol.Page.GetAppManifestResponse, sessionId: string}>;
+
+        getInstallabilityErrors(): Promise<{id: number, result: Protocol.Page.GetInstallabilityErrorsResponse, sessionId: string}>;
+
+        /**
+         * Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.
+         */
+        getManifestIcons(): Promise<{id: number, result: Protocol.Page.GetManifestIconsResponse, sessionId: string}>;
+
+        /**
+         * Returns the unique (PWA) app id.
+         * Only returns values if the feature flag 'WebAppEnableManifestId' is enabled
+         */
+        getAppId(): Promise<{id: number, result: Protocol.Page.GetAppIdResponse, sessionId: string}>;
+
+        getAdScriptId(params: Protocol.Page.GetAdScriptIdRequest): Promise<{id: number, result: Protocol.Page.GetAdScriptIdResponse, sessionId: string}>;
+
+        /**
+         * Returns present frame tree structure.
+         */
+        getFrameTree(): Promise<{id: number, result: Protocol.Page.GetFrameTreeResponse, sessionId: string}>;
+
+        /**
+         * Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
+         */
+        getLayoutMetrics(): Promise<{id: number, result: Protocol.Page.GetLayoutMetricsResponse, sessionId: string}>;
+
+        /**
+         * Returns navigation history for the current page.
+         */
+        getNavigationHistory(): Promise<{id: number, result: Protocol.Page.GetNavigationHistoryResponse, sessionId: string}>;
+
+        /**
+         * Resets navigation history for the current page.
+         */
+        resetNavigationHistory(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns content of the given resource.
+         */
+        getResourceContent(params: Protocol.Page.GetResourceContentRequest): Promise<{id: number, result: Protocol.Page.GetResourceContentResponse, sessionId: string}>;
+
+        /**
+         * Returns present frame / resource tree structure.
+         */
+        getResourceTree(): Promise<{id: number, result: Protocol.Page.GetResourceTreeResponse, sessionId: string}>;
+
+        /**
+         * Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
+         */
+        handleJavaScriptDialog(params: Protocol.Page.HandleJavaScriptDialogRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Navigates current page to the given URL.
+         */
+        navigate(params: Protocol.Page.NavigateRequest): Promise<{id: number, result: Protocol.Page.NavigateResponse, sessionId: string}>;
+
+        /**
+         * Navigates current page to the given history entry.
+         */
+        navigateToHistoryEntry(params: Protocol.Page.NavigateToHistoryEntryRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Print page as PDF.
+         */
+        printToPDF(params: Protocol.Page.PrintToPDFRequest): Promise<{id: number, result: Protocol.Page.PrintToPDFResponse, sessionId: string}>;
+
+        /**
+         * Reloads given page optionally ignoring the cache.
+         */
+        reload(params: Protocol.Page.ReloadRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Deprecated, please use removeScriptToEvaluateOnNewDocument instead.
+         */
+        removeScriptToEvaluateOnLoad(params: Protocol.Page.RemoveScriptToEvaluateOnLoadRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Removes given script from the list.
+         */
+        removeScriptToEvaluateOnNewDocument(params: Protocol.Page.RemoveScriptToEvaluateOnNewDocumentRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Acknowledges that a screencast frame has been received by the frontend.
+         */
+        screencastFrameAck(params: Protocol.Page.ScreencastFrameAckRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Searches for given string in resource content.
+         */
+        searchInResource(params: Protocol.Page.SearchInResourceRequest): Promise<{id: number, result: Protocol.Page.SearchInResourceResponse, sessionId: string}>;
+
+        /**
+         * Enable Chrome's experimental ad filter on all sites.
+         */
+        setAdBlockingEnabled(params: Protocol.Page.SetAdBlockingEnabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enable page Content Security Policy by-passing.
+         */
+        setBypassCSP(params: Protocol.Page.SetBypassCSPRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Get Permissions Policy state on given frame.
+         */
+        getPermissionsPolicyState(params: Protocol.Page.GetPermissionsPolicyStateRequest): Promise<{id: number, result: Protocol.Page.GetPermissionsPolicyStateResponse, sessionId: string}>;
+
+        /**
+         * Get Origin Trials on given frame.
+         */
+        getOriginTrials(params: Protocol.Page.GetOriginTrialsRequest): Promise<{id: number, result: Protocol.Page.GetOriginTrialsResponse, sessionId: string}>;
+
+        /**
+         * Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
+         * window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
+         * query results).
+         */
+        setDeviceMetricsOverride(params: Protocol.Page.SetDeviceMetricsOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Overrides the Device Orientation.
+         */
+        setDeviceOrientationOverride(params: Protocol.Page.SetDeviceOrientationOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Set generic font families.
+         */
+        setFontFamilies(params: Protocol.Page.SetFontFamiliesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Set default font sizes.
+         */
+        setFontSizes(params: Protocol.Page.SetFontSizesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets given markup as the document's HTML.
+         */
+        setDocumentContent(params: Protocol.Page.SetDocumentContentRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Set the behavior when downloading a file.
+         */
+        setDownloadBehavior(params: Protocol.Page.SetDownloadBehaviorRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
+         * unavailable.
+         */
+        setGeolocationOverride(params: Protocol.Page.SetGeolocationOverrideRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Controls whether page will emit lifecycle events.
+         */
+        setLifecycleEventsEnabled(params: Protocol.Page.SetLifecycleEventsEnabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Toggles mouse event-based touch event emulation.
+         */
+        setTouchEmulationEnabled(params: Protocol.Page.SetTouchEmulationEnabledRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Starts sending each frame using the `screencastFrame` event.
+         */
+        startScreencast(params: Protocol.Page.StartScreencastRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Force the page stop all navigations and pending resource fetches.
+         */
+        stopLoading(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Crashes renderer on the IO thread, generates minidumps.
+         */
+        crash(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Tries to close page, running its beforeunload hooks, if any.
+         */
+        close(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Tries to update the web lifecycle state of the page.
+         * It will transition the page to the given state according to:
+         * https://github.com/WICG/web-lifecycle/
+         */
+        setWebLifecycleState(params: Protocol.Page.SetWebLifecycleStateRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Stops sending each frame in the `screencastFrame`.
+         */
+        stopScreencast(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Requests backend to produce compilation cache for the specified scripts.
+         * `scripts` are appended to the list of scripts for which the cache
+         * would be produced. The list may be reset during page navigation.
+         * When script with a matching URL is encountered, the cache is optionally
+         * produced upon backend discretion, based on internal heuristics.
+         * See also: `Page.compilationCacheProduced`.
+         */
+        produceCompilationCache(params: Protocol.Page.ProduceCompilationCacheRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Seeds compilation cache for given url. Compilation cache does not survive
+         * cross-process navigation.
+         */
+        addCompilationCache(params: Protocol.Page.AddCompilationCacheRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears seeded compilation cache.
+         */
+        clearCompilationCache(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets the Secure Payment Confirmation transaction mode.
+         * https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
+         */
+        setSPCTransactionMode(params: Protocol.Page.SetSPCTransactionModeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Extensions for Custom Handlers API:
+         * https://html.spec.whatwg.org/multipage/system-state.html#rph-automation
+         */
+        setRPHRegistrationMode(params: Protocol.Page.SetRPHRegistrationModeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Generates a report for testing.
+         */
+        generateTestReport(params: Protocol.Page.GenerateTestReportRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
+         */
+        waitForDebugger(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Intercept file chooser requests and transfer control to protocol clients.
+         * When file chooser interception is enabled, native file chooser dialog is not shown.
+         * Instead, a protocol event `Page.fileChooserOpened` is emitted.
+         */
+        setInterceptFileChooserDialog(params: Protocol.Page.SetInterceptFileChooserDialogRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enable/disable prerendering manually.
+         * 
+         * This command is a short-term solution for https://crbug.com/1440085.
+         * See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
+         * for more details.
+         * 
+         * TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.
+         */
+        setPrerenderingAllowed(params: Protocol.Page.SetPrerenderingAllowedRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        onDomContentEventFired(listener: (event: { params: Protocol.Page.DomContentEventFiredEvent }) => void): void;
+        offDomContentEventFired(listener: (event: { params: Protocol.Page.DomContentEventFiredEvent }) => void): void;
+        onceDomContentEventFired(eventMatcher?: (event: { params: Protocol.Page.DomContentEventFiredEvent }) => boolean): Promise<{ params: Protocol.Page.DomContentEventFiredEvent }>;
+
+        /**
+         * Emitted only when `page.interceptFileChooser` is enabled.
+         */
+        onFileChooserOpened(listener: (event: { params: Protocol.Page.FileChooserOpenedEvent }) => void): void;
+        offFileChooserOpened(listener: (event: { params: Protocol.Page.FileChooserOpenedEvent }) => void): void;
+        onceFileChooserOpened(eventMatcher?: (event: { params: Protocol.Page.FileChooserOpenedEvent }) => boolean): Promise<{ params: Protocol.Page.FileChooserOpenedEvent }>;
+
+        /**
+         * Fired when frame has been attached to its parent.
+         */
+        onFrameAttached(listener: (event: { params: Protocol.Page.FrameAttachedEvent }) => void): void;
+        offFrameAttached(listener: (event: { params: Protocol.Page.FrameAttachedEvent }) => void): void;
+        onceFrameAttached(eventMatcher?: (event: { params: Protocol.Page.FrameAttachedEvent }) => boolean): Promise<{ params: Protocol.Page.FrameAttachedEvent }>;
+
+        /**
+         * Fired when frame no longer has a scheduled navigation.
+         */
+        onFrameClearedScheduledNavigation(listener: (event: { params: Protocol.Page.FrameClearedScheduledNavigationEvent }) => void): void;
+        offFrameClearedScheduledNavigation(listener: (event: { params: Protocol.Page.FrameClearedScheduledNavigationEvent }) => void): void;
+        onceFrameClearedScheduledNavigation(eventMatcher?: (event: { params: Protocol.Page.FrameClearedScheduledNavigationEvent }) => boolean): Promise<{ params: Protocol.Page.FrameClearedScheduledNavigationEvent }>;
+
+        /**
+         * Fired when frame has been detached from its parent.
+         */
+        onFrameDetached(listener: (event: { params: Protocol.Page.FrameDetachedEvent }) => void): void;
+        offFrameDetached(listener: (event: { params: Protocol.Page.FrameDetachedEvent }) => void): void;
+        onceFrameDetached(eventMatcher?: (event: { params: Protocol.Page.FrameDetachedEvent }) => boolean): Promise<{ params: Protocol.Page.FrameDetachedEvent }>;
+
+        /**
+         * Fired once navigation of the frame has completed. Frame is now associated with the new loader.
+         */
+        onFrameNavigated(listener: (event: { params: Protocol.Page.FrameNavigatedEvent }) => void): void;
+        offFrameNavigated(listener: (event: { params: Protocol.Page.FrameNavigatedEvent }) => void): void;
+        onceFrameNavigated(eventMatcher?: (event: { params: Protocol.Page.FrameNavigatedEvent }) => boolean): Promise<{ params: Protocol.Page.FrameNavigatedEvent }>;
+
+        /**
+         * Fired when opening document to write to.
+         */
+        onDocumentOpened(listener: (event: { params: Protocol.Page.DocumentOpenedEvent }) => void): void;
+        offDocumentOpened(listener: (event: { params: Protocol.Page.DocumentOpenedEvent }) => void): void;
+        onceDocumentOpened(eventMatcher?: (event: { params: Protocol.Page.DocumentOpenedEvent }) => boolean): Promise<{ params: Protocol.Page.DocumentOpenedEvent }>;
+
+        onFrameResized(listener: (event: ) => void): void;
+        offFrameResized(listener: (event: ) => void): void;
+        onceFrameResized(eventMatcher?: (event: ) => boolean): Promise<>;
+
+        /**
+         * Fired when a renderer-initiated navigation is requested.
+         * Navigation may still be cancelled after the event is issued.
+         */
+        onFrameRequestedNavigation(listener: (event: { params: Protocol.Page.FrameRequestedNavigationEvent }) => void): void;
+        offFrameRequestedNavigation(listener: (event: { params: Protocol.Page.FrameRequestedNavigationEvent }) => void): void;
+        onceFrameRequestedNavigation(eventMatcher?: (event: { params: Protocol.Page.FrameRequestedNavigationEvent }) => boolean): Promise<{ params: Protocol.Page.FrameRequestedNavigationEvent }>;
+
+        /**
+         * Fired when frame schedules a potential navigation.
+         */
+        onFrameScheduledNavigation(listener: (event: { params: Protocol.Page.FrameScheduledNavigationEvent }) => void): void;
+        offFrameScheduledNavigation(listener: (event: { params: Protocol.Page.FrameScheduledNavigationEvent }) => void): void;
+        onceFrameScheduledNavigation(eventMatcher?: (event: { params: Protocol.Page.FrameScheduledNavigationEvent }) => boolean): Promise<{ params: Protocol.Page.FrameScheduledNavigationEvent }>;
+
+        /**
+         * Fired when frame has started loading.
+         */
+        onFrameStartedLoading(listener: (event: { params: Protocol.Page.FrameStartedLoadingEvent }) => void): void;
+        offFrameStartedLoading(listener: (event: { params: Protocol.Page.FrameStartedLoadingEvent }) => void): void;
+        onceFrameStartedLoading(eventMatcher?: (event: { params: Protocol.Page.FrameStartedLoadingEvent }) => boolean): Promise<{ params: Protocol.Page.FrameStartedLoadingEvent }>;
+
+        /**
+         * Fired when frame has stopped loading.
+         */
+        onFrameStoppedLoading(listener: (event: { params: Protocol.Page.FrameStoppedLoadingEvent }) => void): void;
+        offFrameStoppedLoading(listener: (event: { params: Protocol.Page.FrameStoppedLoadingEvent }) => void): void;
+        onceFrameStoppedLoading(eventMatcher?: (event: { params: Protocol.Page.FrameStoppedLoadingEvent }) => boolean): Promise<{ params: Protocol.Page.FrameStoppedLoadingEvent }>;
+
+        /**
+         * Fired when page is about to start a download.
+         * Deprecated. Use Browser.downloadWillBegin instead.
+         */
+        onDownloadWillBegin(listener: (event: { params: Protocol.Page.DownloadWillBeginEvent }) => void): void;
+        offDownloadWillBegin(listener: (event: { params: Protocol.Page.DownloadWillBeginEvent }) => void): void;
+        onceDownloadWillBegin(eventMatcher?: (event: { params: Protocol.Page.DownloadWillBeginEvent }) => boolean): Promise<{ params: Protocol.Page.DownloadWillBeginEvent }>;
+
+        /**
+         * Fired when download makes progress. Last call has |done| == true.
+         * Deprecated. Use Browser.downloadProgress instead.
+         */
+        onDownloadProgress(listener: (event: { params: Protocol.Page.DownloadProgressEvent }) => void): void;
+        offDownloadProgress(listener: (event: { params: Protocol.Page.DownloadProgressEvent }) => void): void;
+        onceDownloadProgress(eventMatcher?: (event: { params: Protocol.Page.DownloadProgressEvent }) => boolean): Promise<{ params: Protocol.Page.DownloadProgressEvent }>;
+
+        /**
+         * Fired when interstitial page was hidden
+         */
+        onInterstitialHidden(listener: (event: ) => void): void;
+        offInterstitialHidden(listener: (event: ) => void): void;
+        onceInterstitialHidden(eventMatcher?: (event: ) => boolean): Promise<>;
+
+        /**
+         * Fired when interstitial page was shown
+         */
+        onInterstitialShown(listener: (event: ) => void): void;
+        offInterstitialShown(listener: (event: ) => void): void;
+        onceInterstitialShown(eventMatcher?: (event: ) => boolean): Promise<>;
+
+        /**
+         * Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
+         * closed.
+         */
+        onJavascriptDialogClosed(listener: (event: { params: Protocol.Page.JavascriptDialogClosedEvent }) => void): void;
+        offJavascriptDialogClosed(listener: (event: { params: Protocol.Page.JavascriptDialogClosedEvent }) => void): void;
+        onceJavascriptDialogClosed(eventMatcher?: (event: { params: Protocol.Page.JavascriptDialogClosedEvent }) => boolean): Promise<{ params: Protocol.Page.JavascriptDialogClosedEvent }>;
+
+        /**
+         * Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
+         * open.
+         */
+        onJavascriptDialogOpening(listener: (event: { params: Protocol.Page.JavascriptDialogOpeningEvent }) => void): void;
+        offJavascriptDialogOpening(listener: (event: { params: Protocol.Page.JavascriptDialogOpeningEvent }) => void): void;
+        onceJavascriptDialogOpening(eventMatcher?: (event: { params: Protocol.Page.JavascriptDialogOpeningEvent }) => boolean): Promise<{ params: Protocol.Page.JavascriptDialogOpeningEvent }>;
+
+        /**
+         * Fired for top level page lifecycle events such as navigation, load, paint, etc.
+         */
+        onLifecycleEvent(listener: (event: { params: Protocol.Page.LifecycleEventEvent }) => void): void;
+        offLifecycleEvent(listener: (event: { params: Protocol.Page.LifecycleEventEvent }) => void): void;
+        onceLifecycleEvent(eventMatcher?: (event: { params: Protocol.Page.LifecycleEventEvent }) => boolean): Promise<{ params: Protocol.Page.LifecycleEventEvent }>;
+
+        /**
+         * Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do
+         * not assume any ordering with the Page.frameNavigated event. This event is fired only for
+         * main-frame history navigation where the document changes (non-same-document navigations),
+         * when bfcache navigation fails.
+         */
+        onBackForwardCacheNotUsed(listener: (event: { params: Protocol.Page.BackForwardCacheNotUsedEvent }) => void): void;
+        offBackForwardCacheNotUsed(listener: (event: { params: Protocol.Page.BackForwardCacheNotUsedEvent }) => void): void;
+        onceBackForwardCacheNotUsed(eventMatcher?: (event: { params: Protocol.Page.BackForwardCacheNotUsedEvent }) => boolean): Promise<{ params: Protocol.Page.BackForwardCacheNotUsedEvent }>;
+
+        onLoadEventFired(listener: (event: { params: Protocol.Page.LoadEventFiredEvent }) => void): void;
+        offLoadEventFired(listener: (event: { params: Protocol.Page.LoadEventFiredEvent }) => void): void;
+        onceLoadEventFired(eventMatcher?: (event: { params: Protocol.Page.LoadEventFiredEvent }) => boolean): Promise<{ params: Protocol.Page.LoadEventFiredEvent }>;
+
+        /**
+         * Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
+         */
+        onNavigatedWithinDocument(listener: (event: { params: Protocol.Page.NavigatedWithinDocumentEvent }) => void): void;
+        offNavigatedWithinDocument(listener: (event: { params: Protocol.Page.NavigatedWithinDocumentEvent }) => void): void;
+        onceNavigatedWithinDocument(eventMatcher?: (event: { params: Protocol.Page.NavigatedWithinDocumentEvent }) => boolean): Promise<{ params: Protocol.Page.NavigatedWithinDocumentEvent }>;
+
+        /**
+         * Compressed image data requested by the `startScreencast`.
+         */
+        onScreencastFrame(listener: (event: { params: Protocol.Page.ScreencastFrameEvent }) => void): void;
+        offScreencastFrame(listener: (event: { params: Protocol.Page.ScreencastFrameEvent }) => void): void;
+        onceScreencastFrame(eventMatcher?: (event: { params: Protocol.Page.ScreencastFrameEvent }) => boolean): Promise<{ params: Protocol.Page.ScreencastFrameEvent }>;
+
+        /**
+         * Fired when the page with currently enabled screencast was shown or hidden `.
+         */
+        onScreencastVisibilityChanged(listener: (event: { params: Protocol.Page.ScreencastVisibilityChangedEvent }) => void): void;
+        offScreencastVisibilityChanged(listener: (event: { params: Protocol.Page.ScreencastVisibilityChangedEvent }) => void): void;
+        onceScreencastVisibilityChanged(eventMatcher?: (event: { params: Protocol.Page.ScreencastVisibilityChangedEvent }) => boolean): Promise<{ params: Protocol.Page.ScreencastVisibilityChangedEvent }>;
+
+        /**
+         * Fired when a new window is going to be opened, via window.open(), link click, form submission,
+         * etc.
+         */
+        onWindowOpen(listener: (event: { params: Protocol.Page.WindowOpenEvent }) => void): void;
+        offWindowOpen(listener: (event: { params: Protocol.Page.WindowOpenEvent }) => void): void;
+        onceWindowOpen(eventMatcher?: (event: { params: Protocol.Page.WindowOpenEvent }) => boolean): Promise<{ params: Protocol.Page.WindowOpenEvent }>;
+
+        /**
+         * Issued for every compilation cache generated. Is only available
+         * if Page.setGenerateCompilationCache is enabled.
+         */
+        onCompilationCacheProduced(listener: (event: { params: Protocol.Page.CompilationCacheProducedEvent }) => void): void;
+        offCompilationCacheProduced(listener: (event: { params: Protocol.Page.CompilationCacheProducedEvent }) => void): void;
+        onceCompilationCacheProduced(eventMatcher?: (event: { params: Protocol.Page.CompilationCacheProducedEvent }) => boolean): Promise<{ params: Protocol.Page.CompilationCacheProducedEvent }>;
+
+    }
+
+    export interface PerformanceApi {
+        /**
+         * Disable collecting and reporting metrics.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enable collecting and reporting metrics.
+         */
+        enable(params: Protocol.Performance.EnableRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets time domain to use for collecting and reporting duration metrics.
+         * Note that this must be called before enabling metrics collection. Calling
+         * this method while metrics collection is enabled returns an error.
+         */
+        setTimeDomain(params: Protocol.Performance.SetTimeDomainRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Retrieve current values of run-time metrics.
+         */
+        getMetrics(): Promise<{id: number, result: Protocol.Performance.GetMetricsResponse, sessionId: string}>;
+
+        /**
+         * Current values of the metrics.
+         */
+        onMetrics(listener: (event: { params: Protocol.Performance.MetricsEvent }) => void): void;
+        offMetrics(listener: (event: { params: Protocol.Performance.MetricsEvent }) => void): void;
+        onceMetrics(eventMatcher?: (event: { params: Protocol.Performance.MetricsEvent }) => boolean): Promise<{ params: Protocol.Performance.MetricsEvent }>;
+
+    }
+
+    export interface PerformanceTimelineApi {
+        /**
+         * Previously buffered events would be reported before method returns.
+         * See also: timelineEventAdded
+         */
+        enable(params: Protocol.PerformanceTimeline.EnableRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sent when a performance timeline event is added. See reportPerformanceTimeline method.
+         */
+        onTimelineEventAdded(listener: (event: { params: Protocol.PerformanceTimeline.TimelineEventAddedEvent }) => void): void;
+        offTimelineEventAdded(listener: (event: { params: Protocol.PerformanceTimeline.TimelineEventAddedEvent }) => void): void;
+        onceTimelineEventAdded(eventMatcher?: (event: { params: Protocol.PerformanceTimeline.TimelineEventAddedEvent }) => boolean): Promise<{ params: Protocol.PerformanceTimeline.TimelineEventAddedEvent }>;
+
+    }
+
+    export interface SecurityApi {
+        /**
+         * Disables tracking security state changes.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables tracking security state changes.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enable/disable whether all certificate errors should be ignored.
+         */
+        setIgnoreCertificateErrors(params: Protocol.Security.SetIgnoreCertificateErrorsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Handles a certificate error that fired a certificateError event.
+         */
+        handleCertificateError(params: Protocol.Security.HandleCertificateErrorRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enable/disable overriding certificate errors. If enabled, all certificate error events need to
+         * be handled by the DevTools client and should be answered with `handleCertificateError` commands.
+         */
+        setOverrideCertificateErrors(params: Protocol.Security.SetOverrideCertificateErrorsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * There is a certificate error. If overriding certificate errors is enabled, then it should be
+         * handled with the `handleCertificateError` command. Note: this event does not fire if the
+         * certificate error has been allowed internally. Only one client per target should override
+         * certificate errors at the same time.
+         */
+        onCertificateError(listener: (event: { params: Protocol.Security.CertificateErrorEvent }) => void): void;
+        offCertificateError(listener: (event: { params: Protocol.Security.CertificateErrorEvent }) => void): void;
+        onceCertificateError(eventMatcher?: (event: { params: Protocol.Security.CertificateErrorEvent }) => boolean): Promise<{ params: Protocol.Security.CertificateErrorEvent }>;
+
+        /**
+         * The security state of the page changed.
+         */
+        onVisibleSecurityStateChanged(listener: (event: { params: Protocol.Security.VisibleSecurityStateChangedEvent }) => void): void;
+        offVisibleSecurityStateChanged(listener: (event: { params: Protocol.Security.VisibleSecurityStateChangedEvent }) => void): void;
+        onceVisibleSecurityStateChanged(eventMatcher?: (event: { params: Protocol.Security.VisibleSecurityStateChangedEvent }) => boolean): Promise<{ params: Protocol.Security.VisibleSecurityStateChangedEvent }>;
+
+        /**
+         * The security state of the page changed. No longer being sent.
+         */
+        onSecurityStateChanged(listener: (event: { params: Protocol.Security.SecurityStateChangedEvent }) => void): void;
+        offSecurityStateChanged(listener: (event: { params: Protocol.Security.SecurityStateChangedEvent }) => void): void;
+        onceSecurityStateChanged(eventMatcher?: (event: { params: Protocol.Security.SecurityStateChangedEvent }) => boolean): Promise<{ params: Protocol.Security.SecurityStateChangedEvent }>;
+
+    }
+
+    export interface ServiceWorkerApi {
+        deliverPushMessage(params: Protocol.ServiceWorker.DeliverPushMessageRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        dispatchSyncEvent(params: Protocol.ServiceWorker.DispatchSyncEventRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        dispatchPeriodicSyncEvent(params: Protocol.ServiceWorker.DispatchPeriodicSyncEventRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        inspectWorker(params: Protocol.ServiceWorker.InspectWorkerRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        setForceUpdateOnPageLoad(params: Protocol.ServiceWorker.SetForceUpdateOnPageLoadRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        skipWaiting(params: Protocol.ServiceWorker.SkipWaitingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        startWorker(params: Protocol.ServiceWorker.StartWorkerRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        stopAllWorkers(): Promise<{id: number, result: void, sessionId: string}>;
+
+        stopWorker(params: Protocol.ServiceWorker.StopWorkerRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        unregister(params: Protocol.ServiceWorker.UnregisterRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        updateRegistration(params: Protocol.ServiceWorker.UpdateRegistrationRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        onWorkerErrorReported(listener: (event: { params: Protocol.ServiceWorker.WorkerErrorReportedEvent }) => void): void;
+        offWorkerErrorReported(listener: (event: { params: Protocol.ServiceWorker.WorkerErrorReportedEvent }) => void): void;
+        onceWorkerErrorReported(eventMatcher?: (event: { params: Protocol.ServiceWorker.WorkerErrorReportedEvent }) => boolean): Promise<{ params: Protocol.ServiceWorker.WorkerErrorReportedEvent }>;
+
+        onWorkerRegistrationUpdated(listener: (event: { params: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent }) => void): void;
+        offWorkerRegistrationUpdated(listener: (event: { params: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent }) => void): void;
+        onceWorkerRegistrationUpdated(eventMatcher?: (event: { params: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent }) => boolean): Promise<{ params: Protocol.ServiceWorker.WorkerRegistrationUpdatedEvent }>;
+
+        onWorkerVersionUpdated(listener: (event: { params: Protocol.ServiceWorker.WorkerVersionUpdatedEvent }) => void): void;
+        offWorkerVersionUpdated(listener: (event: { params: Protocol.ServiceWorker.WorkerVersionUpdatedEvent }) => void): void;
+        onceWorkerVersionUpdated(eventMatcher?: (event: { params: Protocol.ServiceWorker.WorkerVersionUpdatedEvent }) => boolean): Promise<{ params: Protocol.ServiceWorker.WorkerVersionUpdatedEvent }>;
+
+    }
+
+    export interface StorageApi {
+        /**
+         * Returns a storage key given a frame id.
+         */
+        getStorageKeyForFrame(params: Protocol.Storage.GetStorageKeyForFrameRequest): Promise<{id: number, result: Protocol.Storage.GetStorageKeyForFrameResponse, sessionId: string}>;
+
+        /**
+         * Clears storage for origin.
+         */
+        clearDataForOrigin(params: Protocol.Storage.ClearDataForOriginRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears storage for storage key.
+         */
+        clearDataForStorageKey(params: Protocol.Storage.ClearDataForStorageKeyRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns all browser cookies.
+         */
+        getCookies(params: Protocol.Storage.GetCookiesRequest): Promise<{id: number, result: Protocol.Storage.GetCookiesResponse, sessionId: string}>;
+
+        /**
+         * Sets given cookies.
+         */
+        setCookies(params: Protocol.Storage.SetCookiesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears cookies.
+         */
+        clearCookies(params: Protocol.Storage.ClearCookiesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns usage and quota in bytes.
+         */
+        getUsageAndQuota(params: Protocol.Storage.GetUsageAndQuotaRequest): Promise<{id: number, result: Protocol.Storage.GetUsageAndQuotaResponse, sessionId: string}>;
+
+        /**
+         * Override quota for the specified origin
+         */
+        overrideQuotaForOrigin(params: Protocol.Storage.OverrideQuotaForOriginRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Registers origin to be notified when an update occurs to its cache storage list.
+         */
+        trackCacheStorageForOrigin(params: Protocol.Storage.TrackCacheStorageForOriginRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Registers storage key to be notified when an update occurs to its cache storage list.
+         */
+        trackCacheStorageForStorageKey(params: Protocol.Storage.TrackCacheStorageForStorageKeyRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Registers origin to be notified when an update occurs to its IndexedDB.
+         */
+        trackIndexedDBForOrigin(params: Protocol.Storage.TrackIndexedDBForOriginRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Registers storage key to be notified when an update occurs to its IndexedDB.
+         */
+        trackIndexedDBForStorageKey(params: Protocol.Storage.TrackIndexedDBForStorageKeyRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Unregisters origin from receiving notifications for cache storage.
+         */
+        untrackCacheStorageForOrigin(params: Protocol.Storage.UntrackCacheStorageForOriginRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Unregisters storage key from receiving notifications for cache storage.
+         */
+        untrackCacheStorageForStorageKey(params: Protocol.Storage.UntrackCacheStorageForStorageKeyRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Unregisters origin from receiving notifications for IndexedDB.
+         */
+        untrackIndexedDBForOrigin(params: Protocol.Storage.UntrackIndexedDBForOriginRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Unregisters storage key from receiving notifications for IndexedDB.
+         */
+        untrackIndexedDBForStorageKey(params: Protocol.Storage.UntrackIndexedDBForStorageKeyRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns the number of stored Trust Tokens per issuer for the
+         * current browsing context.
+         */
+        getTrustTokens(): Promise<{id: number, result: Protocol.Storage.GetTrustTokensResponse, sessionId: string}>;
+
+        /**
+         * Removes all Trust Tokens issued by the provided issuerOrigin.
+         * Leaves other stored data, including the issuer's Redemption Records, intact.
+         */
+        clearTrustTokens(params: Protocol.Storage.ClearTrustTokensRequest): Promise<{id: number, result: Protocol.Storage.ClearTrustTokensResponse, sessionId: string}>;
+
+        /**
+         * Gets details for a named interest group.
+         */
+        getInterestGroupDetails(params: Protocol.Storage.GetInterestGroupDetailsRequest): Promise<{id: number, result: Protocol.Storage.GetInterestGroupDetailsResponse, sessionId: string}>;
+
+        /**
+         * Enables/Disables issuing of interestGroupAccessed events.
+         */
+        setInterestGroupTracking(params: Protocol.Storage.SetInterestGroupTrackingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables/Disables issuing of interestGroupAuctionEventOccurred and
+         * interestGroupAuctionNetworkRequestCreated.
+         */
+        setInterestGroupAuctionTracking(params: Protocol.Storage.SetInterestGroupAuctionTrackingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Gets metadata for an origin's shared storage.
+         */
+        getSharedStorageMetadata(params: Protocol.Storage.GetSharedStorageMetadataRequest): Promise<{id: number, result: Protocol.Storage.GetSharedStorageMetadataResponse, sessionId: string}>;
+
+        /**
+         * Gets the entries in an given origin's shared storage.
+         */
+        getSharedStorageEntries(params: Protocol.Storage.GetSharedStorageEntriesRequest): Promise<{id: number, result: Protocol.Storage.GetSharedStorageEntriesResponse, sessionId: string}>;
+
+        /**
+         * Sets entry with `key` and `value` for a given origin's shared storage.
+         */
+        setSharedStorageEntry(params: Protocol.Storage.SetSharedStorageEntryRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Deletes entry for `key` (if it exists) for a given origin's shared storage.
+         */
+        deleteSharedStorageEntry(params: Protocol.Storage.DeleteSharedStorageEntryRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears all entries for a given origin's shared storage.
+         */
+        clearSharedStorageEntries(params: Protocol.Storage.ClearSharedStorageEntriesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Resets the budget for `ownerOrigin` by clearing all budget withdrawals.
+         */
+        resetSharedStorageBudget(params: Protocol.Storage.ResetSharedStorageBudgetRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables/disables issuing of sharedStorageAccessed events.
+         */
+        setSharedStorageTracking(params: Protocol.Storage.SetSharedStorageTrackingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Set tracking for a storage key's buckets.
+         */
+        setStorageBucketTracking(params: Protocol.Storage.SetStorageBucketTrackingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Deletes the Storage Bucket with the given storage key and bucket name.
+         */
+        deleteStorageBucket(params: Protocol.Storage.DeleteStorageBucketRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Deletes state for sites identified as potential bounce trackers, immediately.
+         */
+        runBounceTrackingMitigations(): Promise<{id: number, result: Protocol.Storage.RunBounceTrackingMitigationsResponse, sessionId: string}>;
+
+        /**
+         * https://wicg.github.io/attribution-reporting-api/
+         */
+        setAttributionReportingLocalTestingMode(params: Protocol.Storage.SetAttributionReportingLocalTestingModeRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables/disables issuing of Attribution Reporting events.
+         */
+        setAttributionReportingTracking(params: Protocol.Storage.SetAttributionReportingTrackingRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sends all pending Attribution Reports immediately, regardless of their
+         * scheduled report time.
+         */
+        sendPendingAttributionReports(): Promise<{id: number, result: Protocol.Storage.SendPendingAttributionReportsResponse, sessionId: string}>;
+
+        /**
+         * Returns the effective Related Website Sets in use by this profile for the browser
+         * session. The effective Related Website Sets will not change during a browser session.
+         */
+        getRelatedWebsiteSets(): Promise<{id: number, result: Protocol.Storage.GetRelatedWebsiteSetsResponse, sessionId: string}>;
+
+        /**
+         * A cache's contents have been modified.
+         */
+        onCacheStorageContentUpdated(listener: (event: { params: Protocol.Storage.CacheStorageContentUpdatedEvent }) => void): void;
+        offCacheStorageContentUpdated(listener: (event: { params: Protocol.Storage.CacheStorageContentUpdatedEvent }) => void): void;
+        onceCacheStorageContentUpdated(eventMatcher?: (event: { params: Protocol.Storage.CacheStorageContentUpdatedEvent }) => boolean): Promise<{ params: Protocol.Storage.CacheStorageContentUpdatedEvent }>;
+
+        /**
+         * A cache has been added/deleted.
+         */
+        onCacheStorageListUpdated(listener: (event: { params: Protocol.Storage.CacheStorageListUpdatedEvent }) => void): void;
+        offCacheStorageListUpdated(listener: (event: { params: Protocol.Storage.CacheStorageListUpdatedEvent }) => void): void;
+        onceCacheStorageListUpdated(eventMatcher?: (event: { params: Protocol.Storage.CacheStorageListUpdatedEvent }) => boolean): Promise<{ params: Protocol.Storage.CacheStorageListUpdatedEvent }>;
+
+        /**
+         * The origin's IndexedDB object store has been modified.
+         */
+        onIndexedDBContentUpdated(listener: (event: { params: Protocol.Storage.IndexedDBContentUpdatedEvent }) => void): void;
+        offIndexedDBContentUpdated(listener: (event: { params: Protocol.Storage.IndexedDBContentUpdatedEvent }) => void): void;
+        onceIndexedDBContentUpdated(eventMatcher?: (event: { params: Protocol.Storage.IndexedDBContentUpdatedEvent }) => boolean): Promise<{ params: Protocol.Storage.IndexedDBContentUpdatedEvent }>;
+
+        /**
+         * The origin's IndexedDB database list has been modified.
+         */
+        onIndexedDBListUpdated(listener: (event: { params: Protocol.Storage.IndexedDBListUpdatedEvent }) => void): void;
+        offIndexedDBListUpdated(listener: (event: { params: Protocol.Storage.IndexedDBListUpdatedEvent }) => void): void;
+        onceIndexedDBListUpdated(eventMatcher?: (event: { params: Protocol.Storage.IndexedDBListUpdatedEvent }) => boolean): Promise<{ params: Protocol.Storage.IndexedDBListUpdatedEvent }>;
+
+        /**
+         * One of the interest groups was accessed. Note that these events are global
+         * to all targets sharing an interest group store.
+         */
+        onInterestGroupAccessed(listener: (event: { params: Protocol.Storage.InterestGroupAccessedEvent }) => void): void;
+        offInterestGroupAccessed(listener: (event: { params: Protocol.Storage.InterestGroupAccessedEvent }) => void): void;
+        onceInterestGroupAccessed(eventMatcher?: (event: { params: Protocol.Storage.InterestGroupAccessedEvent }) => boolean): Promise<{ params: Protocol.Storage.InterestGroupAccessedEvent }>;
+
+        /**
+         * An auction involving interest groups is taking place. These events are
+         * target-specific.
+         */
+        onInterestGroupAuctionEventOccurred(listener: (event: { params: Protocol.Storage.InterestGroupAuctionEventOccurredEvent }) => void): void;
+        offInterestGroupAuctionEventOccurred(listener: (event: { params: Protocol.Storage.InterestGroupAuctionEventOccurredEvent }) => void): void;
+        onceInterestGroupAuctionEventOccurred(eventMatcher?: (event: { params: Protocol.Storage.InterestGroupAuctionEventOccurredEvent }) => boolean): Promise<{ params: Protocol.Storage.InterestGroupAuctionEventOccurredEvent }>;
+
+        /**
+         * Specifies which auctions a particular network fetch may be related to, and
+         * in what role. Note that it is not ordered with respect to
+         * Network.requestWillBeSent (but will happen before loadingFinished
+         * loadingFailed).
+         */
+        onInterestGroupAuctionNetworkRequestCreated(listener: (event: { params: Protocol.Storage.InterestGroupAuctionNetworkRequestCreatedEvent }) => void): void;
+        offInterestGroupAuctionNetworkRequestCreated(listener: (event: { params: Protocol.Storage.InterestGroupAuctionNetworkRequestCreatedEvent }) => void): void;
+        onceInterestGroupAuctionNetworkRequestCreated(eventMatcher?: (event: { params: Protocol.Storage.InterestGroupAuctionNetworkRequestCreatedEvent }) => boolean): Promise<{ params: Protocol.Storage.InterestGroupAuctionNetworkRequestCreatedEvent }>;
+
+        /**
+         * Shared storage was accessed by the associated page.
+         * The following parameters are included in all events.
+         */
+        onSharedStorageAccessed(listener: (event: { params: Protocol.Storage.SharedStorageAccessedEvent }) => void): void;
+        offSharedStorageAccessed(listener: (event: { params: Protocol.Storage.SharedStorageAccessedEvent }) => void): void;
+        onceSharedStorageAccessed(eventMatcher?: (event: { params: Protocol.Storage.SharedStorageAccessedEvent }) => boolean): Promise<{ params: Protocol.Storage.SharedStorageAccessedEvent }>;
+
+        onStorageBucketCreatedOrUpdated(listener: (event: { params: Protocol.Storage.StorageBucketCreatedOrUpdatedEvent }) => void): void;
+        offStorageBucketCreatedOrUpdated(listener: (event: { params: Protocol.Storage.StorageBucketCreatedOrUpdatedEvent }) => void): void;
+        onceStorageBucketCreatedOrUpdated(eventMatcher?: (event: { params: Protocol.Storage.StorageBucketCreatedOrUpdatedEvent }) => boolean): Promise<{ params: Protocol.Storage.StorageBucketCreatedOrUpdatedEvent }>;
+
+        onStorageBucketDeleted(listener: (event: { params: Protocol.Storage.StorageBucketDeletedEvent }) => void): void;
+        offStorageBucketDeleted(listener: (event: { params: Protocol.Storage.StorageBucketDeletedEvent }) => void): void;
+        onceStorageBucketDeleted(eventMatcher?: (event: { params: Protocol.Storage.StorageBucketDeletedEvent }) => boolean): Promise<{ params: Protocol.Storage.StorageBucketDeletedEvent }>;
+
+        onAttributionReportingSourceRegistered(listener: (event: { params: Protocol.Storage.AttributionReportingSourceRegisteredEvent }) => void): void;
+        offAttributionReportingSourceRegistered(listener: (event: { params: Protocol.Storage.AttributionReportingSourceRegisteredEvent }) => void): void;
+        onceAttributionReportingSourceRegistered(eventMatcher?: (event: { params: Protocol.Storage.AttributionReportingSourceRegisteredEvent }) => boolean): Promise<{ params: Protocol.Storage.AttributionReportingSourceRegisteredEvent }>;
+
+        onAttributionReportingTriggerRegistered(listener: (event: { params: Protocol.Storage.AttributionReportingTriggerRegisteredEvent }) => void): void;
+        offAttributionReportingTriggerRegistered(listener: (event: { params: Protocol.Storage.AttributionReportingTriggerRegisteredEvent }) => void): void;
+        onceAttributionReportingTriggerRegistered(eventMatcher?: (event: { params: Protocol.Storage.AttributionReportingTriggerRegisteredEvent }) => boolean): Promise<{ params: Protocol.Storage.AttributionReportingTriggerRegisteredEvent }>;
+
+    }
+
+    export interface SystemInfoApi {
+        /**
+         * Returns information about the system.
+         */
+        getInfo(): Promise<{id: number, result: Protocol.SystemInfo.GetInfoResponse, sessionId: string}>;
+
+        /**
+         * Returns information about the feature state.
+         */
+        getFeatureState(params: Protocol.SystemInfo.GetFeatureStateRequest): Promise<{id: number, result: Protocol.SystemInfo.GetFeatureStateResponse, sessionId: string}>;
+
+        /**
+         * Returns information about all running processes.
+         */
+        getProcessInfo(): Promise<{id: number, result: Protocol.SystemInfo.GetProcessInfoResponse, sessionId: string}>;
+
+    }
+
+    export interface TargetApi {
+        /**
+         * Activates (focuses) the target.
+         */
+        activateTarget(params: Protocol.Target.ActivateTargetRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Attaches to the target with given id.
+         */
+        attachToTarget(params: Protocol.Target.AttachToTargetRequest): Promise<{id: number, result: Protocol.Target.AttachToTargetResponse, sessionId: string}>;
+
+        /**
+         * Attaches to the browser target, only uses flat sessionId mode.
+         */
+        attachToBrowserTarget(): Promise<{id: number, result: Protocol.Target.AttachToBrowserTargetResponse, sessionId: string}>;
+
+        /**
+         * Closes the target. If the target is a page that gets closed too.
+         */
+        closeTarget(params: Protocol.Target.CloseTargetRequest): Promise<{id: number, result: Protocol.Target.CloseTargetResponse, sessionId: string}>;
+
+        /**
+         * Inject object to the target's main frame that provides a communication
+         * channel with browser target.
+         * 
+         * Injected object will be available as `window[bindingName]`.
+         * 
+         * The object has the following API:
+         * - `binding.send(json)` - a method to send messages over the remote debugging protocol
+         * - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
+         */
+        exposeDevToolsProtocol(params: Protocol.Target.ExposeDevToolsProtocolRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
+         * one.
+         */
+        createBrowserContext(params: Protocol.Target.CreateBrowserContextRequest): Promise<{id: number, result: Protocol.Target.CreateBrowserContextResponse, sessionId: string}>;
+
+        /**
+         * Returns all browser contexts created with `Target.createBrowserContext` method.
+         */
+        getBrowserContexts(): Promise<{id: number, result: Protocol.Target.GetBrowserContextsResponse, sessionId: string}>;
+
+        /**
+         * Creates a new page.
+         */
+        createTarget(params: Protocol.Target.CreateTargetRequest): Promise<{id: number, result: Protocol.Target.CreateTargetResponse, sessionId: string}>;
+
+        /**
+         * Detaches session with given id.
+         */
+        detachFromTarget(params: Protocol.Target.DetachFromTargetRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Deletes a BrowserContext. All the belonging pages will be closed without calling their
+         * beforeunload hooks.
+         */
+        disposeBrowserContext(params: Protocol.Target.DisposeBrowserContextRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns information about a target.
+         */
+        getTargetInfo(params: Protocol.Target.GetTargetInfoRequest): Promise<{id: number, result: Protocol.Target.GetTargetInfoResponse, sessionId: string}>;
+
+        /**
+         * Retrieves a list of available targets.
+         */
+        getTargets(params: Protocol.Target.GetTargetsRequest): Promise<{id: number, result: Protocol.Target.GetTargetsResponse, sessionId: string}>;
+
+        /**
+         * Sends protocol message over session with given id.
+         * Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
+         * and crbug.com/991325.
+         */
+        sendMessageToTarget(params: Protocol.Target.SendMessageToTargetRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Controls whether to automatically attach to new targets which are considered to be related to
+         * this one. When turned on, attaches to all existing related targets as well. When turned off,
+         * automatically detaches from all currently attached targets.
+         * This also clears all targets added by `autoAttachRelated` from the list of targets to watch
+         * for creation of related targets.
+         */
+        setAutoAttach(params: Protocol.Target.SetAutoAttachRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Adds the specified target to the list of targets that will be monitored for any related target
+         * creation (such as child frames, child workers and new versions of service worker) and reported
+         * through `attachedToTarget`. The specified target is also auto-attached.
+         * This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
+         * `setAutoAttach`. Only available at the Browser target.
+         */
+        autoAttachRelated(params: Protocol.Target.AutoAttachRelatedRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Controls whether to discover available targets and notify via
+         * `targetCreated/targetInfoChanged/targetDestroyed` events.
+         */
+        setDiscoverTargets(params: Protocol.Target.SetDiscoverTargetsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
+         * `true`.
+         */
+        setRemoteLocations(params: Protocol.Target.SetRemoteLocationsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Issued when attached to target because of auto-attach or `attachToTarget` command.
+         */
+        onAttachedToTarget(listener: (event: { params: Protocol.Target.AttachedToTargetEvent }) => void): void;
+        offAttachedToTarget(listener: (event: { params: Protocol.Target.AttachedToTargetEvent }) => void): void;
+        onceAttachedToTarget(eventMatcher?: (event: { params: Protocol.Target.AttachedToTargetEvent }) => boolean): Promise<{ params: Protocol.Target.AttachedToTargetEvent }>;
+
+        /**
+         * Issued when detached from target for any reason (including `detachFromTarget` command). Can be
+         * issued multiple times per target if multiple sessions have been attached to it.
+         */
+        onDetachedFromTarget(listener: (event: { params: Protocol.Target.DetachedFromTargetEvent }) => void): void;
+        offDetachedFromTarget(listener: (event: { params: Protocol.Target.DetachedFromTargetEvent }) => void): void;
+        onceDetachedFromTarget(eventMatcher?: (event: { params: Protocol.Target.DetachedFromTargetEvent }) => boolean): Promise<{ params: Protocol.Target.DetachedFromTargetEvent }>;
+
+        /**
+         * Notifies about a new protocol message received from the session (as reported in
+         * `attachedToTarget` event).
+         */
+        onReceivedMessageFromTarget(listener: (event: { params: Protocol.Target.ReceivedMessageFromTargetEvent }) => void): void;
+        offReceivedMessageFromTarget(listener: (event: { params: Protocol.Target.ReceivedMessageFromTargetEvent }) => void): void;
+        onceReceivedMessageFromTarget(eventMatcher?: (event: { params: Protocol.Target.ReceivedMessageFromTargetEvent }) => boolean): Promise<{ params: Protocol.Target.ReceivedMessageFromTargetEvent }>;
+
+        /**
+         * Issued when a possible inspection target is created.
+         */
+        onTargetCreated(listener: (event: { params: Protocol.Target.TargetCreatedEvent }) => void): void;
+        offTargetCreated(listener: (event: { params: Protocol.Target.TargetCreatedEvent }) => void): void;
+        onceTargetCreated(eventMatcher?: (event: { params: Protocol.Target.TargetCreatedEvent }) => boolean): Promise<{ params: Protocol.Target.TargetCreatedEvent }>;
+
+        /**
+         * Issued when a target is destroyed.
+         */
+        onTargetDestroyed(listener: (event: { params: Protocol.Target.TargetDestroyedEvent }) => void): void;
+        offTargetDestroyed(listener: (event: { params: Protocol.Target.TargetDestroyedEvent }) => void): void;
+        onceTargetDestroyed(eventMatcher?: (event: { params: Protocol.Target.TargetDestroyedEvent }) => boolean): Promise<{ params: Protocol.Target.TargetDestroyedEvent }>;
+
+        /**
+         * Issued when a target has crashed.
+         */
+        onTargetCrashed(listener: (event: { params: Protocol.Target.TargetCrashedEvent }) => void): void;
+        offTargetCrashed(listener: (event: { params: Protocol.Target.TargetCrashedEvent }) => void): void;
+        onceTargetCrashed(eventMatcher?: (event: { params: Protocol.Target.TargetCrashedEvent }) => boolean): Promise<{ params: Protocol.Target.TargetCrashedEvent }>;
+
+        /**
+         * Issued when some information about a target has changed. This only happens between
+         * `targetCreated` and `targetDestroyed`.
+         */
+        onTargetInfoChanged(listener: (event: { params: Protocol.Target.TargetInfoChangedEvent }) => void): void;
+        offTargetInfoChanged(listener: (event: { params: Protocol.Target.TargetInfoChangedEvent }) => void): void;
+        onceTargetInfoChanged(eventMatcher?: (event: { params: Protocol.Target.TargetInfoChangedEvent }) => boolean): Promise<{ params: Protocol.Target.TargetInfoChangedEvent }>;
+
+    }
+
+    export interface TetheringApi {
+        /**
+         * Request browser port binding.
+         */
+        bind(params: Protocol.Tethering.BindRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Request browser port unbinding.
+         */
+        unbind(params: Protocol.Tethering.UnbindRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Informs that port was successfully bound and got a specified connection id.
+         */
+        onAccepted(listener: (event: { params: Protocol.Tethering.AcceptedEvent }) => void): void;
+        offAccepted(listener: (event: { params: Protocol.Tethering.AcceptedEvent }) => void): void;
+        onceAccepted(eventMatcher?: (event: { params: Protocol.Tethering.AcceptedEvent }) => boolean): Promise<{ params: Protocol.Tethering.AcceptedEvent }>;
+
+    }
+
+    export interface TracingApi {
+        /**
+         * Stop trace events collection.
+         */
+        end(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Gets supported tracing categories.
+         */
+        getCategories(): Promise<{id: number, result: Protocol.Tracing.GetCategoriesResponse, sessionId: string}>;
+
+        /**
+         * Record a clock sync marker in the trace.
+         */
+        recordClockSyncMarker(params: Protocol.Tracing.RecordClockSyncMarkerRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Request a global memory dump.
+         */
+        requestMemoryDump(params: Protocol.Tracing.RequestMemoryDumpRequest): Promise<{id: number, result: Protocol.Tracing.RequestMemoryDumpResponse, sessionId: string}>;
+
+        /**
+         * Start trace events collection.
+         */
+        start(params: Protocol.Tracing.StartRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        onBufferUsage(listener: (event: { params: Protocol.Tracing.BufferUsageEvent }) => void): void;
+        offBufferUsage(listener: (event: { params: Protocol.Tracing.BufferUsageEvent }) => void): void;
+        onceBufferUsage(eventMatcher?: (event: { params: Protocol.Tracing.BufferUsageEvent }) => boolean): Promise<{ params: Protocol.Tracing.BufferUsageEvent }>;
+
+        /**
+         * Contains a bucket of collected trace events. When tracing is stopped collected events will be
+         * sent as a sequence of dataCollected events followed by tracingComplete event.
+         */
+        onDataCollected(listener: (event: { params: Protocol.Tracing.DataCollectedEvent }) => void): void;
+        offDataCollected(listener: (event: { params: Protocol.Tracing.DataCollectedEvent }) => void): void;
+        onceDataCollected(eventMatcher?: (event: { params: Protocol.Tracing.DataCollectedEvent }) => boolean): Promise<{ params: Protocol.Tracing.DataCollectedEvent }>;
+
+        /**
+         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
+         * delivered via dataCollected events.
+         */
+        onTracingComplete(listener: (event: { params: Protocol.Tracing.TracingCompleteEvent }) => void): void;
+        offTracingComplete(listener: (event: { params: Protocol.Tracing.TracingCompleteEvent }) => void): void;
+        onceTracingComplete(eventMatcher?: (event: { params: Protocol.Tracing.TracingCompleteEvent }) => boolean): Promise<{ params: Protocol.Tracing.TracingCompleteEvent }>;
+
+    }
+
+    export interface FetchApi {
+        /**
+         * Disables the fetch domain.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Enables issuing of requestPaused events. A request will be paused until client
+         * calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
+         */
+        enable(params: Protocol.Fetch.EnableRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Causes the request to fail with specified reason.
+         */
+        failRequest(params: Protocol.Fetch.FailRequestRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Provides response to the request.
+         */
+        fulfillRequest(params: Protocol.Fetch.FulfillRequestRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Continues the request, optionally modifying some of its parameters.
+         */
+        continueRequest(params: Protocol.Fetch.ContinueRequestRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Continues a request supplying authChallengeResponse following authRequired event.
+         */
+        continueWithAuth(params: Protocol.Fetch.ContinueWithAuthRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Continues loading of the paused response, optionally modifying the
+         * response headers. If either responseCode or headers are modified, all of them
+         * must be present.
+         */
+        continueResponse(params: Protocol.Fetch.ContinueResponseRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Causes the body of the response to be received from the server and
+         * returned as a single string. May only be issued for a request that
+         * is paused in the Response stage and is mutually exclusive with
+         * takeResponseBodyForInterceptionAsStream. Calling other methods that
+         * affect the request or disabling fetch domain before body is received
+         * results in an undefined behavior.
+         * Note that the response body is not available for redirects. Requests
+         * paused in the _redirect received_ state may be differentiated by
+         * `responseCode` and presence of `location` response header, see
+         * comments to `requestPaused` for details.
+         */
+        getResponseBody(params: Protocol.Fetch.GetResponseBodyRequest): Promise<{id: number, result: Protocol.Fetch.GetResponseBodyResponse, sessionId: string}>;
+
+        /**
+         * Returns a handle to the stream representing the response body.
+         * The request must be paused in the HeadersReceived stage.
+         * Note that after this command the request can't be continued
+         * as is -- client either needs to cancel it or to provide the
+         * response body.
+         * The stream only supports sequential read, IO.read will fail if the position
+         * is specified.
+         * This method is mutually exclusive with getResponseBody.
+         * Calling other methods that affect the request or disabling fetch
+         * domain before body is received results in an undefined behavior.
+         */
+        takeResponseBodyAsStream(params: Protocol.Fetch.TakeResponseBodyAsStreamRequest): Promise<{id: number, result: Protocol.Fetch.TakeResponseBodyAsStreamResponse, sessionId: string}>;
+
+        /**
+         * Issued when the domain is enabled and the request URL matches the
+         * specified filter. The request is paused until the client responds
+         * with one of continueRequest, failRequest or fulfillRequest.
+         * The stage of the request can be determined by presence of responseErrorReason
+         * and responseStatusCode -- the request is at the response stage if either
+         * of these fields is present and in the request stage otherwise.
+         * Redirect responses and subsequent requests are reported similarly to regular
+         * responses and requests. Redirect responses may be distinguished by the value
+         * of `responseStatusCode` (which is one of 301, 302, 303, 307, 308) along with
+         * presence of the `location` header. Requests resulting from a redirect will
+         * have `redirectedRequestId` field set.
+         */
+        onRequestPaused(listener: (event: { params: Protocol.Fetch.RequestPausedEvent }) => void): void;
+        offRequestPaused(listener: (event: { params: Protocol.Fetch.RequestPausedEvent }) => void): void;
+        onceRequestPaused(eventMatcher?: (event: { params: Protocol.Fetch.RequestPausedEvent }) => boolean): Promise<{ params: Protocol.Fetch.RequestPausedEvent }>;
+
+        /**
+         * Issued when the domain is enabled with handleAuthRequests set to true.
+         * The request is paused until client responds with continueWithAuth.
+         */
+        onAuthRequired(listener: (event: { params: Protocol.Fetch.AuthRequiredEvent }) => void): void;
+        offAuthRequired(listener: (event: { params: Protocol.Fetch.AuthRequiredEvent }) => void): void;
+        onceAuthRequired(eventMatcher?: (event: { params: Protocol.Fetch.AuthRequiredEvent }) => boolean): Promise<{ params: Protocol.Fetch.AuthRequiredEvent }>;
+
+    }
+
+    export interface WebAudioApi {
+        /**
+         * Enables the WebAudio domain and starts sending context lifetime events.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables the WebAudio domain.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Fetch the realtime data from the registered contexts.
+         */
+        getRealtimeData(params: Protocol.WebAudio.GetRealtimeDataRequest): Promise<{id: number, result: Protocol.WebAudio.GetRealtimeDataResponse, sessionId: string}>;
+
+        /**
+         * Notifies that a new BaseAudioContext has been created.
+         */
+        onContextCreated(listener: (event: { params: Protocol.WebAudio.ContextCreatedEvent }) => void): void;
+        offContextCreated(listener: (event: { params: Protocol.WebAudio.ContextCreatedEvent }) => void): void;
+        onceContextCreated(eventMatcher?: (event: { params: Protocol.WebAudio.ContextCreatedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.ContextCreatedEvent }>;
+
+        /**
+         * Notifies that an existing BaseAudioContext will be destroyed.
+         */
+        onContextWillBeDestroyed(listener: (event: { params: Protocol.WebAudio.ContextWillBeDestroyedEvent }) => void): void;
+        offContextWillBeDestroyed(listener: (event: { params: Protocol.WebAudio.ContextWillBeDestroyedEvent }) => void): void;
+        onceContextWillBeDestroyed(eventMatcher?: (event: { params: Protocol.WebAudio.ContextWillBeDestroyedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.ContextWillBeDestroyedEvent }>;
+
+        /**
+         * Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
+         */
+        onContextChanged(listener: (event: { params: Protocol.WebAudio.ContextChangedEvent }) => void): void;
+        offContextChanged(listener: (event: { params: Protocol.WebAudio.ContextChangedEvent }) => void): void;
+        onceContextChanged(eventMatcher?: (event: { params: Protocol.WebAudio.ContextChangedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.ContextChangedEvent }>;
+
+        /**
+         * Notifies that the construction of an AudioListener has finished.
+         */
+        onAudioListenerCreated(listener: (event: { params: Protocol.WebAudio.AudioListenerCreatedEvent }) => void): void;
+        offAudioListenerCreated(listener: (event: { params: Protocol.WebAudio.AudioListenerCreatedEvent }) => void): void;
+        onceAudioListenerCreated(eventMatcher?: (event: { params: Protocol.WebAudio.AudioListenerCreatedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.AudioListenerCreatedEvent }>;
+
+        /**
+         * Notifies that a new AudioListener has been created.
+         */
+        onAudioListenerWillBeDestroyed(listener: (event: { params: Protocol.WebAudio.AudioListenerWillBeDestroyedEvent }) => void): void;
+        offAudioListenerWillBeDestroyed(listener: (event: { params: Protocol.WebAudio.AudioListenerWillBeDestroyedEvent }) => void): void;
+        onceAudioListenerWillBeDestroyed(eventMatcher?: (event: { params: Protocol.WebAudio.AudioListenerWillBeDestroyedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.AudioListenerWillBeDestroyedEvent }>;
+
+        /**
+         * Notifies that a new AudioNode has been created.
+         */
+        onAudioNodeCreated(listener: (event: { params: Protocol.WebAudio.AudioNodeCreatedEvent }) => void): void;
+        offAudioNodeCreated(listener: (event: { params: Protocol.WebAudio.AudioNodeCreatedEvent }) => void): void;
+        onceAudioNodeCreated(eventMatcher?: (event: { params: Protocol.WebAudio.AudioNodeCreatedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.AudioNodeCreatedEvent }>;
+
+        /**
+         * Notifies that an existing AudioNode has been destroyed.
+         */
+        onAudioNodeWillBeDestroyed(listener: (event: { params: Protocol.WebAudio.AudioNodeWillBeDestroyedEvent }) => void): void;
+        offAudioNodeWillBeDestroyed(listener: (event: { params: Protocol.WebAudio.AudioNodeWillBeDestroyedEvent }) => void): void;
+        onceAudioNodeWillBeDestroyed(eventMatcher?: (event: { params: Protocol.WebAudio.AudioNodeWillBeDestroyedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.AudioNodeWillBeDestroyedEvent }>;
+
+        /**
+         * Notifies that a new AudioParam has been created.
+         */
+        onAudioParamCreated(listener: (event: { params: Protocol.WebAudio.AudioParamCreatedEvent }) => void): void;
+        offAudioParamCreated(listener: (event: { params: Protocol.WebAudio.AudioParamCreatedEvent }) => void): void;
+        onceAudioParamCreated(eventMatcher?: (event: { params: Protocol.WebAudio.AudioParamCreatedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.AudioParamCreatedEvent }>;
+
+        /**
+         * Notifies that an existing AudioParam has been destroyed.
+         */
+        onAudioParamWillBeDestroyed(listener: (event: { params: Protocol.WebAudio.AudioParamWillBeDestroyedEvent }) => void): void;
+        offAudioParamWillBeDestroyed(listener: (event: { params: Protocol.WebAudio.AudioParamWillBeDestroyedEvent }) => void): void;
+        onceAudioParamWillBeDestroyed(eventMatcher?: (event: { params: Protocol.WebAudio.AudioParamWillBeDestroyedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.AudioParamWillBeDestroyedEvent }>;
+
+        /**
+         * Notifies that two AudioNodes are connected.
+         */
+        onNodesConnected(listener: (event: { params: Protocol.WebAudio.NodesConnectedEvent }) => void): void;
+        offNodesConnected(listener: (event: { params: Protocol.WebAudio.NodesConnectedEvent }) => void): void;
+        onceNodesConnected(eventMatcher?: (event: { params: Protocol.WebAudio.NodesConnectedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.NodesConnectedEvent }>;
+
+        /**
+         * Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
+         */
+        onNodesDisconnected(listener: (event: { params: Protocol.WebAudio.NodesDisconnectedEvent }) => void): void;
+        offNodesDisconnected(listener: (event: { params: Protocol.WebAudio.NodesDisconnectedEvent }) => void): void;
+        onceNodesDisconnected(eventMatcher?: (event: { params: Protocol.WebAudio.NodesDisconnectedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.NodesDisconnectedEvent }>;
+
+        /**
+         * Notifies that an AudioNode is connected to an AudioParam.
+         */
+        onNodeParamConnected(listener: (event: { params: Protocol.WebAudio.NodeParamConnectedEvent }) => void): void;
+        offNodeParamConnected(listener: (event: { params: Protocol.WebAudio.NodeParamConnectedEvent }) => void): void;
+        onceNodeParamConnected(eventMatcher?: (event: { params: Protocol.WebAudio.NodeParamConnectedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.NodeParamConnectedEvent }>;
+
+        /**
+         * Notifies that an AudioNode is disconnected to an AudioParam.
+         */
+        onNodeParamDisconnected(listener: (event: { params: Protocol.WebAudio.NodeParamDisconnectedEvent }) => void): void;
+        offNodeParamDisconnected(listener: (event: { params: Protocol.WebAudio.NodeParamDisconnectedEvent }) => void): void;
+        onceNodeParamDisconnected(eventMatcher?: (event: { params: Protocol.WebAudio.NodeParamDisconnectedEvent }) => boolean): Promise<{ params: Protocol.WebAudio.NodeParamDisconnectedEvent }>;
+
+    }
+
+    export interface WebAuthnApi {
+        /**
+         * Enable the WebAuthn domain and start intercepting credential storage and
+         * retrieval with a virtual authenticator.
+         */
+        enable(params: Protocol.WebAuthn.EnableRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disable the WebAuthn domain.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Creates and adds a virtual authenticator.
+         */
+        addVirtualAuthenticator(params: Protocol.WebAuthn.AddVirtualAuthenticatorRequest): Promise<{id: number, result: Protocol.WebAuthn.AddVirtualAuthenticatorResponse, sessionId: string}>;
+
+        /**
+         * Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present.
+         */
+        setResponseOverrideBits(params: Protocol.WebAuthn.SetResponseOverrideBitsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Removes the given authenticator.
+         */
+        removeVirtualAuthenticator(params: Protocol.WebAuthn.RemoveVirtualAuthenticatorRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Adds the credential to the specified authenticator.
+         */
+        addCredential(params: Protocol.WebAuthn.AddCredentialRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Returns a single credential stored in the given virtual authenticator that
+         * matches the credential ID.
+         */
+        getCredential(params: Protocol.WebAuthn.GetCredentialRequest): Promise<{id: number, result: Protocol.WebAuthn.GetCredentialResponse, sessionId: string}>;
+
+        /**
+         * Returns all the credentials stored in the given virtual authenticator.
+         */
+        getCredentials(params: Protocol.WebAuthn.GetCredentialsRequest): Promise<{id: number, result: Protocol.WebAuthn.GetCredentialsResponse, sessionId: string}>;
+
+        /**
+         * Removes a credential from the authenticator.
+         */
+        removeCredential(params: Protocol.WebAuthn.RemoveCredentialRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Clears all the credentials from the specified device.
+         */
+        clearCredentials(params: Protocol.WebAuthn.ClearCredentialsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets whether User Verification succeeds or fails for an authenticator.
+         * The default is true.
+         */
+        setUserVerified(params: Protocol.WebAuthn.SetUserVerifiedRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
+         * The default is true.
+         */
+        setAutomaticPresenceSimulation(params: Protocol.WebAuthn.SetAutomaticPresenceSimulationRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Allows setting credential properties.
+         * https://w3c.github.io/webauthn/#sctn-automation-set-credential-properties
+         */
+        setCredentialProperties(params: Protocol.WebAuthn.SetCredentialPropertiesRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Triggered when a credential is added to an authenticator.
+         */
+        onCredentialAdded(listener: (event: { params: Protocol.WebAuthn.CredentialAddedEvent }) => void): void;
+        offCredentialAdded(listener: (event: { params: Protocol.WebAuthn.CredentialAddedEvent }) => void): void;
+        onceCredentialAdded(eventMatcher?: (event: { params: Protocol.WebAuthn.CredentialAddedEvent }) => boolean): Promise<{ params: Protocol.WebAuthn.CredentialAddedEvent }>;
+
+        /**
+         * Triggered when a credential is used in a webauthn assertion.
+         */
+        onCredentialAsserted(listener: (event: { params: Protocol.WebAuthn.CredentialAssertedEvent }) => void): void;
+        offCredentialAsserted(listener: (event: { params: Protocol.WebAuthn.CredentialAssertedEvent }) => void): void;
+        onceCredentialAsserted(eventMatcher?: (event: { params: Protocol.WebAuthn.CredentialAssertedEvent }) => boolean): Promise<{ params: Protocol.WebAuthn.CredentialAssertedEvent }>;
+
+    }
+
+    export interface MediaApi {
+        /**
+         * Enables the Media domain
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disables the Media domain.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * This can be called multiple times, and can be used to set / override /
+         * remove player properties. A null propValue indicates removal.
+         */
+        onPlayerPropertiesChanged(listener: (event: { params: Protocol.Media.PlayerPropertiesChangedEvent }) => void): void;
+        offPlayerPropertiesChanged(listener: (event: { params: Protocol.Media.PlayerPropertiesChangedEvent }) => void): void;
+        oncePlayerPropertiesChanged(eventMatcher?: (event: { params: Protocol.Media.PlayerPropertiesChangedEvent }) => boolean): Promise<{ params: Protocol.Media.PlayerPropertiesChangedEvent }>;
+
+        /**
+         * Send events as a list, allowing them to be batched on the browser for less
+         * congestion. If batched, events must ALWAYS be in chronological order.
+         */
+        onPlayerEventsAdded(listener: (event: { params: Protocol.Media.PlayerEventsAddedEvent }) => void): void;
+        offPlayerEventsAdded(listener: (event: { params: Protocol.Media.PlayerEventsAddedEvent }) => void): void;
+        oncePlayerEventsAdded(eventMatcher?: (event: { params: Protocol.Media.PlayerEventsAddedEvent }) => boolean): Promise<{ params: Protocol.Media.PlayerEventsAddedEvent }>;
+
+        /**
+         * Send a list of any messages that need to be delivered.
+         */
+        onPlayerMessagesLogged(listener: (event: { params: Protocol.Media.PlayerMessagesLoggedEvent }) => void): void;
+        offPlayerMessagesLogged(listener: (event: { params: Protocol.Media.PlayerMessagesLoggedEvent }) => void): void;
+        oncePlayerMessagesLogged(eventMatcher?: (event: { params: Protocol.Media.PlayerMessagesLoggedEvent }) => boolean): Promise<{ params: Protocol.Media.PlayerMessagesLoggedEvent }>;
+
+        /**
+         * Send a list of any errors that need to be delivered.
+         */
+        onPlayerErrorsRaised(listener: (event: { params: Protocol.Media.PlayerErrorsRaisedEvent }) => void): void;
+        offPlayerErrorsRaised(listener: (event: { params: Protocol.Media.PlayerErrorsRaisedEvent }) => void): void;
+        oncePlayerErrorsRaised(eventMatcher?: (event: { params: Protocol.Media.PlayerErrorsRaisedEvent }) => boolean): Promise<{ params: Protocol.Media.PlayerErrorsRaisedEvent }>;
+
+        /**
+         * Called whenever a player is created, or when a new agent joins and receives
+         * a list of active players. If an agent is restored, it will receive the full
+         * list of player ids and all events again.
+         */
+        onPlayersCreated(listener: (event: { params: Protocol.Media.PlayersCreatedEvent }) => void): void;
+        offPlayersCreated(listener: (event: { params: Protocol.Media.PlayersCreatedEvent }) => void): void;
+        oncePlayersCreated(eventMatcher?: (event: { params: Protocol.Media.PlayersCreatedEvent }) => boolean): Promise<{ params: Protocol.Media.PlayersCreatedEvent }>;
+
+    }
+
+    export interface DeviceAccessApi {
+        /**
+         * Enable events in this domain.
+         */
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disable events in this domain.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Select a device in response to a DeviceAccess.deviceRequestPrompted event.
+         */
+        selectPrompt(params: Protocol.DeviceAccess.SelectPromptRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event.
+         */
+        cancelPrompt(params: Protocol.DeviceAccess.CancelPromptRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * A device request opened a user prompt to select a device. Respond with the
+         * selectPrompt or cancelPrompt command.
+         */
+        onDeviceRequestPrompted(listener: (event: { params: Protocol.DeviceAccess.DeviceRequestPromptedEvent }) => void): void;
+        offDeviceRequestPrompted(listener: (event: { params: Protocol.DeviceAccess.DeviceRequestPromptedEvent }) => void): void;
+        onceDeviceRequestPrompted(eventMatcher?: (event: { params: Protocol.DeviceAccess.DeviceRequestPromptedEvent }) => boolean): Promise<{ params: Protocol.DeviceAccess.DeviceRequestPromptedEvent }>;
+
+    }
+
+    export interface PreloadApi {
+        enable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Upsert. Currently, it is only emitted when a rule set added.
+         */
+        onRuleSetUpdated(listener: (event: { params: Protocol.Preload.RuleSetUpdatedEvent }) => void): void;
+        offRuleSetUpdated(listener: (event: { params: Protocol.Preload.RuleSetUpdatedEvent }) => void): void;
+        onceRuleSetUpdated(eventMatcher?: (event: { params: Protocol.Preload.RuleSetUpdatedEvent }) => boolean): Promise<{ params: Protocol.Preload.RuleSetUpdatedEvent }>;
+
+        onRuleSetRemoved(listener: (event: { params: Protocol.Preload.RuleSetRemovedEvent }) => void): void;
+        offRuleSetRemoved(listener: (event: { params: Protocol.Preload.RuleSetRemovedEvent }) => void): void;
+        onceRuleSetRemoved(eventMatcher?: (event: { params: Protocol.Preload.RuleSetRemovedEvent }) => boolean): Promise<{ params: Protocol.Preload.RuleSetRemovedEvent }>;
+
+        /**
+         * Fired when a preload enabled state is updated.
+         */
+        onPreloadEnabledStateUpdated(listener: (event: { params: Protocol.Preload.PreloadEnabledStateUpdatedEvent }) => void): void;
+        offPreloadEnabledStateUpdated(listener: (event: { params: Protocol.Preload.PreloadEnabledStateUpdatedEvent }) => void): void;
+        oncePreloadEnabledStateUpdated(eventMatcher?: (event: { params: Protocol.Preload.PreloadEnabledStateUpdatedEvent }) => boolean): Promise<{ params: Protocol.Preload.PreloadEnabledStateUpdatedEvent }>;
+
+        /**
+         * Fired when a prefetch attempt is updated.
+         */
+        onPrefetchStatusUpdated(listener: (event: { params: Protocol.Preload.PrefetchStatusUpdatedEvent }) => void): void;
+        offPrefetchStatusUpdated(listener: (event: { params: Protocol.Preload.PrefetchStatusUpdatedEvent }) => void): void;
+        oncePrefetchStatusUpdated(eventMatcher?: (event: { params: Protocol.Preload.PrefetchStatusUpdatedEvent }) => boolean): Promise<{ params: Protocol.Preload.PrefetchStatusUpdatedEvent }>;
+
+        /**
+         * Fired when a prerender attempt is updated.
+         */
+        onPrerenderStatusUpdated(listener: (event: { params: Protocol.Preload.PrerenderStatusUpdatedEvent }) => void): void;
+        offPrerenderStatusUpdated(listener: (event: { params: Protocol.Preload.PrerenderStatusUpdatedEvent }) => void): void;
+        oncePrerenderStatusUpdated(eventMatcher?: (event: { params: Protocol.Preload.PrerenderStatusUpdatedEvent }) => boolean): Promise<{ params: Protocol.Preload.PrerenderStatusUpdatedEvent }>;
+
+        /**
+         * Send a list of sources for all preloading attempts in a document.
+         */
+        onPreloadingAttemptSourcesUpdated(listener: (event: { params: Protocol.Preload.PreloadingAttemptSourcesUpdatedEvent }) => void): void;
+        offPreloadingAttemptSourcesUpdated(listener: (event: { params: Protocol.Preload.PreloadingAttemptSourcesUpdatedEvent }) => void): void;
+        oncePreloadingAttemptSourcesUpdated(eventMatcher?: (event: { params: Protocol.Preload.PreloadingAttemptSourcesUpdatedEvent }) => boolean): Promise<{ params: Protocol.Preload.PreloadingAttemptSourcesUpdatedEvent }>;
+
+    }
+
+    export interface FedCmApi {
+        enable(params: Protocol.FedCm.EnableRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        selectAccount(params: Protocol.FedCm.SelectAccountRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        clickDialogButton(params: Protocol.FedCm.ClickDialogButtonRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        openUrl(params: Protocol.FedCm.OpenUrlRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        dismissDialog(params: Protocol.FedCm.DismissDialogRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Resets the cooldown time, if any, to allow the next FedCM call to show
+         * a dialog even if one was recently dismissed by the user.
+         */
+        resetCooldown(): Promise<{id: number, result: void, sessionId: string}>;
+
+        onDialogShown(listener: (event: { params: Protocol.FedCm.DialogShownEvent }) => void): void;
+        offDialogShown(listener: (event: { params: Protocol.FedCm.DialogShownEvent }) => void): void;
+        onceDialogShown(eventMatcher?: (event: { params: Protocol.FedCm.DialogShownEvent }) => boolean): Promise<{ params: Protocol.FedCm.DialogShownEvent }>;
+
+        /**
+         * Triggered when a dialog is closed, either by user action, JS abort,
+         * or a command below.
+         */
+        onDialogClosed(listener: (event: { params: Protocol.FedCm.DialogClosedEvent }) => void): void;
+        offDialogClosed(listener: (event: { params: Protocol.FedCm.DialogClosedEvent }) => void): void;
+        onceDialogClosed(eventMatcher?: (event: { params: Protocol.FedCm.DialogClosedEvent }) => boolean): Promise<{ params: Protocol.FedCm.DialogClosedEvent }>;
+
+    }
+
+    export interface PWAApi {
+        /**
+         * Returns the following OS state for the given manifest id.
+         */
+        getOsAppState(params: Protocol.PWA.GetOsAppStateRequest): Promise<{id: number, result: Protocol.PWA.GetOsAppStateResponse, sessionId: string}>;
+
+        /**
+         * Installs the given manifest identity, optionally using the given install_url
+         * or IWA bundle location.
+         * 
+         * TODO(crbug.com/337872319) Support IWA to meet the following specific
+         * requirement.
+         * IWA-specific install description: If the manifest_id is isolated-app://,
+         * install_url_or_bundle_url is required, and can be either an http(s) URL or
+         * file:// URL pointing to a signed web bundle (.swbn). The .swbn file's
+         * signing key must correspond to manifest_id. If Chrome is not in IWA dev
+         * mode, the installation will fail, regardless of the state of the allowlist.
+         */
+        install(params: Protocol.PWA.InstallRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Uninstalls the given manifest_id and closes any opened app windows.
+         */
+        uninstall(params: Protocol.PWA.UninstallRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Launches the installed web app, or an url in the same web app instead of the
+         * default start url if it is provided. Returns a page Target.TargetID which
+         * can be used to attach to via Target.attachToTarget or similar APIs.
+         */
+        launch(params: Protocol.PWA.LaunchRequest): Promise<{id: number, result: Protocol.PWA.LaunchResponse, sessionId: string}>;
+
+        /**
+         * Opens one or more local files from an installed web app identified by its
+         * manifestId. The web app needs to have file handlers registered to process
+         * the files. The API returns one or more page Target.TargetIDs which can be
+         * used to attach to via Target.attachToTarget or similar APIs.
+         * If some files in the parameters cannot be handled by the web app, they will
+         * be ignored. If none of the files can be handled, this API returns an error.
+         * If no files are provided as the parameter, this API also returns an error.
+         * 
+         * According to the definition of the file handlers in the manifest file, one
+         * Target.TargetID may represent a page handling one or more files. The order
+         * of the returned Target.TargetIDs is not guaranteed.
+         * 
+         * TODO(crbug.com/339454034): Check the existences of the input files.
+         */
+        launchFilesInApp(params: Protocol.PWA.LaunchFilesInAppRequest): Promise<{id: number, result: Protocol.PWA.LaunchFilesInAppResponse, sessionId: string}>;
+
+        /**
+         * Opens the current page in its web app identified by the manifest id, needs
+         * to be called on a page target. This function returns immediately without
+         * waiting for the app to finish loading.
+         */
+        openCurrentPageInApp(params: Protocol.PWA.OpenCurrentPageInAppRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Changes user settings of the web app identified by its manifestId. If the
+         * app was not installed, this command returns an error. Unset parameters will
+         * be ignored; unrecognized values will cause an error.
+         * 
+         * Unlike the ones defined in the manifest files of the web apps, these
+         * settings are provided by the browser and controlled by the users, they
+         * impact the way the browser handling the web apps.
+         * 
+         * See the comment of each parameter.
+         */
+        changeAppUserSettings(params: Protocol.PWA.ChangeAppUserSettingsRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+    }
+
+    export interface BluetoothEmulationApi {
+        /**
+         * Enable the BluetoothEmulation domain.
+         */
+        enable(params: Protocol.BluetoothEmulation.EnableRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Disable the BluetoothEmulation domain.
+         */
+        disable(): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Simulates a peripheral with |address|, |name| and |knownServiceUuids|
+         * that has already been connected to the system.
+         */
+        simulatePreconnectedPeripheral(params: Protocol.BluetoothEmulation.SimulatePreconnectedPeripheralRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+        /**
+         * Simulates an advertisement packet described in |entry| being received by
+         * the central.
+         */
+        simulateAdvertisement(params: Protocol.BluetoothEmulation.SimulateAdvertisementRequest): Promise<{id: number, result: void, sessionId: string}>;
+
+    }
+}
+
+export default ProtocolTestsProxyApi;
diff --git a/node_modules/devtools-protocol/types/protocol.d.ts b/node_modules/devtools-protocol/types/protocol.d.ts
index a3d0885..fbef7e6 100644
--- a/node_modules/devtools-protocol/types/protocol.d.ts
+++ b/node_modules/devtools-protocol/types/protocol.d.ts
@@ -151,6 +151,8 @@ export namespace Protocol {
             location: Location;
             /**
              * JavaScript script name or url.
+             * Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
+             * sent `Debugger.scriptParsed` event.
              */
             url: string;
             /**
@@ -165,6 +167,13 @@ export namespace Protocol {
              * The value being returned, if the function is at return point.
              */
             returnValue?: Runtime.RemoteObject;
+            /**
+             * Valid only while the VM is paused and indicates whether this frame
+             * can be restarted or not. Note that a `true` value here does not
+             * guarantee that Debugger#restartFrame with this CallFrameId will be
+             * successful, but it is very likely.
+             */
+            canBeRestarted?: boolean;
         }
 
         export const enum ScopeType {
@@ -244,6 +253,17 @@ export namespace Protocol {
             type?: ('debuggerStatement' | 'call' | 'return');
         }
 
+        export interface WasmDisassemblyChunk {
+            /**
+             * The next chunk of disassembled lines.
+             */
+            lines: string[];
+            /**
+             * The bytecode offsets describing the start of each line.
+             */
+            bytecodeOffsets: integer[];
+        }
+
         /**
          * Enum of possible script languages.
          */
@@ -395,6 +415,45 @@ export namespace Protocol {
             bytecode?: string;
         }
 
+        export interface DisassembleWasmModuleRequest {
+            /**
+             * Id of the script to disassemble
+             */
+            scriptId: Runtime.ScriptId;
+        }
+
+        export interface DisassembleWasmModuleResponse {
+            /**
+             * For large modules, return a stream from which additional chunks of
+             * disassembly can be read successively.
+             */
+            streamId?: string;
+            /**
+             * The total number of lines in the disassembly text.
+             */
+            totalNumberOfLines: integer;
+            /**
+             * The offsets of all function bodies, in the format [start1, end1,
+             * start2, end2, ...] where all ends are exclusive.
+             */
+            functionBodyOffsets: integer[];
+            /**
+             * The first chunk of disassembly.
+             */
+            chunk: WasmDisassemblyChunk;
+        }
+
+        export interface NextWasmDisassemblyChunkRequest {
+            streamId: string;
+        }
+
+        export interface NextWasmDisassemblyChunkResponse {
+            /**
+             * The next chunk of disassembly.
+             */
+            chunk: WasmDisassemblyChunk;
+        }
+
         export interface GetWasmBytecodeRequest {
             /**
              * Id of the Wasm script to get source for.
@@ -428,11 +487,20 @@ export namespace Protocol {
             breakpointId: BreakpointId;
         }
 
+        export const enum RestartFrameRequestMode {
+            StepInto = 'StepInto',
+        }
+
         export interface RestartFrameRequest {
             /**
              * Call frame identifier to evaluate on.
              */
             callFrameId: CallFrameId;
+            /**
+             * The `mode` parameter must be present and set to 'StepInto', otherwise
+             * `restartFrame` will error out. (RestartFrameRequestMode enum)
+             */
+            mode?: ('StepInto');
         }
 
         export interface RestartFrameResponse {
@@ -620,6 +688,7 @@ export namespace Protocol {
 
         export const enum SetPauseOnExceptionsRequestState {
             None = 'none',
+            Caught = 'caught',
             Uncaught = 'uncaught',
             All = 'all',
         }
@@ -628,7 +697,7 @@ export namespace Protocol {
             /**
              * Pause on exceptions mode. (SetPauseOnExceptionsRequestState enum)
              */
-            state: ('none' | 'uncaught' | 'all');
+            state: ('none' | 'caught' | 'uncaught' | 'all');
         }
 
         export interface SetReturnValueRequest {
@@ -638,6 +707,14 @@ export namespace Protocol {
             newValue: Runtime.CallArgument;
         }
 
+        export const enum SetScriptSourceResponseStatus {
+            Ok = 'Ok',
+            CompileError = 'CompileError',
+            BlockedByActiveGenerator = 'BlockedByActiveGenerator',
+            BlockedByActiveFunction = 'BlockedByActiveFunction',
+            BlockedByTopLevelEsModuleChange = 'BlockedByTopLevelEsModuleChange',
+        }
+
         export interface SetScriptSourceRequest {
             /**
              * Id of the script to edit.
@@ -652,6 +729,11 @@ export namespace Protocol {
              * description without actually modifying the code.
              */
             dryRun?: boolean;
+            /**
+             * If true, then `scriptSource` is allowed to change the function on top of the stack
+             * as long as the top-most stack frame is the only activation of that function.
+             */
+            allowTopFrameEditing?: boolean;
         }
 
         export interface SetScriptSourceResponse {
@@ -672,7 +754,13 @@ export namespace Protocol {
              */
             asyncStackTraceId?: Runtime.StackTraceId;
             /**
-             * Exception details if any.
+             * Whether the operation was successful or not. Only `Ok` denotes a
+             * successful live edit while the other enum variants denote why
+             * the live edit failed. (SetScriptSourceResponseStatus enum)
+             */
+            status: ('Ok' | 'CompileError' | 'BlockedByActiveGenerator' | 'BlockedByActiveFunction' | 'BlockedByTopLevelEsModuleChange');
+            /**
+             * Exception details if any. Only present when `status` is `CompileError`.
              */
             exceptionDetails?: Runtime.ExceptionDetails;
         }
@@ -750,6 +838,7 @@ export namespace Protocol {
             Other = 'other',
             PromiseRejection = 'promiseRejection',
             XHR = 'XHR',
+            Step = 'step',
         }
 
         /**
@@ -763,7 +852,7 @@ export namespace Protocol {
             /**
              * Pause reason. (PausedEventReason enum)
              */
-            reason: ('ambiguous' | 'assert' | 'CSPViolation' | 'debugCommand' | 'DOM' | 'EventListener' | 'exception' | 'instrumentation' | 'OOM' | 'other' | 'promiseRejection' | 'XHR');
+            reason: ('ambiguous' | 'assert' | 'CSPViolation' | 'debugCommand' | 'DOM' | 'EventListener' | 'exception' | 'instrumentation' | 'OOM' | 'other' | 'promiseRejection' | 'XHR' | 'step');
             /**
              * Object containing break-specific auxiliary properties.
              */
@@ -819,11 +908,11 @@ export namespace Protocol {
              */
             executionContextId: Runtime.ExecutionContextId;
             /**
-             * Content hash of the script.
+             * Content hash of the script, SHA-256.
              */
             hash: string;
             /**
-             * Embedder-specific auxiliary data.
+             * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
              */
             executionContextAuxData?: any;
             /**
@@ -894,11 +983,11 @@ export namespace Protocol {
              */
             executionContextId: Runtime.ExecutionContextId;
             /**
-             * Content hash of the script.
+             * Content hash of the script, SHA-256.
              */
             hash: string;
             /**
-             * Embedder-specific auxiliary data.
+             * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
              */
             executionContextAuxData?: any;
             /**
@@ -1049,6 +1138,26 @@ export namespace Protocol {
              * default value is 32768 bytes.
              */
             samplingInterval?: number;
+            /**
+             * By default, the sampling heap profiler reports only objects which are
+             * still alive when the profile is returned via getSamplingProfile or
+             * stopSampling, which is useful for determining what functions contribute
+             * the most to steady-state memory usage. This flag instructs the sampling
+             * heap profiler to also include information about objects discarded by
+             * major GC, which will show which functions cause large temporary memory
+             * usage or long GC pauses.
+             */
+            includeObjectsCollectedByMajorGC?: boolean;
+            /**
+             * By default, the sampling heap profiler reports only objects which are
+             * still alive when the profile is returned via getSamplingProfile or
+             * stopSampling, which is useful for determining what functions contribute
+             * the most to steady-state memory usage. This flag instructs the sampling
+             * heap profiler to also include information about objects discarded by
+             * minor GC, which is useful when tuning a latency-sensitive application
+             * for minimal GC activity.
+             */
+            includeObjectsCollectedByMinorGC?: boolean;
         }
 
         export interface StartTrackingHeapObjectsRequest {
@@ -1068,11 +1177,18 @@ export namespace Protocol {
              * when the tracking is stopped.
              */
             reportProgress?: boolean;
+            /**
+             * Deprecated in favor of `exposeInternals`.
+             */
             treatGlobalObjectsAsRoots?: boolean;
             /**
              * If true, numerical values are included in the snapshot
              */
             captureNumericValue?: boolean;
+            /**
+             * If true, exposes internals of the snapshot.
+             */
+            exposeInternals?: boolean;
         }
 
         export interface TakeHeapSnapshotRequest {
@@ -1081,13 +1197,18 @@ export namespace Protocol {
              */
             reportProgress?: boolean;
             /**
-             * If true, a raw snapshot without artificial roots will be generated
+             * If true, a raw snapshot without artificial roots will be generated.
+             * Deprecated in favor of `exposeInternals`.
              */
             treatGlobalObjectsAsRoots?: boolean;
             /**
              * If true, numerical values are included in the snapshot
              */
             captureNumericValue?: boolean;
+            /**
+             * If true, exposes internals of the snapshot.
+             */
+            exposeInternals?: boolean;
         }
 
         export interface AddHeapSnapshotChunkEvent {
@@ -1251,48 +1372,6 @@ export namespace Protocol {
             functions: FunctionCoverage[];
         }
 
-        /**
-         * Describes a type collected during runtime.
-         */
-        export interface TypeObject {
-            /**
-             * Name of a type collected with type profiling.
-             */
-            name: string;
-        }
-
-        /**
-         * Source offset and types for a parameter or return value.
-         */
-        export interface TypeProfileEntry {
-            /**
-             * Source offset of the parameter or end of function for return values.
-             */
-            offset: integer;
-            /**
-             * The types for this parameter or return value.
-             */
-            types: TypeObject[];
-        }
-
-        /**
-         * Type profile data collected during runtime for a JavaScript script.
-         */
-        export interface ScriptTypeProfile {
-            /**
-             * JavaScript script id.
-             */
-            scriptId: Runtime.ScriptId;
-            /**
-             * JavaScript script name or url.
-             */
-            url: string;
-            /**
-             * Type profile entries for parameters and return values of the functions in the script.
-             */
-            entries: TypeProfileEntry[];
-        }
-
         export interface GetBestEffortCoverageResponse {
             /**
              * Coverage data for the current isolate.
@@ -1347,13 +1426,6 @@ export namespace Protocol {
             timestamp: number;
         }
 
-        export interface TakeTypeProfileResponse {
-            /**
-             * Type profile for all scripts since startTypeProfile() was turned on.
-             */
-            result: ScriptTypeProfile[];
-        }
-
         export interface ConsoleProfileFinishedEvent {
             id: string;
             /**
@@ -1418,6 +1490,77 @@ export namespace Protocol {
          */
         export type ScriptId = string;
 
+        export const enum SerializationOptionsSerialization {
+            Deep = 'deep',
+            Json = 'json',
+            IdOnly = 'idOnly',
+        }
+
+        /**
+         * Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
+         */
+        export interface SerializationOptions {
+            /**
+             *  (SerializationOptionsSerialization enum)
+             */
+            serialization: ('deep' | 'json' | 'idOnly');
+            /**
+             * Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.
+             */
+            maxDepth?: integer;
+            /**
+             * Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM
+             * serialization via `maxNodeDepth: integer` and `includeShadowTree: "none" | "open" | "all"`.
+             * Values can be only of type string or integer.
+             */
+            additionalParameters?: any;
+        }
+
+        export const enum DeepSerializedValueType {
+            Undefined = 'undefined',
+            Null = 'null',
+            String = 'string',
+            Number = 'number',
+            Boolean = 'boolean',
+            Bigint = 'bigint',
+            Regexp = 'regexp',
+            Date = 'date',
+            Symbol = 'symbol',
+            Array = 'array',
+            Object = 'object',
+            Function = 'function',
+            Map = 'map',
+            Set = 'set',
+            Weakmap = 'weakmap',
+            Weakset = 'weakset',
+            Error = 'error',
+            Proxy = 'proxy',
+            Promise = 'promise',
+            Typedarray = 'typedarray',
+            Arraybuffer = 'arraybuffer',
+            Node = 'node',
+            Window = 'window',
+            Generator = 'generator',
+        }
+
+        /**
+         * Represents deep serialized value.
+         */
+        export interface DeepSerializedValue {
+            /**
+             *  (DeepSerializedValueType enum)
+             */
+            type: ('undefined' | 'null' | 'string' | 'number' | 'boolean' | 'bigint' | 'regexp' | 'date' | 'symbol' | 'array' | 'object' | 'function' | 'map' | 'set' | 'weakmap' | 'weakset' | 'error' | 'proxy' | 'promise' | 'typedarray' | 'arraybuffer' | 'node' | 'window' | 'generator');
+            value?: any;
+            objectId?: string;
+            /**
+             * Set if value reference met more then once during serialization. In such
+             * case, value is provided only to one of the serialized values. Unique
+             * per value in the scope of one CDP call.
+             */
+            weakLocalObjectReference?: integer;
+        }
+
         /**
          * Unique object identifier.
          */
@@ -1493,6 +1636,10 @@ export namespace Protocol {
              * String representation of the object.
              */
             description?: string;
+            /**
+             * Deep serialized value.
+             */
+            deepSerializedValue?: DeepSerializedValue;
             /**
              * Unique object identifier (for non-primitive values).
              */
@@ -1785,7 +1932,7 @@ export namespace Protocol {
              */
             uniqueId: string;
             /**
-             * Embedder-specific auxiliary data.
+             * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
              */
             auxData?: any;
         }
@@ -1960,6 +2107,7 @@ export namespace Protocol {
             silent?: boolean;
             /**
              * Whether the result is expected to be a JSON object which should be sent by value.
+             * Can be overriden by `serializationOptions`.
              */
             returnByValue?: boolean;
             /**
@@ -1989,6 +2137,20 @@ export namespace Protocol {
              * Whether to throw an exception if side effect cannot be ruled out during evaluation.
              */
             throwOnSideEffect?: boolean;
+            /**
+             * An alternative way to specify the execution context to call function on.
+             * Compared to contextId that may be reused across processes, this is guaranteed to be
+             * system-unique, so it can be used to prevent accidental function call
+             * in context different than intended (e.g. as a result of navigation across process
+             * boundaries).
+             * This is mutually exclusive with `executionContextId`.
+             */
+            uniqueContextId?: string;
+            /**
+             * Specifies the result serialization. If provided, overrides
+             * `generatePreview` and `returnByValue`.
+             */
+            serializationOptions?: SerializationOptions;
         }
 
         export interface CallFunctionOnResponse {
@@ -2111,6 +2273,11 @@ export namespace Protocol {
              * This is mutually exclusive with `contextId`.
              */
             uniqueContextId?: string;
+            /**
+             * Specifies the result serialization. If provided, overrides
+             * `generatePreview` and `returnByValue`.
+             */
+            serializationOptions?: SerializationOptions;
         }
 
         export interface EvaluateResponse {
@@ -2320,6 +2487,17 @@ export namespace Protocol {
             name: string;
         }
 
+        export interface GetExceptionDetailsRequest {
+            /**
+             * The error object for which to resolve the exception details.
+             */
+            errorObjectId: RemoteObjectId;
+        }
+
+        export interface GetExceptionDetailsResponse {
+            exceptionDetails?: ExceptionDetails;
+        }
+
         /**
          * Notification is issued every time when binding is called.
          */
@@ -2430,6 +2608,10 @@ export namespace Protocol {
              * Id of the destroyed context
              */
             executionContextId: ExecutionContextId;
+            /**
+             * Unique Id of the destroyed context
+             */
+            executionContextUniqueId: string;
         }
 
         /**
@@ -2493,7 +2675,7 @@ export namespace Protocol {
         /**
          * Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
          */
-        export type AXValueNativeSourceType = ('figcaption' | 'label' | 'labelfor' | 'labelwrapped' | 'legend' | 'rubyannotation' | 'tablecaption' | 'title' | 'other');
+        export type AXValueNativeSourceType = ('description' | 'figcaption' | 'label' | 'labelfor' | 'labelwrapped' | 'legend' | 'rubyannotation' | 'tablecaption' | 'title' | 'other');
 
         /**
          * A single source for a computed AX property.
@@ -2520,7 +2702,7 @@ export namespace Protocol {
              */
             superseded?: boolean;
             /**
-             * The native markup source for this value, e.g. a <label> element.
+             * The native markup source for this value, e.g. a `<label>` element.
              */
             nativeSource?: AXValueNativeSourceType;
             /**
@@ -2593,7 +2775,7 @@ export namespace Protocol {
          * - from 'checked' to 'selected': states which apply to widgets
          * - from 'activedescendant' to 'owns' - relationships between elements other than parent/child/sibling.
          */
-        export type AXPropertyName = ('busy' | 'disabled' | 'editable' | 'focusable' | 'focused' | 'hidden' | 'hiddenRoot' | 'invalid' | 'keyshortcuts' | 'settable' | 'roledescription' | 'live' | 'atomic' | 'relevant' | 'root' | 'autocomplete' | 'hasPopup' | 'level' | 'multiselectable' | 'orientation' | 'multiline' | 'readonly' | 'required' | 'valuemin' | 'valuemax' | 'valuetext' | 'checked' | 'expanded' | 'modal' | 'pressed' | 'selected' | 'activedescendant' | 'controls' | 'describedby' | 'details' | 'errormessage' | 'flowto' | 'labelledby' | 'owns');
+        export type AXPropertyName = ('busy' | 'disabled' | 'editable' | 'focusable' | 'focused' | 'hidden' | 'hiddenRoot' | 'invalid' | 'keyshortcuts' | 'settable' | 'roledescription' | 'live' | 'atomic' | 'relevant' | 'root' | 'autocomplete' | 'hasPopup' | 'level' | 'multiselectable' | 'orientation' | 'multiline' | 'readonly' | 'required' | 'valuemin' | 'valuemax' | 'valuetext' | 'checked' | 'expanded' | 'modal' | 'pressed' | 'selected' | 'activedescendant' | 'controls' | 'describedby' | 'details' | 'errormessage' | 'flowto' | 'labelledby' | 'owns' | 'url');
 
         /**
          * A node in the accessibility tree.
@@ -2615,6 +2797,10 @@ export namespace Protocol {
              * This `Node`'s role, whether explicit or implicit.
              */
             role?: AXValue;
+            /**
+             * This `Node`'s Chrome raw role.
+             */
+            chromeRole?: AXValue;
             /**
              * The accessible name for this `Node`.
              */
@@ -2631,6 +2817,10 @@ export namespace Protocol {
              * All other properties
              */
             properties?: AXProperty[];
+            /**
+             * ID for this node's parent.
+             */
+            parentId?: AXNodeId;
             /**
              * IDs for each of this node's child nodes.
              */
@@ -2639,6 +2829,10 @@ export namespace Protocol {
              * The backend ID for the associated DOM node, if any.
              */
             backendDOMNodeId?: DOM.BackendNodeId;
+            /**
+             * The frame ID for the frame associated with this nodes document.
+             */
+            frameId?: Page.FrameId;
         }
 
         export interface GetPartialAXTreeRequest {
@@ -2655,7 +2849,7 @@ export namespace Protocol {
              */
             objectId?: Runtime.RemoteObjectId;
             /**
-             * Whether to fetch this nodes ancestors, siblings and children. Defaults to true.
+             * Whether to fetch this node's ancestors, siblings and children. Defaults to true.
              */
             fetchRelatives?: boolean;
         }
@@ -2674,13 +2868,9 @@ export namespace Protocol {
              * If omitted, the full tree is returned.
              */
             depth?: integer;
-            /**
-             * Deprecated. This parameter has been renamed to `depth`. If depth is not provided, max_depth will be used.
-             */
-            max_depth?: integer;
             /**
              * The frame for whose document the AX tree should be retrieved.
-             * If omited, the root frame is used.
+             * If omitted, the root frame is used.
              */
             frameId?: Page.FrameId;
         }
@@ -2689,6 +2879,37 @@ export namespace Protocol {
             nodes: AXNode[];
         }
 
+        export interface GetRootAXNodeRequest {
+            /**
+             * The frame in whose document the node resides.
+             * If omitted, the root frame is used.
+             */
+            frameId?: Page.FrameId;
+        }
+
+        export interface GetRootAXNodeResponse {
+            node: AXNode;
+        }
+
+        export interface GetAXNodeAndAncestorsRequest {
+            /**
+             * Identifier of the node to get.
+             */
+            nodeId?: DOM.NodeId;
+            /**
+             * Identifier of the backend node to get.
+             */
+            backendNodeId?: DOM.BackendNodeId;
+            /**
+             * JavaScript object id of the node wrapper to get.
+             */
+            objectId?: Runtime.RemoteObjectId;
+        }
+
+        export interface GetAXNodeAndAncestorsResponse {
+            nodes: AXNode[];
+        }
+
         export interface GetChildAXNodesRequest {
             id: AXNodeId;
             /**
@@ -2732,6 +2953,27 @@ export namespace Protocol {
              */
             nodes: AXNode[];
         }
+
+        /**
+         * The loadComplete event mirrors the load complete event sent by the browser to assistive
+         * technology when the web page has finished loading.
+         */
+        export interface LoadCompleteEvent {
+            /**
+             * New document root node.
+             */
+            root: AXNode;
+        }
+
+        /**
+         * The nodesUpdated event is sent every time a previously requested node has changed the in tree.
+         */
+        export interface NodesUpdatedEvent {
+            /**
+             * Updated node data.
+             */
+            nodes: AXNode[];
+        }
     }
 
     export namespace Animation {
@@ -2768,6 +3010,9 @@ export namespace Protocol {
             playbackRate: number;
             /**
              * `Animation`'s start time.
+             * Milliseconds for time based animations and
+             * percentage [0 - 100] for scroll driven animations
+             * (i.e. when viewOrScrollTimeline exists).
              */
             startTime: number;
             /**
@@ -2787,6 +3032,40 @@ export namespace Protocol {
              * animation/transition.
              */
             cssId?: string;
+            /**
+             * View or scroll timeline
+             */
+            viewOrScrollTimeline?: ViewOrScrollTimeline;
+        }
+
+        /**
+         * Timeline instance
+         */
+        export interface ViewOrScrollTimeline {
+            /**
+             * Scroll container node
+             */
+            sourceNodeId?: DOM.BackendNodeId;
+            /**
+             * Represents the starting scroll position of the timeline
+             * as a length offset in pixels from scroll origin.
+             */
+            startOffset?: number;
+            /**
+             * Represents the ending scroll position of the timeline
+             * as a length offset in pixels from scroll origin.
+             */
+            endOffset?: number;
+            /**
+             * The element whose principal box's visibility in the
+             * scrollport defined the progress of the timeline.
+             * Does not exist for animations with ScrollTimeline
+             */
+            subjectNodeId?: DOM.BackendNodeId;
+            /**
+             * Orientation of the scroll
+             */
+            axis: DOM.ScrollOrientation;
         }
 
         /**
@@ -2811,6 +3090,9 @@ export namespace Protocol {
             iterations: number;
             /**
              * `AnimationEffect`'s iteration duration.
+             * Milliseconds for time based animations and
+             * percentage [0 - 100] for scroll driven animations
+             * (i.e. when viewOrScrollTimeline exists).
              */
             duration: number;
             /**
@@ -2978,178 +3260,65 @@ export namespace Protocol {
              */
             animation: Animation;
         }
+
+        /**
+         * Event for animation that has been updated.
+         */
+        export interface AnimationUpdatedEvent {
+            /**
+             * Animation that was updated.
+             */
+            animation: Animation;
+        }
     }
 
     /**
-     * The domain is deprecated as AppCache is being removed (see crbug.com/582750).
+     * Audits domain allows investigation of page violations and possible improvements.
      */
-    export namespace ApplicationCache {
+    export namespace Audits {
 
         /**
-         * Detailed application cache resource information.
+         * Information about a cookie that is affected by an inspector issue.
          */
-        export interface ApplicationCacheResource {
-            /**
-             * Resource url.
-             */
-            url: string;
-            /**
-             * Resource size.
-             */
-            size: integer;
+        export interface AffectedCookie {
             /**
-             * Resource type.
+             * The following three properties uniquely identify a cookie
              */
-            type: string;
+            name: string;
+            path: string;
+            domain: string;
         }
 
         /**
-         * Detailed application cache information.
+         * Information about a request that is affected by an inspector issue.
          */
-        export interface ApplicationCache {
-            /**
-             * Manifest URL.
-             */
-            manifestURL: string;
-            /**
-             * Application cache size.
-             */
-            size: number;
-            /**
-             * Application cache creation time.
-             */
-            creationTime: number;
-            /**
-             * Application cache update time.
-             */
-            updateTime: number;
+        export interface AffectedRequest {
             /**
-             * Application cache resources.
+             * The unique request id.
              */
-            resources: ApplicationCacheResource[];
+            requestId: Network.RequestId;
+            url?: string;
         }
 
         /**
-         * Frame identifier - manifest URL pair.
+         * Information about the frame affected by an inspector issue.
          */
-        export interface FrameWithManifest {
-            /**
-             * Frame identifier.
-             */
-            frameId: Page.FrameId;
-            /**
-             * Manifest URL.
-             */
-            manifestURL: string;
-            /**
-             * Application cache status.
-             */
-            status: integer;
-        }
-
-        export interface GetApplicationCacheForFrameRequest {
-            /**
-             * Identifier of the frame containing document whose application cache is retrieved.
-             */
-            frameId: Page.FrameId;
-        }
-
-        export interface GetApplicationCacheForFrameResponse {
-            /**
-             * Relevant application cache data for the document in given frame.
-             */
-            applicationCache: ApplicationCache;
-        }
-
-        export interface GetFramesWithManifestsResponse {
-            /**
-             * Array of frame identifiers with manifest urls for each frame containing a document
-             * associated with some application cache.
-             */
-            frameIds: FrameWithManifest[];
-        }
-
-        export interface GetManifestForFrameRequest {
-            /**
-             * Identifier of the frame containing document whose manifest is retrieved.
-             */
-            frameId: Page.FrameId;
-        }
-
-        export interface GetManifestForFrameResponse {
-            /**
-             * Manifest URL for document in the given frame.
-             */
-            manifestURL: string;
-        }
-
-        export interface ApplicationCacheStatusUpdatedEvent {
-            /**
-             * Identifier of the frame containing document whose application cache updated status.
-             */
-            frameId: Page.FrameId;
-            /**
-             * Manifest URL.
-             */
-            manifestURL: string;
-            /**
-             * Updated application cache status.
-             */
-            status: integer;
-        }
-
-        export interface NetworkStateUpdatedEvent {
-            isNowOnline: boolean;
-        }
-    }
-
-    /**
-     * Audits domain allows investigation of page violations and possible improvements.
-     */
-    export namespace Audits {
-
-        /**
-         * Information about a cookie that is affected by an inspector issue.
-         */
-        export interface AffectedCookie {
-            /**
-             * The following three properties uniquely identify a cookie
-             */
-            name: string;
-            path: string;
-            domain: string;
-        }
-
-        /**
-         * Information about a request that is affected by an inspector issue.
-         */
-        export interface AffectedRequest {
-            /**
-             * The unique request id.
-             */
-            requestId: Network.RequestId;
-            url?: string;
-        }
-
-        /**
-         * Information about the frame affected by an inspector issue.
-         */
-        export interface AffectedFrame {
+        export interface AffectedFrame {
             frameId: Page.FrameId;
         }
 
-        export type SameSiteCookieExclusionReason = ('ExcludeSameSiteUnspecifiedTreatedAsLax' | 'ExcludeSameSiteNoneInsecure' | 'ExcludeSameSiteLax' | 'ExcludeSameSiteStrict' | 'ExcludeInvalidSameParty' | 'ExcludeSamePartyCrossPartyContext');
+        export type CookieExclusionReason = ('ExcludeSameSiteUnspecifiedTreatedAsLax' | 'ExcludeSameSiteNoneInsecure' | 'ExcludeSameSiteLax' | 'ExcludeSameSiteStrict' | 'ExcludeInvalidSameParty' | 'ExcludeSamePartyCrossPartyContext' | 'ExcludeDomainNonASCII' | 'ExcludeThirdPartyCookieBlockedInFirstPartySet' | 'ExcludeThirdPartyPhaseout');
 
-        export type SameSiteCookieWarningReason = ('WarnSameSiteUnspecifiedCrossSiteContext' | 'WarnSameSiteNoneInsecure' | 'WarnSameSiteUnspecifiedLaxAllowUnsafe' | 'WarnSameSiteStrictLaxDowngradeStrict' | 'WarnSameSiteStrictCrossDowngradeStrict' | 'WarnSameSiteStrictCrossDowngradeLax' | 'WarnSameSiteLaxCrossDowngradeStrict' | 'WarnSameSiteLaxCrossDowngradeLax');
+        export type CookieWarningReason = ('WarnSameSiteUnspecifiedCrossSiteContext' | 'WarnSameSiteNoneInsecure' | 'WarnSameSiteUnspecifiedLaxAllowUnsafe' | 'WarnSameSiteStrictLaxDowngradeStrict' | 'WarnSameSiteStrictCrossDowngradeStrict' | 'WarnSameSiteStrictCrossDowngradeLax' | 'WarnSameSiteLaxCrossDowngradeStrict' | 'WarnSameSiteLaxCrossDowngradeLax' | 'WarnAttributeValueExceedsMaxSize' | 'WarnDomainNonASCII' | 'WarnThirdPartyPhaseout' | 'WarnCrossSiteRedirectDowngradeChangesInclusion');
 
-        export type SameSiteCookieOperation = ('SetCookie' | 'ReadCookie');
+        export type CookieOperation = ('SetCookie' | 'ReadCookie');
 
         /**
          * This information is currently necessary, as the front-end has a difficult
          * time finding a specific cookie. With this, we can convey specific error
          * information without the cookie.
          */
-        export interface SameSiteCookieIssueDetails {
+        export interface CookieIssueDetails {
             /**
              * If AffectedCookie is not set then rawCookieLine contains the raw
              * Set-Cookie header string. This hints at a problem where the
@@ -3158,13 +3327,13 @@ export namespace Protocol {
              */
             cookie?: AffectedCookie;
             rawCookieLine?: string;
-            cookieWarningReasons: SameSiteCookieWarningReason[];
-            cookieExclusionReasons: SameSiteCookieExclusionReason[];
+            cookieWarningReasons: CookieWarningReason[];
+            cookieExclusionReasons: CookieExclusionReason[];
             /**
              * Optionally identifies the site-for-cookies and the cookie url, which
              * may be used by the front-end as additional context.
              */
-            operation: SameSiteCookieOperation;
+            operation: CookieOperation;
             siteForCookies?: string;
             cookieUrl?: string;
             request?: AffectedRequest;
@@ -3172,7 +3341,7 @@ export namespace Protocol {
 
         export type MixedContentResolutionStatus = ('MixedContentBlocked' | 'MixedContentAutomaticallyUpgraded' | 'MixedContentWarning');
 
-        export type MixedContentResourceType = ('Audio' | 'Beacon' | 'CSPReport' | 'Download' | 'EventSource' | 'Favicon' | 'Font' | 'Form' | 'Frame' | 'Image' | 'Import' | 'Manifest' | 'Ping' | 'PluginData' | 'PluginResource' | 'Prefetch' | 'Resource' | 'Script' | 'ServiceWorker' | 'SharedWorker' | 'Stylesheet' | 'Track' | 'Video' | 'Worker' | 'XMLHttpRequest' | 'XSLT');
+        export type MixedContentResourceType = ('AttributionSrc' | 'Audio' | 'Beacon' | 'CSPReport' | 'Download' | 'EventSource' | 'Favicon' | 'Font' | 'Form' | 'Frame' | 'Image' | 'Import' | 'JSON' | 'Manifest' | 'Ping' | 'PluginData' | 'PluginResource' | 'Prefetch' | 'Resource' | 'Script' | 'ServiceWorker' | 'SharedWorker' | 'SpeculationRules' | 'Stylesheet' | 'Track' | 'Video' | 'Worker' | 'XMLHttpRequest' | 'XSLT');
 
         export interface MixedContentIssueDetails {
             /**
@@ -3209,7 +3378,7 @@ export namespace Protocol {
          * Enum indicating the reason a response has been blocked. These reasons are
          * refinements of the net error BLOCKED_BY_RESPONSE.
          */
-        export type BlockedByResponseReason = ('CoepFrameResourceNeedsCoepHeader' | 'CoopSandboxedIFrameCannotNavigateToCoopPage' | 'CorpNotSameOrigin' | 'CorpNotSameOriginAfterDefaultedToSameOriginByCoep' | 'CorpNotSameSite');
+        export type BlockedByResponseReason = ('CoepFrameResourceNeedsCoepHeader' | 'CoopSandboxedIFrameCannotNavigateToCoopPage' | 'CorpNotSameOrigin' | 'CorpNotSameOriginAfterDefaultedToSameOriginByCoep' | 'CorpNotSameOriginAfterDefaultedToSameOriginByDip' | 'CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip' | 'CorpNotSameSite');
 
         /**
          * Details for a request that has been blocked with the BLOCKED_BY_RESPONSE
@@ -3242,7 +3411,7 @@ export namespace Protocol {
             frame: AffectedFrame;
         }
 
-        export type ContentSecurityPolicyViolationType = ('kInlineViolation' | 'kEvalViolation' | 'kURLViolation' | 'kTrustedTypesSinkViolation' | 'kTrustedTypesPolicyViolation');
+        export type ContentSecurityPolicyViolationType = ('kInlineViolation' | 'kEvalViolation' | 'kURLViolation' | 'kTrustedTypesSinkViolation' | 'kTrustedTypesPolicyViolation' | 'kWasmEvalViolation');
 
         export interface SourceCodeLocation {
             scriptId?: Runtime.ScriptId;
@@ -3279,27 +3448,6 @@ export namespace Protocol {
             type: SharedArrayBufferIssueType;
         }
 
-        export type TwaQualityEnforcementViolationType = ('kHttpError' | 'kUnavailableOffline' | 'kDigitalAssetLinks');
-
-        export interface TrustedWebActivityIssueDetails {
-            /**
-             * The url that triggers the violation.
-             */
-            url: string;
-            violationType: TwaQualityEnforcementViolationType;
-            httpStatusCode?: integer;
-            /**
-             * The package name of the Trusted Web Activity client app. This field is
-             * only used when violation type is kDigitalAssetLinks.
-             */
-            packageName?: string;
-            /**
-             * The signature of the Trusted Web Activity client app. This field is only
-             * used when violation type is kDigitalAssetLinks.
-             */
-            signature?: string;
-        }
-
         export interface LowTextContrastIssueDetails {
             violatingNodeId: DOM.BackendNodeId;
             violatingNodeSelector: string;
@@ -3324,15 +3472,16 @@ export namespace Protocol {
             clientSecurityState?: Network.ClientSecurityState;
         }
 
-        export type AttributionReportingIssueType = ('PermissionPolicyDisabled' | 'InvalidAttributionSourceEventId' | 'InvalidAttributionData' | 'AttributionSourceUntrustworthyOrigin' | 'AttributionUntrustworthyOrigin' | 'AttributionTriggerDataTooLarge' | 'AttributionEventSourceTriggerDataTooLarge');
+        export type AttributionReportingIssueType = ('PermissionPolicyDisabled' | 'UntrustworthyReportingOrigin' | 'InsecureContext' | 'InvalidHeader' | 'InvalidRegisterTriggerHeader' | 'SourceAndTriggerHeaders' | 'SourceIgnored' | 'TriggerIgnored' | 'OsSourceIgnored' | 'OsTriggerIgnored' | 'InvalidRegisterOsSourceHeader' | 'InvalidRegisterOsTriggerHeader' | 'WebAndOsHeaders' | 'NoWebOrOsSupport' | 'NavigationRegistrationWithoutTransientUserActivation' | 'InvalidInfoHeader' | 'NoRegisterSourceHeader' | 'NoRegisterTriggerHeader' | 'NoRegisterOsSourceHeader' | 'NoRegisterOsTriggerHeader');
+
+        export type SharedDictionaryError = ('UseErrorCrossOriginNoCorsRequest' | 'UseErrorDictionaryLoadFailure' | 'UseErrorMatchingDictionaryNotUsed' | 'UseErrorUnexpectedContentDictionaryHeader' | 'WriteErrorCossOriginNoCorsRequest' | 'WriteErrorDisallowedBySettings' | 'WriteErrorExpiredResponse' | 'WriteErrorFeatureDisabled' | 'WriteErrorInsufficientResources' | 'WriteErrorInvalidMatchField' | 'WriteErrorInvalidStructuredHeader' | 'WriteErrorNavigationRequest' | 'WriteErrorNoMatchField' | 'WriteErrorNonListMatchDestField' | 'WriteErrorNonSecureContext' | 'WriteErrorNonStringIdField' | 'WriteErrorNonStringInMatchDestList' | 'WriteErrorNonStringMatchField' | 'WriteErrorNonTokenTypeField' | 'WriteErrorRequestAborted' | 'WriteErrorShuttingDown' | 'WriteErrorTooLongIdField' | 'WriteErrorUnsupportedType');
 
         /**
          * Details for issues around "Attribution Reporting API" usage.
-         * Explainer: https://github.com/WICG/conversion-measurement-api
+         * Explainer: https://github.com/WICG/attribution-reporting-api
          */
         export interface AttributionReportingIssueDetails {
             violationType: AttributionReportingIssueType;
-            frame?: AffectedFrame;
             request?: AffectedRequest;
             violatingNodeId?: DOM.BackendNodeId;
             invalidParameter?: string;
@@ -3359,14 +3508,12 @@ export namespace Protocol {
             location?: SourceCodeLocation;
         }
 
-        export interface WasmCrossOriginModuleSharingIssueDetails {
-            wasmModuleUrl: string;
-            sourceOrigin: string;
-            targetOrigin: string;
-            isWarning: boolean;
+        export interface SharedDictionaryIssueDetails {
+            sharedDictionaryError: SharedDictionaryError;
+            request: AffectedRequest;
         }
 
-        export type GenericIssueErrorType = ('CrossOriginPortalPostMessageError');
+        export type GenericIssueErrorType = ('FormLabelForNameError' | 'FormDuplicateIdForInputError' | 'FormInputWithNoLabelError' | 'FormAutocompleteAttributeEmptyError' | 'FormEmptyIdAndNameAttributesForInputError' | 'FormAriaLabelledByToNonExistingId' | 'FormInputAssignedAutocompleteValueToIdOrNameAttributeError' | 'FormLabelHasNeitherForNorNestedInput' | 'FormLabelForMatchesNonExistingIdError' | 'FormInputHasWrongButWellIntendedAutocompleteValueError' | 'ResponseWasBlockedByORB');
 
         /**
          * Depending on the concrete errorType, different properties are set.
@@ -3377,6 +3524,134 @@ export namespace Protocol {
              */
             errorType: GenericIssueErrorType;
             frameId?: Page.FrameId;
+            violatingNodeId?: DOM.BackendNodeId;
+            violatingNodeAttribute?: string;
+            request?: AffectedRequest;
+        }
+
+        /**
+         * This issue tracks information needed to print a deprecation message.
+         * https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/third_party/blink/renderer/core/frame/deprecation/README.md
+         */
+        export interface DeprecationIssueDetails {
+            affectedFrame?: AffectedFrame;
+            sourceCodeLocation: SourceCodeLocation;
+            /**
+             * One of the deprecation names from third_party/blink/renderer/core/frame/deprecation/deprecation.json5
+             */
+            type: string;
+        }
+
+        /**
+         * This issue warns about sites in the redirect chain of a finished navigation
+         * that may be flagged as trackers and have their state cleared if they don't
+         * receive a user interaction. Note that in this context 'site' means eTLD+1.
+         * For example, if the URL `https://example.test:80/bounce` was in the
+         * redirect chain, the site reported would be `example.test`.
+         */
+        export interface BounceTrackingIssueDetails {
+            trackingSites: string[];
+        }
+
+        /**
+         * This issue warns about third-party sites that are accessing cookies on the
+         * current page, and have been permitted due to having a global metadata grant.
+         * Note that in this context 'site' means eTLD+1. For example, if the URL
+         * `https://example.test:80/web_page` was accessing cookies, the site reported
+         * would be `example.test`.
+         */
+        export interface CookieDeprecationMetadataIssueDetails {
+            allowedSites: string[];
+            optOutPercentage: number;
+            isOptOutTopLevel: boolean;
+            operation: CookieOperation;
+        }
+
+        export type ClientHintIssueReason = ('MetaTagAllowListInvalidOrigin' | 'MetaTagModifiedHTML');
+
+        export interface FederatedAuthRequestIssueDetails {
+            federatedAuthRequestIssueReason: FederatedAuthRequestIssueReason;
+        }
+
+        /**
+         * Represents the failure reason when a federated authentication reason fails.
+         * Should be updated alongside RequestIdTokenStatus in
+         * third_party/blink/public/mojom/devtools/inspector_issue.mojom to include
+         * all cases except for success.
+         */
+        export type FederatedAuthRequestIssueReason = ('ShouldEmbargo' | 'TooManyRequests' | 'WellKnownHttpNotFound' | 'WellKnownNoResponse' | 'WellKnownInvalidResponse' | 'WellKnownListEmpty' | 'WellKnownInvalidContentType' | 'ConfigNotInWellKnown' | 'WellKnownTooBig' | 'ConfigHttpNotFound' | 'ConfigNoResponse' | 'ConfigInvalidResponse' | 'ConfigInvalidContentType' | 'ClientMetadataHttpNotFound' | 'ClientMetadataNoResponse' | 'ClientMetadataInvalidResponse' | 'ClientMetadataInvalidContentType' | 'IdpNotPotentiallyTrustworthy' | 'DisabledInSettings' | 'DisabledInFlags' | 'ErrorFetchingSignin' | 'InvalidSigninResponse' | 'AccountsHttpNotFound' | 'AccountsNoResponse' | 'AccountsInvalidResponse' | 'AccountsListEmpty' | 'AccountsInvalidContentType' | 'IdTokenHttpNotFound' | 'IdTokenNoResponse' | 'IdTokenInvalidResponse' | 'IdTokenIdpErrorResponse' | 'IdTokenCrossSiteIdpErrorResponse' | 'IdTokenInvalidRequest' | 'IdTokenInvalidContentType' | 'ErrorIdToken' | 'Canceled' | 'RpPageNotVisible' | 'SilentMediationFailure' | 'ThirdPartyCookiesBlocked' | 'NotSignedInWithIdp' | 'MissingTransientUserActivation' | 'ReplacedByButtonMode' | 'InvalidFieldsSpecified' | 'RelyingPartyOriginIsOpaque' | 'TypeNotMatching');
+
+        export interface FederatedAuthUserInfoRequestIssueDetails {
+            federatedAuthUserInfoRequestIssueReason: FederatedAuthUserInfoRequestIssueReason;
+        }
+
+        /**
+         * Represents the failure reason when a getUserInfo() call fails.
+         * Should be updated alongside FederatedAuthUserInfoRequestResult in
+         * third_party/blink/public/mojom/devtools/inspector_issue.mojom.
+         */
+        export type FederatedAuthUserInfoRequestIssueReason = ('NotSameOrigin' | 'NotIframe' | 'NotPotentiallyTrustworthy' | 'NoApiPermission' | 'NotSignedInWithIdp' | 'NoAccountSharingPermission' | 'InvalidConfigOrWellKnown' | 'InvalidAccountsResponse' | 'NoReturningUserFromFetchedAccounts');
+
+        /**
+         * This issue tracks client hints related issues. It's used to deprecate old
+         * features, encourage the use of new ones, and provide general guidance.
+         */
+        export interface ClientHintIssueDetails {
+            sourceCodeLocation: SourceCodeLocation;
+            clientHintIssueReason: ClientHintIssueReason;
+        }
+
+        export interface FailedRequestInfo {
+            /**
+             * The URL that failed to load.
+             */
+            url: string;
+            /**
+             * The failure message for the failed request.
+             */
+            failureMessage: string;
+            requestId?: Network.RequestId;
+        }
+
+        export type StyleSheetLoadingIssueReason = ('LateImportRule' | 'RequestFailed');
+
+        /**
+         * This issue warns when a referenced stylesheet couldn't be loaded.
+         */
+        export interface StylesheetLoadingIssueDetails {
+            /**
+             * Source code position that referenced the failing stylesheet.
+             */
+            sourceCodeLocation: SourceCodeLocation;
+            /**
+             * Reason why the stylesheet couldn't be loaded.
+             */
+            styleSheetLoadingIssueReason: StyleSheetLoadingIssueReason;
+            /**
+             * Contains additional info when the failure was due to a request.
+             */
+            failedRequestInfo?: FailedRequestInfo;
+        }
+
+        export type PropertyRuleIssueReason = ('InvalidSyntax' | 'InvalidInitialValue' | 'InvalidInherits' | 'InvalidName');
+
+        /**
+         * This issue warns about errors in property rules that lead to property
+         * registrations being ignored.
+         */
+        export interface PropertyRuleIssueDetails {
+            /**
+             * Source code position of the property rule.
+             */
+            sourceCodeLocation: SourceCodeLocation;
+            /**
+             * Reason why the property rule was discarded.
+             */
+            propertyRuleIssueReason: PropertyRuleIssueReason;
+            /**
+             * The value of the property rule property that failed to parse
+             */
+            propertyValue?: string;
         }
 
         /**
@@ -3384,7 +3659,7 @@ export namespace Protocol {
          * optional fields in InspectorIssueDetails to convey more specific
          * information about the kind of issue.
          */
-        export type InspectorIssueCode = ('SameSiteCookieIssue' | 'MixedContentIssue' | 'BlockedByResponseIssue' | 'HeavyAdIssue' | 'ContentSecurityPolicyIssue' | 'SharedArrayBufferIssue' | 'TrustedWebActivityIssue' | 'LowTextContrastIssue' | 'CorsIssue' | 'AttributionReportingIssue' | 'QuirksModeIssue' | 'NavigatorUserAgentIssue' | 'WasmCrossOriginModuleSharingIssue' | 'GenericIssue');
+        export type InspectorIssueCode = ('CookieIssue' | 'MixedContentIssue' | 'BlockedByResponseIssue' | 'HeavyAdIssue' | 'ContentSecurityPolicyIssue' | 'SharedArrayBufferIssue' | 'LowTextContrastIssue' | 'CorsIssue' | 'AttributionReportingIssue' | 'QuirksModeIssue' | 'NavigatorUserAgentIssue' | 'GenericIssue' | 'DeprecationIssue' | 'ClientHintIssue' | 'FederatedAuthRequestIssue' | 'BounceTrackingIssue' | 'CookieDeprecationMetadataIssue' | 'StylesheetLoadingIssue' | 'FederatedAuthUserInfoRequestIssue' | 'PropertyRuleIssue' | 'SharedDictionaryIssue');
 
         /**
          * This struct holds a list of optional fields with additional information
@@ -3392,20 +3667,27 @@ export namespace Protocol {
          * add a new optional field to this type.
          */
         export interface InspectorIssueDetails {
-            sameSiteCookieIssueDetails?: SameSiteCookieIssueDetails;
+            cookieIssueDetails?: CookieIssueDetails;
             mixedContentIssueDetails?: MixedContentIssueDetails;
             blockedByResponseIssueDetails?: BlockedByResponseIssueDetails;
             heavyAdIssueDetails?: HeavyAdIssueDetails;
             contentSecurityPolicyIssueDetails?: ContentSecurityPolicyIssueDetails;
             sharedArrayBufferIssueDetails?: SharedArrayBufferIssueDetails;
-            twaQualityEnforcementDetails?: TrustedWebActivityIssueDetails;
             lowTextContrastIssueDetails?: LowTextContrastIssueDetails;
             corsIssueDetails?: CorsIssueDetails;
             attributionReportingIssueDetails?: AttributionReportingIssueDetails;
             quirksModeIssueDetails?: QuirksModeIssueDetails;
             navigatorUserAgentIssueDetails?: NavigatorUserAgentIssueDetails;
-            wasmCrossOriginModuleSharingIssue?: WasmCrossOriginModuleSharingIssueDetails;
             genericIssueDetails?: GenericIssueDetails;
+            deprecationIssueDetails?: DeprecationIssueDetails;
+            clientHintIssueDetails?: ClientHintIssueDetails;
+            federatedAuthRequestIssueDetails?: FederatedAuthRequestIssueDetails;
+            bounceTrackingIssueDetails?: BounceTrackingIssueDetails;
+            cookieDeprecationMetadataIssueDetails?: CookieDeprecationMetadataIssueDetails;
+            stylesheetLoadingIssueDetails?: StylesheetLoadingIssueDetails;
+            propertyRuleIssueDetails?: PropertyRuleIssueDetails;
+            federatedAuthUserInfoRequestIssueDetails?: FederatedAuthUserInfoRequestIssueDetails;
+            sharedDictionaryIssueDetails?: SharedDictionaryIssueDetails;
         }
 
         /**
@@ -3474,100 +3756,337 @@ export namespace Protocol {
             reportAAA?: boolean;
         }
 
+        export interface CheckFormsIssuesResponse {
+            formIssues: GenericIssueDetails[];
+        }
+
         export interface IssueAddedEvent {
             issue: InspectorIssue;
         }
     }
 
     /**
-     * Defines events for background web platform features.
+     * Defines commands and events for browser extensions.
      */
-    export namespace BackgroundService {
+    export namespace Extensions {
 
         /**
-         * The Background Service that will be associated with the commands/events.
-         * Every Background Service operates independently, but they share the same
-         * API.
+         * Storage areas.
          */
-        export type ServiceName = ('backgroundFetch' | 'backgroundSync' | 'pushMessaging' | 'notifications' | 'paymentHandler' | 'periodicBackgroundSync');
+        export type StorageArea = ('session' | 'local' | 'sync' | 'managed');
 
-        /**
-         * A key-value pair for additional event information to pass along.
-         */
-        export interface EventMetadata {
-            key: string;
-            value: string;
+        export interface LoadUnpackedRequest {
+            /**
+             * Absolute file path.
+             */
+            path: string;
         }
 
-        export interface BackgroundServiceEvent {
+        export interface LoadUnpackedResponse {
             /**
-             * Timestamp of the event (in seconds).
+             * Extension id.
              */
-            timestamp: Network.TimeSinceEpoch;
+            id: string;
+        }
+
+        export interface GetStorageItemsRequest {
             /**
-             * The origin this event belongs to.
+             * ID of extension.
              */
-            origin: string;
+            id: string;
             /**
-             * The Service Worker ID that initiated the event.
+             * StorageArea to retrieve data from.
              */
-            serviceWorkerRegistrationId: ServiceWorker.RegistrationID;
+            storageArea: StorageArea;
             /**
-             * The Background Service this event belongs to.
+             * Keys to retrieve.
              */
-            service: ServiceName;
+            keys?: string[];
+        }
+
+        export interface GetStorageItemsResponse {
+            data: any;
+        }
+
+        export interface RemoveStorageItemsRequest {
             /**
-             * A description of the event.
+             * ID of extension.
              */
-            eventName: string;
+            id: string;
             /**
-             * An identifier that groups related events together.
+             * StorageArea to remove data from.
              */
-            instanceId: string;
+            storageArea: StorageArea;
             /**
-             * A list of event-specific information.
+             * Keys to remove.
              */
-            eventMetadata: EventMetadata[];
+            keys: string[];
         }
 
-        export interface StartObservingRequest {
-            service: ServiceName;
+        export interface ClearStorageItemsRequest {
+            /**
+             * ID of extension.
+             */
+            id: string;
+            /**
+             * StorageArea to remove data from.
+             */
+            storageArea: StorageArea;
         }
 
-        export interface StopObservingRequest {
-            service: ServiceName;
+        export interface SetStorageItemsRequest {
+            /**
+             * ID of extension.
+             */
+            id: string;
+            /**
+             * StorageArea to set data in.
+             */
+            storageArea: StorageArea;
+            /**
+             * Values to set.
+             */
+            values: any;
         }
+    }
 
-        export interface SetRecordingRequest {
-            shouldRecord: boolean;
-            service: ServiceName;
+    /**
+     * Defines commands and events for Autofill.
+     */
+    export namespace Autofill {
+
+        export interface CreditCard {
+            /**
+             * 16-digit credit card number.
+             */
+            number: string;
+            /**
+             * Name of the credit card owner.
+             */
+            name: string;
+            /**
+             * 2-digit expiry month.
+             */
+            expiryMonth: string;
+            /**
+             * 4-digit expiry year.
+             */
+            expiryYear: string;
+            /**
+             * 3-digit card verification code.
+             */
+            cvc: string;
         }
 
-        export interface ClearEventsRequest {
-            service: ServiceName;
+        export interface AddressField {
+            /**
+             * address field name, for example GIVEN_NAME.
+             */
+            name: string;
+            /**
+             * address field value, for example Jon Doe.
+             */
+            value: string;
         }
 
         /**
-         * Called when the recording state for the service has been updated.
+         * A list of address fields.
          */
-        export interface RecordingStateChangedEvent {
-            isRecording: boolean;
-            service: ServiceName;
+        export interface AddressFields {
+            fields: AddressField[];
+        }
+
+        export interface Address {
+            /**
+             * fields and values defining an address.
+             */
+            fields: AddressField[];
         }
 
         /**
-         * Called with all existing backgroundServiceEvents when enabled, and all new
-         * events afterwards if enabled and recording.
+         * Defines how an address can be displayed like in chrome://settings/addresses.
+         * Address UI is a two dimensional array, each inner array is an "address information line", and when rendered in a UI surface should be displayed as such.
+         * The following address UI for instance:
+         * [[{name: "GIVE_NAME", value: "Jon"}, {name: "FAMILY_NAME", value: "Doe"}], [{name: "CITY", value: "Munich"}, {name: "ZIP", value: "81456"}]]
+         * should allow the receiver to render:
+         * Jon Doe
+         * Munich 81456
          */
-        export interface BackgroundServiceEventReceivedEvent {
-            backgroundServiceEvent: BackgroundServiceEvent;
+        export interface AddressUI {
+            /**
+             * A two dimension array containing the representation of values from an address profile.
+             */
+            addressFields: AddressFields[];
         }
-    }
 
-    /**
-     * The Browser domain defines methods and events for browser managing.
-     */
-    export namespace Browser {
+        /**
+         * Specified whether a filled field was done so by using the html autocomplete attribute or autofill heuristics.
+         */
+        export type FillingStrategy = ('autocompleteAttribute' | 'autofillInferred');
+
+        export interface FilledField {
+            /**
+             * The type of the field, e.g text, password etc.
+             */
+            htmlType: string;
+            /**
+             * the html id
+             */
+            id: string;
+            /**
+             * the html name
+             */
+            name: string;
+            /**
+             * the field value
+             */
+            value: string;
+            /**
+             * The actual field type, e.g FAMILY_NAME
+             */
+            autofillType: string;
+            /**
+             * The filling strategy
+             */
+            fillingStrategy: FillingStrategy;
+            /**
+             * The frame the field belongs to
+             */
+            frameId: Page.FrameId;
+            /**
+             * The form field's DOM node
+             */
+            fieldId: DOM.BackendNodeId;
+        }
+
+        export interface TriggerRequest {
+            /**
+             * Identifies a field that serves as an anchor for autofill.
+             */
+            fieldId: DOM.BackendNodeId;
+            /**
+             * Identifies the frame that field belongs to.
+             */
+            frameId?: Page.FrameId;
+            /**
+             * Credit card information to fill out the form. Credit card data is not saved.
+             */
+            card: CreditCard;
+        }
+
+        export interface SetAddressesRequest {
+            addresses: Address[];
+        }
+
+        /**
+         * Emitted when an address form is filled.
+         */
+        export interface AddressFormFilledEvent {
+            /**
+             * Information about the fields that were filled
+             */
+            filledFields: FilledField[];
+            /**
+             * An UI representation of the address used to fill the form.
+             * Consists of a 2D array where each child represents an address/profile line.
+             */
+            addressUi: AddressUI;
+        }
+    }
+
+    /**
+     * Defines events for background web platform features.
+     */
+    export namespace BackgroundService {
+
+        /**
+         * The Background Service that will be associated with the commands/events.
+         * Every Background Service operates independently, but they share the same
+         * API.
+         */
+        export type ServiceName = ('backgroundFetch' | 'backgroundSync' | 'pushMessaging' | 'notifications' | 'paymentHandler' | 'periodicBackgroundSync');
+
+        /**
+         * A key-value pair for additional event information to pass along.
+         */
+        export interface EventMetadata {
+            key: string;
+            value: string;
+        }
+
+        export interface BackgroundServiceEvent {
+            /**
+             * Timestamp of the event (in seconds).
+             */
+            timestamp: Network.TimeSinceEpoch;
+            /**
+             * The origin this event belongs to.
+             */
+            origin: string;
+            /**
+             * The Service Worker ID that initiated the event.
+             */
+            serviceWorkerRegistrationId: ServiceWorker.RegistrationID;
+            /**
+             * The Background Service this event belongs to.
+             */
+            service: ServiceName;
+            /**
+             * A description of the event.
+             */
+            eventName: string;
+            /**
+             * An identifier that groups related events together.
+             */
+            instanceId: string;
+            /**
+             * A list of event-specific information.
+             */
+            eventMetadata: EventMetadata[];
+            /**
+             * Storage key this event belongs to.
+             */
+            storageKey: string;
+        }
+
+        export interface StartObservingRequest {
+            service: ServiceName;
+        }
+
+        export interface StopObservingRequest {
+            service: ServiceName;
+        }
+
+        export interface SetRecordingRequest {
+            shouldRecord: boolean;
+            service: ServiceName;
+        }
+
+        export interface ClearEventsRequest {
+            service: ServiceName;
+        }
+
+        /**
+         * Called when the recording state for the service has been updated.
+         */
+        export interface RecordingStateChangedEvent {
+            isRecording: boolean;
+            service: ServiceName;
+        }
+
+        /**
+         * Called with all existing backgroundServiceEvents when enabled, and all new
+         * events afterwards if enabled and recording.
+         */
+        export interface BackgroundServiceEventReceivedEvent {
+            backgroundServiceEvent: BackgroundServiceEvent;
+        }
+    }
+
+    /**
+     * The Browser domain defines methods and events for browser managing.
+     */
+    export namespace Browser {
 
         export type BrowserContextID = string;
 
@@ -3604,13 +4123,13 @@ export namespace Protocol {
             windowState?: WindowState;
         }
 
-        export type PermissionType = ('accessibilityEvents' | 'audioCapture' | 'backgroundSync' | 'backgroundFetch' | 'clipboardReadWrite' | 'clipboardSanitizedWrite' | 'displayCapture' | 'durableStorage' | 'flash' | 'geolocation' | 'midi' | 'midiSysex' | 'nfc' | 'notifications' | 'paymentHandler' | 'periodicBackgroundSync' | 'protectedMediaIdentifier' | 'sensors' | 'videoCapture' | 'videoCapturePanTiltZoom' | 'idleDetection' | 'wakeLockScreen' | 'wakeLockSystem');
+        export type PermissionType = ('accessibilityEvents' | 'audioCapture' | 'backgroundSync' | 'backgroundFetch' | 'capturedSurfaceControl' | 'clipboardReadWrite' | 'clipboardSanitizedWrite' | 'displayCapture' | 'durableStorage' | 'flash' | 'geolocation' | 'idleDetection' | 'localFonts' | 'midi' | 'midiSysex' | 'nfc' | 'notifications' | 'paymentHandler' | 'periodicBackgroundSync' | 'protectedMediaIdentifier' | 'sensors' | 'storageAccess' | 'speakerSelection' | 'topLevelStorageAccess' | 'videoCapture' | 'videoCapturePanTiltZoom' | 'wakeLockScreen' | 'wakeLockSystem' | 'webAppInstallation' | 'windowManagement');
 
         export type PermissionSetting = ('granted' | 'denied' | 'prompt');
 
         /**
          * Definition of PermissionDescriptor defined in the Permissions API:
-         * https://w3c.github.io/permissions/#dictdef-permissiondescriptor.
+         * https://w3c.github.io/permissions/#dom-permissiondescriptor.
          */
         export interface PermissionDescriptor {
             /**
@@ -3631,6 +4150,10 @@ export namespace Protocol {
              * For "clipboard" permission, may specify allowWithoutSanitization.
              */
             allowWithoutSanitization?: boolean;
+            /**
+             * For "fullscreen" permission, must specify allowWithoutGesture:true.
+             */
+            allowWithoutGesture?: boolean;
             /**
              * For "camera" permission, may specify panTiltZoom.
              */
@@ -3731,7 +4254,7 @@ export namespace Protocol {
             /**
              * Whether to allow all or deny all download requests, or use default Chrome behavior if
              * available (otherwise deny). |allowAndName| allows download and names files according to
-             * their dowmload guids. (SetDownloadBehaviorRequestBehavior enum)
+             * their download guids. (SetDownloadBehaviorRequestBehavior enum)
              */
             behavior: ('deny' | 'allow' | 'allowAndName' | 'default');
             /**
@@ -3798,7 +4321,7 @@ export namespace Protocol {
              */
             query?: string;
             /**
-             * If true, retrieve delta since last call.
+             * If true, retrieve delta since last delta call.
              */
             delta?: boolean;
         }
@@ -3816,7 +4339,7 @@ export namespace Protocol {
              */
             name: string;
             /**
-             * If true, retrieve delta since last call.
+             * If true, retrieve delta since last delta call.
              */
             delta?: boolean;
         }
@@ -3886,6 +4409,10 @@ export namespace Protocol {
             commandId: BrowserCommandId;
         }
 
+        export interface AddPrivacySandboxEnrollmentOverrideRequest {
+            url: string;
+        }
+
         /**
          * Fired when page is about to start a download.
          */
@@ -3964,6 +4491,10 @@ export namespace Protocol {
              * Pseudo element type.
              */
             pseudoType: DOM.PseudoType;
+            /**
+             * Pseudo element custom ident.
+             */
+            pseudoIdentifier?: string;
             /**
              * Matches of CSS rules applicable to the pseudo style.
              */
@@ -3984,6 +4515,16 @@ export namespace Protocol {
             matchedCSSRules: RuleMatch[];
         }
 
+        /**
+         * Inherited pseudo element matches from pseudos of an ancestor node.
+         */
+        export interface InheritedPseudoElementMatches {
+            /**
+             * Matches of pseudo styles from the pseudos of an ancestor node.
+             */
+            pseudoElements: PseudoElementMatches[];
+        }
+
         /**
          * Match data for a CSS rule.
          */
@@ -4010,6 +4551,30 @@ export namespace Protocol {
              * Value range in the underlying resource (if available).
              */
             range?: SourceRange;
+            /**
+             * Specificity of the selector.
+             */
+            specificity?: Specificity;
+        }
+
+        /**
+         * Specificity:
+         * https://drafts.csswg.org/selectors/#specificity-rules
+         */
+        export interface Specificity {
+            /**
+             * The a component, which represents the number of ID selectors.
+             */
+            a: integer;
+            /**
+             * The b component, which represents the number of class selectors, attributes selectors, and
+             * pseudo-classes.
+             */
+            b: integer;
+            /**
+             * The c component, which represents the number of type selectors and pseudo-elements.
+             */
+            c: integer;
         }
 
         /**
@@ -4040,7 +4605,7 @@ export namespace Protocol {
             frameId: Page.FrameId;
             /**
              * Stylesheet resource URL. Empty if this is a constructed stylesheet created using
-             * new CSSStyleSheet() (but non-empty if this is a constructed sylesheet imported
+             * new CSSStyleSheet() (but non-empty if this is a constructed stylesheet imported
              * as a CSS module script).
              */
             sourceURL: string;
@@ -4076,7 +4641,7 @@ export namespace Protocol {
             /**
              * Whether this stylesheet is mutable. Inline stylesheets become mutable
              * after they have been modified via CSSOM API.
-             * <link> element's stylesheets become mutable only if DevTools modifies them.
+             * `<link>` element's stylesheets become mutable only if DevTools modifies them.
              * Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
              */
             isMutable: boolean;
@@ -4105,6 +4670,10 @@ export namespace Protocol {
              * Column offset of the end of the stylesheet within the resource (zero based).
              */
             endColumn: number;
+            /**
+             * If the style sheet was loaded from a network resource, this indicates when the resource failed to load
+             */
+            loadingFailed?: boolean;
         }
 
         /**
@@ -4120,6 +4689,10 @@ export namespace Protocol {
              * Rule selector data.
              */
             selectorList: SelectorList;
+            /**
+             * Array of selectors from ancestor style rules, sorted by distance from the current rule.
+             */
+            nestingSelectors?: string[];
             /**
              * Parent stylesheet's origin.
              */
@@ -4138,8 +4711,33 @@ export namespace Protocol {
              * The array enumerates container queries starting with the innermost one, going outwards.
              */
             containerQueries?: CSSContainerQuery[];
+            /**
+             * @supports CSS at-rule array.
+             * The array enumerates @supports at-rules starting with the innermost one, going outwards.
+             */
+            supports?: CSSSupports[];
+            /**
+             * Cascade layer array. Contains the layer hierarchy that this rule belongs to starting
+             * with the innermost layer and going outwards.
+             */
+            layers?: CSSLayer[];
+            /**
+             * @scope CSS at-rule array.
+             * The array enumerates @scope at-rules starting with the innermost one, going outwards.
+             */
+            scopes?: CSSScope[];
+            /**
+             * The array keeps the types of ancestor CSSRules from the innermost going outwards.
+             */
+            ruleTypes?: CSSRuleType[];
         }
 
+        /**
+         * Enum indicating the type of a CSS rule, used to represent the order of a style rule's ancestors.
+         * This list only contains rule types that are collected during the ancestor rule collection.
+         */
+        export type CSSRuleType = ('MediaRule' | 'SupportsRule' | 'ContainerRule' | 'LayerRule' | 'ScopeRule' | 'StyleRule');
+
         /**
          * CSS coverage information.
          */
@@ -4274,6 +4872,11 @@ export namespace Protocol {
              * The entire property range in the enclosing style declaration (if available).
              */
             range?: SourceRange;
+            /**
+             * Parsed longhand components of this property if it is a shorthand.
+             * This field will be empty if the given property is not a shorthand.
+             */
+            longhandProperties?: CSSProperty[];
         }
 
         export const enum CSSMediaSource {
@@ -4378,6 +4981,94 @@ export namespace Protocol {
              * Optional name for the container.
              */
             name?: string;
+            /**
+             * Optional physical axes queried for the container.
+             */
+            physicalAxes?: DOM.PhysicalAxes;
+            /**
+             * Optional logical axes queried for the container.
+             */
+            logicalAxes?: DOM.LogicalAxes;
+        }
+
+        /**
+         * CSS Supports at-rule descriptor.
+         */
+        export interface CSSSupports {
+            /**
+             * Supports rule text.
+             */
+            text: string;
+            /**
+             * Whether the supports condition is satisfied.
+             */
+            active: boolean;
+            /**
+             * The associated rule header range in the enclosing stylesheet (if
+             * available).
+             */
+            range?: SourceRange;
+            /**
+             * Identifier of the stylesheet containing this object (if exists).
+             */
+            styleSheetId?: StyleSheetId;
+        }
+
+        /**
+         * CSS Scope at-rule descriptor.
+         */
+        export interface CSSScope {
+            /**
+             * Scope rule text.
+             */
+            text: string;
+            /**
+             * The associated rule header range in the enclosing stylesheet (if
+             * available).
+             */
+            range?: SourceRange;
+            /**
+             * Identifier of the stylesheet containing this object (if exists).
+             */
+            styleSheetId?: StyleSheetId;
+        }
+
+        /**
+         * CSS Layer at-rule descriptor.
+         */
+        export interface CSSLayer {
+            /**
+             * Layer name.
+             */
+            text: string;
+            /**
+             * The associated rule header range in the enclosing stylesheet (if
+             * available).
+             */
+            range?: SourceRange;
+            /**
+             * Identifier of the stylesheet containing this object (if exists).
+             */
+            styleSheetId?: StyleSheetId;
+        }
+
+        /**
+         * CSS Layer data.
+         */
+        export interface CSSLayerData {
+            /**
+             * Layer name.
+             */
+            name: string;
+            /**
+             * Direct sub-layers
+             */
+            subLayers?: CSSLayerData[];
+            /**
+             * Layer order. The order determines the order of the layer in the cascade order.
+             * A higher number has higher priority in the cascade order.
+             */
+            order: number;
         }
 
         /**
@@ -4388,6 +5079,10 @@ export namespace Protocol {
              * Font's family name reported by platform.
              */
             familyName: string;
+            /**
+             * Font's PostScript name reported by platform.
+             */
+            postScriptName: string;
             /**
              * Indicates if the font was downloaded or resolved locally.
              */
@@ -4449,6 +5144,10 @@ export namespace Protocol {
              * The font-stretch.
              */
             fontStretch: string;
+            /**
+             * The font-display.
+             */
+            fontDisplay: string;
             /**
              * The unicode-range.
              */
@@ -4468,19 +5167,118 @@ export namespace Protocol {
         }
 
         /**
-         * CSS keyframes rule representation.
+         * CSS try rule representation.
          */
-        export interface CSSKeyframesRule {
+        export interface CSSTryRule {
             /**
-             * Animation name.
+             * The css style sheet identifier (absent for user agent stylesheet and user-specified
+             * stylesheet rules) this rule came from.
              */
-            animationName: Value;
+            styleSheetId?: StyleSheetId;
+            /**
+             * Parent stylesheet's origin.
+             */
+            origin: StyleSheetOrigin;
+            /**
+             * Associated style declaration.
+             */
+            style: CSSStyle;
+        }
+
+        /**
+         * CSS @position-try rule representation.
+         */
+        export interface CSSPositionTryRule {
+            /**
+             * The prelude dashed-ident name
+             */
+            name: Value;
+            /**
+             * The css style sheet identifier (absent for user agent stylesheet and user-specified
+             * stylesheet rules) this rule came from.
+             */
+            styleSheetId?: StyleSheetId;
+            /**
+             * Parent stylesheet's origin.
+             */
+            origin: StyleSheetOrigin;
+            /**
+             * Associated style declaration.
+             */
+            style: CSSStyle;
+            active: boolean;
+        }
+
+        /**
+         * CSS keyframes rule representation.
+         */
+        export interface CSSKeyframesRule {
+            /**
+             * Animation name.
+             */
+            animationName: Value;
             /**
              * List of keyframes.
              */
             keyframes: CSSKeyframeRule[];
         }
 
+        /**
+         * Representation of a custom property registration through CSS.registerProperty
+         */
+        export interface CSSPropertyRegistration {
+            propertyName: string;
+            initialValue?: Value;
+            inherits: boolean;
+            syntax: string;
+        }
+
+        /**
+         * CSS font-palette-values rule representation.
+         */
+        export interface CSSFontPaletteValuesRule {
+            /**
+             * The css style sheet identifier (absent for user agent stylesheet and user-specified
+             * stylesheet rules) this rule came from.
+             */
+            styleSheetId?: StyleSheetId;
+            /**
+             * Parent stylesheet's origin.
+             */
+            origin: StyleSheetOrigin;
+            /**
+             * Associated font palette name.
+             */
+            fontPaletteName: Value;
+            /**
+             * Associated style declaration.
+             */
+            style: CSSStyle;
+        }
+
+        /**
+         * CSS property at-rule representation.
+         */
+        export interface CSSPropertyRule {
+            /**
+             * The css style sheet identifier (absent for user agent stylesheet and user-specified
+             * stylesheet rules) this rule came from.
+             */
+            styleSheetId?: StyleSheetId;
+            /**
+             * Parent stylesheet's origin.
+             */
+            origin: StyleSheetOrigin;
+            /**
+             * Associated property name.
+             */
+            propertyName: Value;
+            /**
+             * Associated style declaration.
+             */
+            style: CSSStyle;
+        }
+
         /**
          * CSS keyframe rule representation.
          */
@@ -4535,6 +5333,12 @@ export namespace Protocol {
              * Text position of a new rule in the target style sheet.
              */
             location: SourceRange;
+            /**
+             * NodeId for the DOM node in whose context custom property declarations for registered properties should be
+             * validated. If omitted, declarations in the new rule text can only be validated statically, which may produce
+             * incorrect results if the declaration contains a var() for example.
+             */
+            nodeForPropertySyntaxValidation?: DOM.NodeId;
         }
 
         export interface AddRuleResponse {
@@ -4658,10 +5462,39 @@ export namespace Protocol {
              * A chain of inherited styles (from the immediate node parent up to the DOM tree root).
              */
             inherited?: InheritedStyleEntry[];
+            /**
+             * A chain of inherited pseudo element styles (from the immediate node parent up to the DOM tree root).
+             */
+            inheritedPseudoElements?: InheritedPseudoElementMatches[];
             /**
              * A list of CSS keyframed animations matching this node.
              */
             cssKeyframesRules?: CSSKeyframesRule[];
+            /**
+             * A list of CSS @position-try rules matching this node, based on the position-try-fallbacks property.
+             */
+            cssPositionTryRules?: CSSPositionTryRule[];
+            /**
+             * Index of the active fallback in the applied position-try-fallback property,
+             * will not be set if there is no active position-try fallback.
+             */
+            activePositionFallbackIndex?: integer;
+            /**
+             * A list of CSS at-property rules matching this node.
+             */
+            cssPropertyRules?: CSSPropertyRule[];
+            /**
+             * A list of CSS property registrations matching this node.
+             */
+            cssPropertyRegistrations?: CSSPropertyRegistration[];
+            /**
+             * A font-palette-values rule matching this node.
+             */
+            cssFontPaletteValuesRule?: CSSFontPaletteValuesRule;
+            /**
+             * Id of the first parent element that does not have display: contents.
+             */
+            parentLayoutNodeId?: DOM.NodeId;
         }
 
         export interface GetMediaQueriesResponse {
@@ -4690,13 +5523,30 @@ export namespace Protocol {
             text: string;
         }
 
+        export interface GetLayersForNodeRequest {
+            nodeId: DOM.NodeId;
+        }
+
+        export interface GetLayersForNodeResponse {
+            rootLayer: CSSLayerData;
+        }
+
+        export interface GetLocationForSelectorRequest {
+            styleSheetId: StyleSheetId;
+            selectorText: string;
+        }
+
+        export interface GetLocationForSelectorResponse {
+            ranges: SourceRange[];
+        }
+
         export interface TrackComputedStyleUpdatesRequest {
             propertiesToTrack: CSSComputedStyleProperty[];
         }
 
         export interface TakeComputedStyleUpdatesResponse {
             /**
-             * The list of node Ids that have their tracked computed styles updated
+             * The list of node Ids that have their tracked computed styles updated.
              */
             nodeIds: DOM.NodeId[];
         }
@@ -4710,6 +5560,19 @@ export namespace Protocol {
             value: string;
         }
 
+        export interface SetPropertyRulePropertyNameRequest {
+            styleSheetId: StyleSheetId;
+            range: SourceRange;
+            propertyName: string;
+        }
+
+        export interface SetPropertyRulePropertyNameResponse {
+            /**
+             * The resulting key text after modification.
+             */
+            propertyName: Value;
+        }
+
         export interface SetKeyframeKeyRequest {
             styleSheetId: StyleSheetId;
             range: SourceRange;
@@ -4749,6 +5612,32 @@ export namespace Protocol {
             containerQuery: CSSContainerQuery;
         }
 
+        export interface SetSupportsTextRequest {
+            styleSheetId: StyleSheetId;
+            range: SourceRange;
+            text: string;
+        }
+
+        export interface SetSupportsTextResponse {
+            /**
+             * The resulting CSS Supports rule after modification.
+             */
+            supports: CSSSupports;
+        }
+
+        export interface SetScopeTextRequest {
+            styleSheetId: StyleSheetId;
+            range: SourceRange;
+            text: string;
+        }
+
+        export interface SetScopeTextResponse {
+            /**
+             * The resulting CSS Scope rule after modification.
+             */
+            scope: CSSScope;
+        }
+
         export interface SetRuleSelectorRequest {
             styleSheetId: StyleSheetId;
             range: SourceRange;
@@ -4776,6 +5665,12 @@ export namespace Protocol {
 
         export interface SetStyleTextsRequest {
             edits: StyleDeclarationEdit[];
+            /**
+             * NodeId for the DOM node in whose context custom property declarations for registered properties should be
+             * validated. If omitted, declarations in the new rule text can only be validated statically, which may produce
+             * incorrect results if the declaration contains a var() for example.
+             */
+            nodeForPropertySyntaxValidation?: DOM.NodeId;
         }
 
         export interface SetStyleTextsResponse {
@@ -4806,7 +5701,7 @@ export namespace Protocol {
 
         /**
          * Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
-         * web font
+         * web font.
          */
         export interface FontsUpdatedEvent {
             /**
@@ -4905,6 +5800,14 @@ export namespace Protocol {
              * Security origin of the cache.
              */
             securityOrigin: string;
+            /**
+             * Storage key of the cache.
+             */
+            storageKey: string;
+            /**
+             * Storage bucket of the cache.
+             */
+            storageBucket?: Storage.StorageBucket;
             /**
              * The name of the cache.
              */
@@ -4946,9 +5849,18 @@ export namespace Protocol {
 
         export interface RequestCacheNamesRequest {
             /**
+             * At least and at most one of securityOrigin, storageKey, storageBucket must be specified.
              * Security origin.
              */
-            securityOrigin: string;
+            securityOrigin?: string;
+            /**
+             * Storage key.
+             */
+            storageKey?: string;
+            /**
+             * Storage bucket. If not specified, it uses the default bucket.
+             */
+            storageBucket?: Storage.StorageBucket;
         }
 
         export interface RequestCacheNamesResponse {
@@ -5036,6 +5948,10 @@ export namespace Protocol {
             sinkName: string;
         }
 
+        export interface StartDesktopMirroringRequest {
+            sinkName: string;
+        }
+
         export interface StartTabMirroringRequest {
             sinkName: string;
         }
@@ -5067,8 +5983,8 @@ export namespace Protocol {
      * the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
      * nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
      * and never sends the same node twice. It is client's responsibility to collect information about
-     * the nodes that were sent to the client.<p>Note that `iframe` owner elements will return
-     * corresponding document elements as their child nodes.</p>
+     * the nodes that were sent to the client. Note that `iframe` owner elements will return
+     * corresponding document elements as their child nodes.
      */
     export namespace DOM {
 
@@ -5101,7 +6017,7 @@ export namespace Protocol {
         /**
          * Pseudo element type.
          */
-        export type PseudoType = ('first-line' | 'first-letter' | 'before' | 'after' | 'marker' | 'backdrop' | 'selection' | 'target-text' | 'spelling-error' | 'grammar-error' | 'highlight' | 'first-line-inherited' | 'scrollbar' | 'scrollbar-thumb' | 'scrollbar-button' | 'scrollbar-track' | 'scrollbar-track-piece' | 'scrollbar-corner' | 'resizer' | 'input-list-button');
+        export type PseudoType = ('first-line' | 'first-letter' | 'before' | 'after' | 'marker' | 'backdrop' | 'selection' | 'search-text' | 'target-text' | 'spelling-error' | 'grammar-error' | 'highlight' | 'first-line-inherited' | 'scroll-marker' | 'scroll-marker-group' | 'scroll-next-button' | 'scroll-prev-button' | 'scrollbar' | 'scrollbar-thumb' | 'scrollbar-button' | 'scrollbar-track' | 'scrollbar-track-piece' | 'scrollbar-corner' | 'resizer' | 'input-list-button' | 'view-transition' | 'view-transition-group' | 'view-transition-image-pair' | 'view-transition-old' | 'view-transition-new');
 
         /**
          * Shadow root type.
@@ -5113,6 +6029,21 @@ export namespace Protocol {
          */
         export type CompatibilityMode = ('QuirksMode' | 'LimitedQuirksMode' | 'NoQuirksMode');
 
+        /**
+         * ContainerSelector physical axes
+         */
+        export type PhysicalAxes = ('Horizontal' | 'Vertical' | 'Both');
+
+        /**
+         * ContainerSelector logical axes
+         */
+        export type LogicalAxes = ('Inline' | 'Block' | 'Both');
+
+        /**
+         * Physical scroll orientation
+         */
+        export type ScrollOrientation = ('horizontal' | 'vertical');
+
         /**
          * DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
          * DOMNode is a base node mirror type.
@@ -5196,6 +6127,11 @@ export namespace Protocol {
              * Pseudo element type for this node.
              */
             pseudoType?: PseudoType;
+            /**
+             * Pseudo element identifier for this node. Only present if there is a
+             * valid pseudoType.
+             */
+            pseudoIdentifier?: string;
             /**
              * Shadow root type.
              */
@@ -5235,6 +6171,15 @@ export namespace Protocol {
              */
             isSVG?: boolean;
             compatibilityMode?: CompatibilityMode;
+            assignedSlot?: BackendNode;
+        }
+
+        /**
+         * A structure to hold the top-level node of a detached tree and an array of its retained descendants.
+         */
+        export interface DetachedElementInfo {
+            treeNode: Node;
+            retainedNodeIds: NodeId[];
         }
 
         /**
@@ -5445,6 +6390,18 @@ export namespace Protocol {
             searchId: string;
         }
 
+        export const enum EnableRequestIncludeWhitespace {
+            None = 'none',
+            All = 'all',
+        }
+
+        export interface EnableRequest {
+            /**
+             * Whether to include whitespaces in the children array of returned Nodes. (EnableRequestIncludeWhitespace enum)
+             */
+            includeWhitespace?: ('none' | 'all');
+        }
+
         export interface FocusRequest {
             /**
              * Identifier of the node.
@@ -5462,7 +6419,7 @@ export namespace Protocol {
 
         export interface GetAttributesRequest {
             /**
-             * Id of the node to retrieve attibutes for.
+             * Id of the node to retrieve attributes for.
              */
             nodeId: NodeId;
         }
@@ -5783,6 +6740,35 @@ export namespace Protocol {
             nodeIds: NodeId[];
         }
 
+        export interface GetTopLayerElementsResponse {
+            /**
+             * NodeIds of top layer elements
+             */
+            nodeIds: NodeId[];
+        }
+
+        export const enum GetElementByRelationRequestRelation {
+            PopoverTarget = 'PopoverTarget',
+        }
+
+        export interface GetElementByRelationRequest {
+            /**
+             * Id of the node from which to query the relation.
+             */
+            nodeId: NodeId;
+            /**
+             * Type of relation to get. (GetElementByRelationRequestRelation enum)
+             */
+            relation: ('PopoverTarget');
+        }
+
+        export interface GetElementByRelationResponse {
+            /**
+             * NodeId of the element matching the queried relation.
+             */
+            nodeId: NodeId;
+        }
+
         export interface RemoveAttributeRequest {
             /**
              * Id of the element to remove attribute from.
@@ -5940,6 +6926,13 @@ export namespace Protocol {
             path: string;
         }
 
+        export interface GetDetachedDomNodesResponse {
+            /**
+             * The list of detached nodes
+             */
+            detachedNodes: DetachedElementInfo[];
+        }
+
         export interface SetInspectedNodeRequest {
             /**
              * DOM node id to be accessible by means of $x command line API.
@@ -6005,6 +6998,8 @@ export namespace Protocol {
         export interface GetContainerForNodeRequest {
             nodeId: NodeId;
             containerName?: string;
+            physicalAxes?: PhysicalAxes;
+            logicalAxes?: LogicalAxes;
         }
 
         export interface GetContainerForNodeResponse {
@@ -6028,6 +7023,27 @@ export namespace Protocol {
             nodeIds: NodeId[];
         }
 
+        export interface GetAnchorElementRequest {
+            /**
+             * Id of the positioned element from which to find the anchor.
+             */
+            nodeId: NodeId;
+            /**
+             * An optional anchor specifier, as defined in
+             * https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier.
+             * If not provided, it will return the implicit anchor element for
+             * the given positioned element.
+             */
+            anchorSpecifier?: string;
+        }
+
+        export interface GetAnchorElementResponse {
+            /**
+             * The anchor element of the given anchor query.
+             */
+            nodeId: NodeId;
+        }
+
         /**
          * Fired when `Element`'s attribute is modified.
          */
@@ -6097,7 +7113,7 @@ export namespace Protocol {
              */
             parentNodeId: NodeId;
             /**
-             * If of the previous siblint.
+             * Id of the previous sibling.
              */
             previousNodeId: NodeId;
             /**
@@ -6383,6 +7399,28 @@ export namespace Protocol {
         }
     }
 
+    /**
+     * EventBreakpoints permits setting JavaScript breakpoints on operations and events
+     * occurring in native code invoked from JavaScript. Once breakpoint is hit, it is
+     * reported through Debugger domain, similarly to regular breakpoints being hit.
+     */
+    export namespace EventBreakpoints {
+
+        export interface SetInstrumentationBreakpointRequest {
+            /**
+             * Instrumentation name to stop on.
+             */
+            eventName: string;
+        }
+
+        export interface RemoveInstrumentationBreakpointRequest {
+            /**
+             * Instrumentation name to stop on.
+             */
+            eventName: string;
+        }
+    }
+
     /**
      * This domain facilitates obtaining document snapshots with DOM, layout, and style information.
      */
@@ -6741,6 +7779,11 @@ export namespace Protocol {
              * Type of a pseudo element node.
              */
             pseudoType?: RareStringData;
+            /**
+             * Pseudo element identifier for this node. Only present if there is a
+             * valid pseudoType.
+             */
+            pseudoIdentifier?: RareStringData;
             /**
              * Whether this DOM node responds to mouse clicks. This includes nodes that have had click
              * event listeners attached via JavaScript as well as anchor tags that naturally navigate when
@@ -6912,6 +7955,8 @@ export namespace Protocol {
      */
     export namespace DOMStorage {
 
+        export type SerializedStorageKey = string;
+
         /**
          * DOM Storage identifier.
          */
@@ -6919,7 +7964,11 @@ export namespace Protocol {
             /**
              * Security origin for the storage.
              */
-            securityOrigin: string;
+            securityOrigin?: string;
+            /**
+             * Represents a key by which DOM Storage keys its CachedStorageAreas
+             */
+            storageKey?: SerializedStorageKey;
             /**
              * Whether the storage is local storage (not session storage).
              */
@@ -7111,6 +8160,18 @@ export namespace Protocol {
             maskLength: integer;
         }
 
+        export const enum DevicePostureType {
+            Continuous = 'continuous',
+            Folded = 'folded',
+        }
+
+        export interface DevicePosture {
+            /**
+             * Current posture of the device (DevicePostureType enum)
+             */
+            type: ('continuous' | 'folded');
+        }
+
         export interface MediaFeature {
             name: string;
             value: string;
@@ -7125,7 +8186,7 @@ export namespace Protocol {
         export type VirtualTimePolicy = ('advance' | 'pause' | 'pauseIfNetworkFetchesPending');
 
         /**
-         * Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
+         * Used to specify User Agent Client Hints to emulate. See https://wicg.github.io/ua-client-hints
          */
         export interface UserAgentBrandVersion {
             brand: string;
@@ -7133,40 +8194,92 @@ export namespace Protocol {
         }
 
         /**
-         * Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
+         * Used to specify User Agent Client Hints to emulate. See https://wicg.github.io/ua-client-hints
          * Missing optional values will be filled in by the target with what it would normally use.
          */
         export interface UserAgentMetadata {
+            /**
+             * Brands appearing in Sec-CH-UA.
+             */
             brands?: UserAgentBrandVersion[];
+            /**
+             * Brands appearing in Sec-CH-UA-Full-Version-List.
+             */
+            fullVersionList?: UserAgentBrandVersion[];
             fullVersion?: string;
             platform: string;
             platformVersion: string;
             architecture: string;
             model: string;
             mobile: boolean;
+            bitness?: string;
+            wow64?: boolean;
         }
 
         /**
-         * Enum of image types that can be disabled.
+         * Used to specify sensor types to emulate.
+         * See https://w3c.github.io/sensors/#automation for more information.
          */
-        export type DisabledImageType = ('avif' | 'jxl' | 'webp');
+        export type SensorType = ('absolute-orientation' | 'accelerometer' | 'ambient-light' | 'gravity' | 'gyroscope' | 'linear-acceleration' | 'magnetometer' | 'proximity' | 'relative-orientation');
 
-        export interface CanEmulateResponse {
-            /**
-             * True if emulation is supported.
-             */
-            result: boolean;
+        export interface SensorMetadata {
+            available?: boolean;
+            minimumFrequency?: number;
+            maximumFrequency?: number;
         }
 
-        export interface SetFocusEmulationEnabledRequest {
-            /**
-             * Whether to enable to disable focus emulation.
-             */
-            enabled: boolean;
+        export interface SensorReadingSingle {
+            value: number;
         }
 
-        export interface SetAutoDarkModeOverrideRequest {
-            /**
+        export interface SensorReadingXYZ {
+            x: number;
+            y: number;
+            z: number;
+        }
+
+        export interface SensorReadingQuaternion {
+            x: number;
+            y: number;
+            z: number;
+            w: number;
+        }
+
+        export interface SensorReading {
+            single?: SensorReadingSingle;
+            xyz?: SensorReadingXYZ;
+            quaternion?: SensorReadingQuaternion;
+        }
+
+        export type PressureSource = ('cpu');
+
+        export type PressureState = ('nominal' | 'fair' | 'serious' | 'critical');
+
+        export interface PressureMetadata {
+            available?: boolean;
+        }
+
+        /**
+         * Enum of image types that can be disabled.
+         */
+        export type DisabledImageType = ('avif' | 'webp');
+
+        export interface CanEmulateResponse {
+            /**
+             * True if emulation is supported.
+             */
+            result: boolean;
+        }
+
+        export interface SetFocusEmulationEnabledRequest {
+            /**
+             * Whether to enable to disable focus emulation.
+             */
+            enabled: boolean;
+        }
+
+        export interface SetAutoDarkModeOverrideRequest {
+            /**
              * Whether to enable or disable automatic dark mode.
              * If not specified, any existing override will be cleared.
              */
@@ -7244,6 +8357,16 @@ export namespace Protocol {
              * is turned-off.
              */
             displayFeature?: DisplayFeature;
+            /**
+             * If set, the posture of a foldable device. If not set the posture is set
+             * to continuous.
+             * Deprecated, use Emulation.setDevicePostureOverride.
+             */
+            devicePosture?: DevicePosture;
+        }
+
+        export interface SetDevicePostureOverrideRequest {
+            posture: DevicePosture;
         }
 
         export interface SetScrollbarsHiddenRequest {
@@ -7289,8 +8412,9 @@ export namespace Protocol {
 
         export const enum SetEmulatedVisionDeficiencyRequestType {
             None = 'none',
-            Achromatopsia = 'achromatopsia',
             BlurredVision = 'blurredVision',
+            ReducedContrast = 'reducedContrast',
+            Achromatopsia = 'achromatopsia',
             Deuteranopia = 'deuteranopia',
             Protanopia = 'protanopia',
             Tritanopia = 'tritanopia',
@@ -7298,9 +8422,10 @@ export namespace Protocol {
 
         export interface SetEmulatedVisionDeficiencyRequest {
             /**
-             * Vision deficiency to emulate. (SetEmulatedVisionDeficiencyRequestType enum)
+             * Vision deficiency to emulate. Order: best-effort emulations come first, followed by any
+             * physiologically accurate emulations for medically recognized color vision deficiencies. (SetEmulatedVisionDeficiencyRequestType enum)
              */
-            type: ('none' | 'achromatopsia' | 'blurredVision' | 'deuteranopia' | 'protanopia' | 'tritanopia');
+            type: ('none' | 'blurredVision' | 'reducedContrast' | 'achromatopsia' | 'deuteranopia' | 'protanopia' | 'tritanopia');
         }
 
         export interface SetGeolocationOverrideRequest {
@@ -7318,6 +8443,36 @@ export namespace Protocol {
             accuracy?: number;
         }
 
+        export interface GetOverriddenSensorInformationRequest {
+            type: SensorType;
+        }
+
+        export interface GetOverriddenSensorInformationResponse {
+            requestedSamplingFrequency: number;
+        }
+
+        export interface SetSensorOverrideEnabledRequest {
+            enabled: boolean;
+            type: SensorType;
+            metadata?: SensorMetadata;
+        }
+
+        export interface SetSensorOverrideReadingsRequest {
+            type: SensorType;
+            reading: SensorReading;
+        }
+
+        export interface SetPressureSourceOverrideEnabledRequest {
+            enabled: boolean;
+            source: PressureSource;
+            metadata?: PressureMetadata;
+        }
+
+        export interface SetPressureStateOverrideRequest {
+            source: PressureSource;
+            state: PressureState;
+        }
+
         export interface SetIdleOverrideRequest {
             /**
              * Mock isUserActive
@@ -7373,11 +8528,6 @@ export namespace Protocol {
              * forwards to prevent deadlock.
              */
             maxVirtualTimeTaskStarvationCount?: integer;
-            /**
-             * If set the virtual time policy change should be deferred until any frame starts navigating.
-             * Note any previous deferred policy change is superseded.
-             */
-            waitForNavigation?: boolean;
             /**
              * If set, base::Time::Now will be overridden to initially return this value.
              */
@@ -7401,8 +8551,9 @@ export namespace Protocol {
 
         export interface SetTimezoneOverrideRequest {
             /**
-             * The timezone identifier. If empty, disables the override and
-             * restores default host system timezone.
+             * The timezone identifier. List of supported timezones:
+             * https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt
+             * If empty, disables the override and restores default host system timezone.
              */
             timezoneId: string;
         }
@@ -7425,13 +8576,20 @@ export namespace Protocol {
             imageTypes: DisabledImageType[];
         }
 
+        export interface SetHardwareConcurrencyOverrideRequest {
+            /**
+             * Hardware concurrency to report
+             */
+            hardwareConcurrency: integer;
+        }
+
         export interface SetUserAgentOverrideRequest {
             /**
              * User agent to use.
              */
             userAgent: string;
             /**
-             * Browser langugage to emulate.
+             * Browser language to emulate.
              */
             acceptLanguage?: string;
             /**
@@ -7443,6 +8601,13 @@ export namespace Protocol {
              */
             userAgentMetadata?: UserAgentMetadata;
         }
+
+        export interface SetAutomationOverrideRequest {
+            /**
+             * Whether the override should be enabled.
+             */
+            enabled: boolean;
+        }
     }
 
     /**
@@ -7453,6 +8618,7 @@ export namespace Protocol {
         export const enum ScreenshotParamsFormat {
             Jpeg = 'jpeg',
             Png = 'png',
+            Webp = 'webp',
         }
 
         /**
@@ -7462,11 +8628,15 @@ export namespace Protocol {
             /**
              * Image compression format (defaults to png). (ScreenshotParamsFormat enum)
              */
-            format?: ('jpeg' | 'png');
+            format?: ('jpeg' | 'png' | 'webp');
             /**
-             * Compression quality from range [0..100] (jpeg only).
+             * Compression quality from range [0..100] (jpeg and webp only).
              */
             quality?: integer;
+            /**
+             * Optimize image encoding for speed, not for resulting size (defaults to false)
+             */
+            optimizeForSpeed?: boolean;
         }
 
         export interface BeginFrameRequest {
@@ -7505,18 +8675,6 @@ export namespace Protocol {
              */
             screenshotData?: string;
         }
-
-        /**
-         * Issued when the target starts or stops needing BeginFrames.
-         * Deprecated. Issue beginFrame unconditionally instead and use result from
-         * beginFrame to detect whether the frames were suppressed.
-         */
-        export interface NeedsBeginFramesChangedEvent {
-            /**
-             * True if BeginFrames are needed, false otherwise.
-             */
-            needsBeginFrames: boolean;
-        }
     }
 
     /**
@@ -7525,8 +8683,8 @@ export namespace Protocol {
     export namespace IO {
 
         /**
-         * This is either obtained from another method or specified as `blob:&lt;uuid&gt;` where
-         * `&lt;uuid&gt` is an UUID of a Blob.
+         * This is either obtained from another method or specified as `blob:<uuid>` where
+         * `<uuid>` is an UUID of a Blob.
          */
         export type StreamHandle = string;
 
@@ -7543,7 +8701,7 @@ export namespace Protocol {
              */
             handle: StreamHandle;
             /**
-             * Seek to the specified offset before reading (if not specificed, proceed with offset
+             * Seek to the specified offset before reading (if not specified, proceed with offset
              * following the last read). Some types of streams may only support sequential reads.
              */
             offset?: integer;
@@ -7583,6 +8741,57 @@ export namespace Protocol {
         }
     }
 
+    export namespace FileSystem {
+
+        export interface File {
+            name: string;
+            /**
+             * Timestamp
+             */
+            lastModified: Network.TimeSinceEpoch;
+            /**
+             * Size in bytes
+             */
+            size: number;
+            type: string;
+        }
+
+        export interface Directory {
+            name: string;
+            nestedDirectories: string[];
+            /**
+             * Files that are directly nested under this directory.
+             */
+            nestedFiles: File[];
+        }
+
+        export interface BucketFileSystemLocator {
+            /**
+             * Storage key
+             */
+            storageKey: Storage.SerializedStorageKey;
+            /**
+             * Bucket name. Not passing a `bucketName` will retrieve the default Bucket. (https://developer.mozilla.org/en-US/docs/Web/API/Storage_API#storage_buckets)
+             */
+            bucketName?: string;
+            /**
+             * Path to the directory using each path component as an array item.
+             */
+            pathComponents: string[];
+        }
+
+        export interface GetDirectoryRequest {
+            bucketFileSystemLocator: BucketFileSystemLocator;
+        }
+
+        export interface GetDirectoryResponse {
+            /**
+             * Returns the directory object at the path.
+             */
+            directory: Directory;
+        }
+    }
+
     export namespace IndexedDB {
 
         /**
@@ -7747,9 +8956,18 @@ export namespace Protocol {
 
         export interface ClearObjectStoreRequest {
             /**
+             * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
              * Security origin.
              */
-            securityOrigin: string;
+            securityOrigin?: string;
+            /**
+             * Storage key.
+             */
+            storageKey?: string;
+            /**
+             * Storage bucket. If not specified, it uses the default bucket.
+             */
+            storageBucket?: Storage.StorageBucket;
             /**
              * Database name.
              */
@@ -7762,9 +8980,18 @@ export namespace Protocol {
 
         export interface DeleteDatabaseRequest {
             /**
+             * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
              * Security origin.
              */
-            securityOrigin: string;
+            securityOrigin?: string;
+            /**
+             * Storage key.
+             */
+            storageKey?: string;
+            /**
+             * Storage bucket. If not specified, it uses the default bucket.
+             */
+            storageBucket?: Storage.StorageBucket;
             /**
              * Database name.
              */
@@ -7772,7 +8999,19 @@ export namespace Protocol {
         }
 
         export interface DeleteObjectStoreEntriesRequest {
-            securityOrigin: string;
+            /**
+             * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
+             * Security origin.
+             */
+            securityOrigin?: string;
+            /**
+             * Storage key.
+             */
+            storageKey?: string;
+            /**
+             * Storage bucket. If not specified, it uses the default bucket.
+             */
+            storageBucket?: Storage.StorageBucket;
             databaseName: string;
             objectStoreName: string;
             /**
@@ -7783,9 +9022,18 @@ export namespace Protocol {
 
         export interface RequestDataRequest {
             /**
+             * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
              * Security origin.
              */
-            securityOrigin: string;
+            securityOrigin?: string;
+            /**
+             * Storage key.
+             */
+            storageKey?: string;
+            /**
+             * Storage bucket. If not specified, it uses the default bucket.
+             */
+            storageBucket?: Storage.StorageBucket;
             /**
              * Database name.
              */
@@ -7825,9 +9073,18 @@ export namespace Protocol {
 
         export interface GetMetadataRequest {
             /**
+             * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
              * Security origin.
              */
-            securityOrigin: string;
+            securityOrigin?: string;
+            /**
+             * Storage key.
+             */
+            storageKey?: string;
+            /**
+             * Storage bucket. If not specified, it uses the default bucket.
+             */
+            storageBucket?: Storage.StorageBucket;
             /**
              * Database name.
              */
@@ -7853,9 +9110,18 @@ export namespace Protocol {
 
         export interface RequestDatabaseRequest {
             /**
+             * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
              * Security origin.
              */
-            securityOrigin: string;
+            securityOrigin?: string;
+            /**
+             * Storage key.
+             */
+            storageKey?: string;
+            /**
+             * Storage bucket. If not specified, it uses the default bucket.
+             */
+            storageBucket?: Storage.StorageBucket;
             /**
              * Database name.
              */
@@ -7871,9 +9137,18 @@ export namespace Protocol {
 
         export interface RequestDatabaseNamesRequest {
             /**
+             * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
              * Security origin.
              */
-            securityOrigin: string;
+            securityOrigin?: string;
+            /**
+             * Storage key.
+             */
+            storageKey?: string;
+            /**
+             * Storage bucket. If not specified, it uses the default bucket.
+             */
+            storageBucket?: Storage.StorageBucket;
         }
 
         export interface RequestDatabaseNamesResponse {
@@ -7919,11 +9194,11 @@ export namespace Protocol {
             /**
              * The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)
              */
-            tiltX?: integer;
+            tiltX?: number;
             /**
              * The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
              */
-            tiltY?: integer;
+            tiltY?: number;
             /**
              * The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
              */
@@ -8077,7 +9352,7 @@ export namespace Protocol {
             /**
              * Editing commands to send with the key event (e.g., 'selectAll') (default: []).
              * These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.
-             * See https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
+             * See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
              */
             commands?: string[];
         }
@@ -8171,11 +9446,11 @@ export namespace Protocol {
             /**
              * The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
              */
-            tiltX?: integer;
+            tiltX?: number;
             /**
              * The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
              */
-            tiltY?: integer;
+            tiltY?: number;
             /**
              * The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
              */
@@ -8686,7 +9961,7 @@ export namespace Protocol {
 
         export interface LayerTreeDidChangeEvent {
             /**
-             * Layer tree, absent if not in the comspositing mode.
+             * Layer tree, absent if not in the compositing mode.
              */
             layers?: Layer[];
         }
@@ -8925,7 +10200,7 @@ export namespace Protocol {
         /**
          * Resource type as it was perceived by the rendering engine.
          */
-        export type ResourceType = ('Document' | 'Stylesheet' | 'Image' | 'Media' | 'Font' | 'Script' | 'TextTrack' | 'XHR' | 'Fetch' | 'EventSource' | 'WebSocket' | 'Manifest' | 'SignedExchange' | 'Ping' | 'CSPViolationReport' | 'Preflight' | 'Other');
+        export type ResourceType = ('Document' | 'Stylesheet' | 'Image' | 'Media' | 'Font' | 'Script' | 'TextTrack' | 'XHR' | 'Fetch' | 'Prefetch' | 'EventSource' | 'WebSocket' | 'Manifest' | 'SignedExchange' | 'Ping' | 'CSPViolationReport' | 'Preflight' | 'Other');
 
         /**
          * Unique loader identifier.
@@ -9045,6 +10320,14 @@ export namespace Protocol {
              * Settled fetch event respondWith promise.
              */
             workerRespondWithSettled: number;
+            /**
+             * Started ServiceWorker static routing source evaluation.
+             */
+            workerRouterEvaluationStart?: number;
+            /**
+             * Started cache lookup when the source was evaluated to `cache`.
+             */
+            workerCacheLookupStart?: number;
             /**
              * Started sending request.
              */
@@ -9061,6 +10344,10 @@ export namespace Protocol {
              * Time the server finished pushing request.
              */
             pushEnd: number;
+            /**
+             * Started receiving response headers.
+             */
+            receiveHeadersStart: number;
             /**
              * Finished receiving response headers.
              */
@@ -9112,6 +10399,7 @@ export namespace Protocol {
             headers: Headers;
             /**
              * HTTP POST request data.
+             * Use postDataEntries instead.
              */
             postData?: string;
             /**
@@ -9119,7 +10407,7 @@ export namespace Protocol {
              */
             hasPostData?: boolean;
             /**
-             * Request body elements. This will be converted from base64 to binary
+             * Request body elements (post data broken into individual entries).
              */
             postDataEntries?: PostDataEntry[];
             /**
@@ -9145,7 +10433,7 @@ export namespace Protocol {
             trustTokenParams?: TrustTokenParams;
             /**
              * True if this resource request is considered to be the 'same site' as the
-             * request correspondinfg to the main frame.
+             * request corresponding to the main frame.
              */
             isSameSite?: boolean;
         }
@@ -9171,9 +10459,10 @@ export namespace Protocol {
              */
             logId: string;
             /**
-             * Issuance date.
+             * Issuance date. Unlike TimeSinceEpoch, this contains the number of
+             * milliseconds since January 1, 1970, UTC, not the number of seconds.
              */
-            timestamp: TimeSinceEpoch;
+            timestamp: number;
             /**
              * Hash algorithm.
              */
@@ -9244,6 +10533,16 @@ export namespace Protocol {
              * Whether the request complied with Certificate Transparency policy
              */
             certificateTransparencyCompliance: CertificateTransparencyCompliance;
+            /**
+             * The signature algorithm used by the server in the TLS server signature,
+             * represented as a TLS SignatureScheme code point. Omitted if not
+             * applicable or not known.
+             */
+            serverSignatureAlgorithm?: integer;
+            /**
+             * Whether the connection used Encrypted ClientHello
+             */
+            encryptedClientHello: boolean;
         }
 
         /**
@@ -9254,12 +10553,12 @@ export namespace Protocol {
         /**
          * The reason why request was blocked.
          */
-        export type BlockedReason = ('other' | 'csp' | 'mixed-content' | 'origin' | 'inspector' | 'subresource-filter' | 'content-type' | 'coep-frame-resource-needs-coep-header' | 'coop-sandboxed-iframe-cannot-navigate-to-coop-page' | 'corp-not-same-origin' | 'corp-not-same-origin-after-defaulted-to-same-origin-by-coep' | 'corp-not-same-site');
+        export type BlockedReason = ('other' | 'csp' | 'mixed-content' | 'origin' | 'inspector' | 'subresource-filter' | 'content-type' | 'coep-frame-resource-needs-coep-header' | 'coop-sandboxed-iframe-cannot-navigate-to-coop-page' | 'corp-not-same-origin' | 'corp-not-same-origin-after-defaulted-to-same-origin-by-coep' | 'corp-not-same-origin-after-defaulted-to-same-origin-by-dip' | 'corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip' | 'corp-not-same-site');
 
         /**
          * The reason why request was blocked.
          */
-        export type CorsError = ('DisallowedByMode' | 'InvalidResponse' | 'WildcardOriginNotAllowed' | 'MissingAllowOriginHeader' | 'MultipleAllowOriginValues' | 'InvalidAllowOriginValue' | 'AllowOriginMismatch' | 'InvalidAllowCredentials' | 'CorsDisabledScheme' | 'PreflightInvalidStatus' | 'PreflightDisallowedRedirect' | 'PreflightWildcardOriginNotAllowed' | 'PreflightMissingAllowOriginHeader' | 'PreflightMultipleAllowOriginValues' | 'PreflightInvalidAllowOriginValue' | 'PreflightAllowOriginMismatch' | 'PreflightInvalidAllowCredentials' | 'PreflightMissingAllowExternal' | 'PreflightInvalidAllowExternal' | 'InvalidAllowMethodsPreflightResponse' | 'InvalidAllowHeadersPreflightResponse' | 'MethodDisallowedByPreflightResponse' | 'HeaderDisallowedByPreflightResponse' | 'RedirectContainsCredentials' | 'InsecurePrivateNetwork' | 'InvalidPrivateNetworkAccess' | 'NoCorsRedirectModeNotFollow');
+        export type CorsError = ('DisallowedByMode' | 'InvalidResponse' | 'WildcardOriginNotAllowed' | 'MissingAllowOriginHeader' | 'MultipleAllowOriginValues' | 'InvalidAllowOriginValue' | 'AllowOriginMismatch' | 'InvalidAllowCredentials' | 'CorsDisabledScheme' | 'PreflightInvalidStatus' | 'PreflightDisallowedRedirect' | 'PreflightWildcardOriginNotAllowed' | 'PreflightMissingAllowOriginHeader' | 'PreflightMultipleAllowOriginValues' | 'PreflightInvalidAllowOriginValue' | 'PreflightAllowOriginMismatch' | 'PreflightInvalidAllowCredentials' | 'PreflightMissingAllowExternal' | 'PreflightInvalidAllowExternal' | 'PreflightMissingAllowPrivateNetwork' | 'PreflightInvalidAllowPrivateNetwork' | 'InvalidAllowMethodsPreflightResponse' | 'InvalidAllowHeadersPreflightResponse' | 'MethodDisallowedByPreflightResponse' | 'HeaderDisallowedByPreflightResponse' | 'RedirectContainsCredentials' | 'InsecurePrivateNetwork' | 'InvalidPrivateNetworkAccess' | 'UnexpectedPrivateNetworkAccess' | 'NoCorsRedirectModeNotFollow' | 'PreflightMissingPrivateNetworkAccessId' | 'PreflightMissingPrivateNetworkAccessName' | 'PrivateNetworkAccessPermissionUnavailable' | 'PrivateNetworkAccessPermissionDenied');
 
         export interface CorsErrorStatus {
             corsError: CorsError;
@@ -9282,9 +10581,9 @@ export namespace Protocol {
          * are specified in third_party/blink/renderer/core/fetch/trust_token.idl.
          */
         export interface TrustTokenParams {
-            type: TrustTokenOperationType;
+            operation: TrustTokenOperationType;
             /**
-             * Only set for "token-redemption" type and determine whether
+             * Only set for "token-redemption" operation and determine whether
              * to request a fresh SRR or use a still valid cached SRR. (TrustTokenParamsRefreshPolicy enum)
              */
             refreshPolicy: ('UseCached' | 'Refresh');
@@ -9297,6 +10596,33 @@ export namespace Protocol {
 
         export type TrustTokenOperationType = ('Issuance' | 'Redemption' | 'Signing');
 
+        /**
+         * The reason why Chrome uses a specific transport protocol for HTTP semantics.
+         */
+        export type AlternateProtocolUsage = ('alternativeJobWonWithoutRace' | 'alternativeJobWonRace' | 'mainJobWonRace' | 'mappingMissing' | 'broken' | 'dnsAlpnH3JobWonWithoutRace' | 'dnsAlpnH3JobWonRace' | 'unspecifiedReason');
+
+        /**
+         * Source of service worker router.
+         */
+        export type ServiceWorkerRouterSource = ('network' | 'cache' | 'fetch-event' | 'race-network-and-fetch-handler');
+
+        export interface ServiceWorkerRouterInfo {
+            /**
+             * ID of the rule matched. If there is a matched rule, this field will
+             * be set, otherwiser no value will be set.
+             */
+            ruleIdMatched?: integer;
+            /**
+             * The router source of the matched rule. If there is a matched rule, this
+             * field will be set, otherwise no value will be set.
+             */
+            matchedSourceType?: ServiceWorkerRouterSource;
+            /**
+             * The actual router source used.
+             */
+            actualSourceType?: ServiceWorkerRouterSource;
+        }
+
         /**
          * HTTP response data.
          */
@@ -9325,6 +10651,10 @@ export namespace Protocol {
              * Resource mimeType as determined by the browser.
              */
             mimeType: string;
+            /**
+             * Resource charset as determined by the browser (if applicable).
+             */
+            charset: string;
             /**
              * Refined HTTP request headers that were actually transmitted over the network.
              */
@@ -9361,6 +10691,17 @@ export namespace Protocol {
              * Specifies that the request was served from the prefetch cache.
              */
             fromPrefetchCache?: boolean;
+            /**
+             * Specifies that the request was served from the prefetch cache.
+             */
+            fromEarlyHints?: boolean;
+            /**
+             * Information about how ServiceWorker Static Router API was used. If this
+             * field is set with `matchedSourceType` field, a matching rule is found.
+             * If this field is set without `matchedSource`, no matching rule is found.
+             * Otherwise, the API is not used.
+             */
+            serviceWorkerRouterInfo?: ServiceWorkerRouterInfo;
             /**
              * Total number of bytes received for this request so far.
              */
@@ -9385,6 +10726,10 @@ export namespace Protocol {
              * Protocol used to fetch this request.
              */
             protocol?: string;
+            /**
+             * The reason why Chrome uses a specific transport protocol for HTTP semantics.
+             */
+            alternateProtocolUsage?: AlternateProtocolUsage;
             /**
              * Security state of the request resource.
              */
@@ -9518,6 +10863,22 @@ export namespace Protocol {
             requestId?: RequestId;
         }
 
+        /**
+         * cookiePartitionKey object
+         * The representation of the components of the key that are created by the cookiePartitionKey class contained in net/cookies/cookie_partition_key.h.
+         */
+        export interface CookiePartitionKey {
+            /**
+             * The site of the top-level URL the browser was visiting at the start
+             * of the request to the endpoint that set the cookie.
+             */
+            topLevelSite: string;
+            /**
+             * Indicates if the cookie has any ancestors that are cross-site to the topLevelSite.
+             */
+            hasCrossSiteAncestor: boolean;
+        }
+
         /**
          * Cookie object
          */
@@ -9580,17 +10941,30 @@ export namespace Protocol {
              * This is a temporary ability and it will be removed in the future.
              */
             sourcePort: integer;
+            /**
+             * Cookie partition key.
+             */
+            partitionKey?: CookiePartitionKey;
+            /**
+             * True if cookie partition key is opaque.
+             */
+            partitionKeyOpaque?: boolean;
         }
 
         /**
          * Types of reasons why a cookie may not be stored from a response.
          */
-        export type SetCookieBlockedReason = ('SecureOnly' | 'SameSiteStrict' | 'SameSiteLax' | 'SameSiteUnspecifiedTreatedAsLax' | 'SameSiteNoneInsecure' | 'UserPreferences' | 'SyntaxError' | 'SchemeNotSupported' | 'OverwriteSecure' | 'InvalidDomain' | 'InvalidPrefix' | 'UnknownError' | 'SchemefulSameSiteStrict' | 'SchemefulSameSiteLax' | 'SchemefulSameSiteUnspecifiedTreatedAsLax' | 'SamePartyFromCrossPartyContext' | 'SamePartyConflictsWithOtherAttributes' | 'NameValuePairExceedsMaxSize');
+        export type SetCookieBlockedReason = ('SecureOnly' | 'SameSiteStrict' | 'SameSiteLax' | 'SameSiteUnspecifiedTreatedAsLax' | 'SameSiteNoneInsecure' | 'UserPreferences' | 'ThirdPartyPhaseout' | 'ThirdPartyBlockedInFirstPartySet' | 'SyntaxError' | 'SchemeNotSupported' | 'OverwriteSecure' | 'InvalidDomain' | 'InvalidPrefix' | 'UnknownError' | 'SchemefulSameSiteStrict' | 'SchemefulSameSiteLax' | 'SchemefulSameSiteUnspecifiedTreatedAsLax' | 'SamePartyFromCrossPartyContext' | 'SamePartyConflictsWithOtherAttributes' | 'NameValuePairExceedsMaxSize' | 'DisallowedCharacter' | 'NoCookieContent');
 
         /**
          * Types of reasons why a cookie may not be sent with a request.
          */
-        export type CookieBlockedReason = ('SecureOnly' | 'NotOnPath' | 'DomainMismatch' | 'SameSiteStrict' | 'SameSiteLax' | 'SameSiteUnspecifiedTreatedAsLax' | 'SameSiteNoneInsecure' | 'UserPreferences' | 'UnknownError' | 'SchemefulSameSiteStrict' | 'SchemefulSameSiteLax' | 'SchemefulSameSiteUnspecifiedTreatedAsLax' | 'SamePartyFromCrossPartyContext' | 'NameValuePairExceedsMaxSize');
+        export type CookieBlockedReason = ('SecureOnly' | 'NotOnPath' | 'DomainMismatch' | 'SameSiteStrict' | 'SameSiteLax' | 'SameSiteUnspecifiedTreatedAsLax' | 'SameSiteNoneInsecure' | 'UserPreferences' | 'ThirdPartyPhaseout' | 'ThirdPartyBlockedInFirstPartySet' | 'UnknownError' | 'SchemefulSameSiteStrict' | 'SchemefulSameSiteLax' | 'SchemefulSameSiteUnspecifiedTreatedAsLax' | 'SamePartyFromCrossPartyContext' | 'NameValuePairExceedsMaxSize');
+
+        /**
+         * Types of reasons why a cookie should have been blocked by 3PCD but is exempted for the request.
+         */
+        export type CookieExemptionReason = ('None' | 'UserSetting' | 'TPCDMetadata' | 'TPCDDeprecationTrial' | 'TPCDHeuristics' | 'EnterprisePolicy' | 'StorageAccess' | 'TopLevelStorageAccess' | 'CorsOptIn' | 'Scheme');
 
         /**
          * A cookie which was not stored from a response with the corresponding reason.
@@ -9614,17 +10988,42 @@ export namespace Protocol {
         }
 
         /**
-         * A cookie with was not sent with a request with the corresponding reason.
+         * A cookie should have been blocked by 3PCD but is exempted and stored from a response with the
+         * corresponding reason. A cookie could only have at most one exemption reason.
          */
-        export interface BlockedCookieWithReason {
+        export interface ExemptedSetCookieWithReason {
             /**
-             * The reason(s) the cookie was blocked.
+             * The reason the cookie was exempted.
              */
-            blockedReasons: CookieBlockedReason[];
+            exemptionReason: CookieExemptionReason;
+            /**
+             * The string representing this individual cookie as it would appear in the header.
+             */
+            cookieLine: string;
+            /**
+             * The cookie object representing the cookie.
+             */
+            cookie: Cookie;
+        }
+
+        /**
+         * A cookie associated with the request which may or may not be sent with it.
+         * Includes the cookies itself and reasons for blocking or exemption.
+         */
+        export interface AssociatedCookie {
             /**
              * The cookie object representing the cookie which was not sent.
              */
             cookie: Cookie;
+            /**
+             * The reason(s) the cookie was blocked. If empty means the cookie is included.
+             */
+            blockedReasons: CookieBlockedReason[];
+            /**
+             * The reason the cookie should have been blocked by 3PCD but is exempted. A cookie could
+             * only have at most one exemption reason.
+             */
+            exemptionReason?: CookieExemptionReason;
         }
 
         /**
@@ -9686,6 +11085,10 @@ export namespace Protocol {
              * This is a temporary ability and it will be removed in the future.
              */
             sourcePort?: integer;
+            /**
+             * Cookie partition key. If not set, the cookie will be set as not partitioned.
+             */
+            partitionKey?: CookiePartitionKey;
         }
 
         export const enum AuthChallengeSource {
@@ -9833,7 +11236,7 @@ export namespace Protocol {
              */
             signatures: SignedExchangeSignature[];
             /**
-             * Signed exchange header integrity hash in the form of "sha256-<base64-hash-value>".
+             * Signed exchange header integrity hash in the form of `sha256-<base64-hash-value>`.
              */
             headerIntegrity: string;
         }
@@ -9878,7 +11281,7 @@ export namespace Protocol {
              */
             securityDetails?: SecurityDetails;
             /**
-             * Errors occurred while handling the signed exchagne.
+             * Errors occurred while handling the signed exchange.
              */
             errors?: SignedExchangeError[];
         }
@@ -9886,9 +11289,9 @@ export namespace Protocol {
         /**
          * List of content encodings supported by the backend.
          */
-        export type ContentEncoding = ('deflate' | 'gzip' | 'br');
+        export type ContentEncoding = ('deflate' | 'gzip' | 'br' | 'zstd');
 
-        export type PrivateNetworkRequestPolicy = ('Allow' | 'BlockFromInsecureToMorePrivate' | 'WarnFromInsecureToMorePrivate');
+        export type PrivateNetworkRequestPolicy = ('Allow' | 'BlockFromInsecureToMorePrivate' | 'WarnFromInsecureToMorePrivate' | 'PreflightBlock' | 'PreflightWarn');
 
         export type IPAddressSpace = ('Local' | 'Private' | 'Public' | 'Unknown');
 
@@ -9907,7 +11310,7 @@ export namespace Protocol {
             privateNetworkRequestPolicy: PrivateNetworkRequestPolicy;
         }
 
-        export type CrossOriginOpenerPolicyValue = ('SameOrigin' | 'SameOriginAllowPopups' | 'UnsafeNone' | 'SameOriginPlusCoep');
+        export type CrossOriginOpenerPolicyValue = ('SameOrigin' | 'SameOriginAllowPopups' | 'RestrictProperties' | 'UnsafeNone' | 'SameOriginPlusCoep' | 'RestrictPropertiesPlusCoep' | 'NoopenerAllowPopups');
 
         export interface CrossOriginOpenerPolicyStatus {
             value: CrossOriginOpenerPolicyValue;
@@ -9925,9 +11328,18 @@ export namespace Protocol {
             reportOnlyReportingEndpoint?: string;
         }
 
+        export type ContentSecurityPolicySource = ('HTTP' | 'Meta');
+
+        export interface ContentSecurityPolicyStatus {
+            effectiveDirectives: string;
+            isEnforced: boolean;
+            source: ContentSecurityPolicySource;
+        }
+
         export interface SecurityIsolationStatus {
             coop?: CrossOriginOpenerPolicyStatus;
             coep?: CrossOriginEmbedderPolicyStatus;
+            csp?: ContentSecurityPolicyStatus[];
         }
 
         /**
@@ -9970,6 +11382,17 @@ export namespace Protocol {
             status: ReportStatus;
         }
 
+        export interface ReportingApiEndpoint {
+            /**
+             * The URL of the endpoint to which reports may be delivered.
+             */
+            url: string;
+            /**
+             * Name of the endpoint group.
+             */
+            groupName: string;
+        }
+
         /**
          * An object providing the result of a network resource load.
          */
@@ -10084,6 +11507,11 @@ export namespace Protocol {
              * If specified, deletes only cookies with the exact path.
              */
             path?: string;
+            /**
+             * If specified, deletes only cookies with the the given name and partitionKey where
+             * all partition key attributes match the cookie partition key attribute.
+             */
+            partitionKey?: CookiePartitionKey;
         }
 
         export interface EmulateNetworkConditionsRequest {
@@ -10107,6 +11535,18 @@ export namespace Protocol {
              * Connection type if known.
              */
             connectionType?: ConnectionType;
+            /**
+             * WebRTC packet loss (percent, 0-100). 0 disables packet loss emulation, 100 drops all the packets.
+             */
+            packetLoss?: number;
+            /**
+             * WebRTC packet queue length (packet). 0 removes any queue length limitations.
+             */
+            packetQueueLength?: integer;
+            /**
+             * WebRTC packetReordering feature.
+             */
+            packetReordering?: boolean;
         }
 
         export interface EnableRequest {
@@ -10326,6 +11766,10 @@ export namespace Protocol {
              * This is a temporary ability and it will be removed in the future.
              */
             sourcePort?: integer;
+            /**
+             * Cookie partition key. If not set, the cookie will be set as not partitioned.
+             */
+            partitionKey?: CookiePartitionKey;
         }
 
         export interface SetCookieResponse {
@@ -10370,7 +11814,7 @@ export namespace Protocol {
              */
             userAgent: string;
             /**
-             * Browser langugage to emulate.
+             * Browser language to emulate.
              */
             acceptLanguage?: string;
             /**
@@ -10383,6 +11827,20 @@ export namespace Protocol {
             userAgentMetadata?: Emulation.UserAgentMetadata;
         }
 
+        export interface StreamResourceContentRequest {
+            /**
+             * Identifier of the request to stream.
+             */
+            requestId: RequestId;
+        }
+
+        export interface StreamResourceContentResponse {
+            /**
+             * Data that has been buffered until streaming is enabled. (Encoded as a base64 string when passed over JSON)
+             */
+            bufferedData: string;
+        }
+
         export interface GetSecurityIsolationStatusRequest {
             /**
              * If no frameId is provided, the status of the target is provided.
@@ -10441,6 +11899,10 @@ export namespace Protocol {
              * Actual bytes received (might be less than dataLength for compressed encodings).
              */
             encodedDataLength: integer;
+            /**
+             * Data that was received. (Encoded as a base64 string when passed over JSON)
+             */
+            data?: string;
         }
 
         /**
@@ -10486,7 +11948,7 @@ export namespace Protocol {
              */
             type: ResourceType;
             /**
-             * User friendly error message.
+             * Error message. List of network errors: https://cs.chromium.org/chromium/src/net/base/net_error_list.h
              */
             errorText: string;
             /**
@@ -10519,11 +11981,6 @@ export namespace Protocol {
              * Total number of bytes received for this request.
              */
             encodedDataLength: number;
-            /**
-             * Set when 1) response was blocked by Cross-Origin Read Blocking and also
-             * 2) this needs to be reported to the DevTools console.
-             */
-            shouldReportCorbBlocking?: boolean;
         }
 
         /**
@@ -10629,6 +12086,12 @@ export namespace Protocol {
              * Request initiator.
              */
             initiator: Initiator;
+            /**
+             * In the case that redirectResponse is populated, this flag indicates whether
+             * requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted
+             * for the request which was just redirected.
+             */
+            redirectHasExtraInfo: boolean;
             /**
              * Redirect response data.
              */
@@ -10703,6 +12166,11 @@ export namespace Protocol {
              * Response data.
              */
             response: Response;
+            /**
+             * Indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be
+             * or were emitted for this request.
+             */
+            hasExtraInfo: boolean;
             /**
              * Frame identifier.
              */
@@ -10898,9 +12366,9 @@ export namespace Protocol {
             requestId: RequestId;
             /**
              * A list of cookies potentially associated to the requested URL. This includes both cookies sent with
-             * the request and the ones not sent; the latter are distinguished by having blockedReason field set.
+             * the request and the ones not sent; the latter are distinguished by having blockedReasons field set.
              */
-            associatedCookies: BlockedCookieWithReason[];
+            associatedCookies: AssociatedCookie[];
             /**
              * Raw request headers as they will be sent over the wire.
              */
@@ -10913,6 +12381,10 @@ export namespace Protocol {
              * The client security state set for the request.
              */
             clientSecurityState?: ClientSecurityState;
+            /**
+             * Whether the site has partitioned cookies stored in a partition different than the current one.
+             */
+            siteHasCookieInOtherPartition?: boolean;
         }
 
         /**
@@ -10951,15 +12423,47 @@ export namespace Protocol {
              * available, such as in the case of HTTP/2 or QUIC.
              */
             headersText?: string;
-        }
-
+            /**
+             * The cookie partition key that will be used to store partitioned cookies set in this response.
+             * Only sent when partitioned cookies are enabled.
+             */
+            cookiePartitionKey?: CookiePartitionKey;
+            /**
+             * True if partitioned cookies are enabled, but the partition key is not serializable to string.
+             */
+            cookiePartitionKeyOpaque?: boolean;
+            /**
+             * A list of cookies which should have been blocked by 3PCD but are exempted and stored from
+             * the response with the corresponding reason.
+             */
+            exemptedCookies?: ExemptedSetCookieWithReason[];
+        }
+
+        /**
+         * Fired when 103 Early Hints headers is received in addition to the common response.
+         * Not every responseReceived event will have an responseReceivedEarlyHints fired.
+         * Only one responseReceivedEarlyHints may be fired for eached responseReceived event.
+         */
+        export interface ResponseReceivedEarlyHintsEvent {
+            /**
+             * Request identifier. Used to match this information to another responseReceived event.
+             */
+            requestId: RequestId;
+            /**
+             * Raw response headers as they were received over the wire.
+             */
+            headers: Headers;
+        }
+
         export const enum TrustTokenOperationDoneEventStatus {
             Ok = 'Ok',
             InvalidArgument = 'InvalidArgument',
+            MissingIssuerKeys = 'MissingIssuerKeys',
             FailedPrecondition = 'FailedPrecondition',
             ResourceExhausted = 'ResourceExhausted',
             AlreadyExists = 'AlreadyExists',
-            Unavailable = 'Unavailable',
+            ResourceLimited = 'ResourceLimited',
+            Unauthorized = 'Unauthorized',
             BadResponse = 'BadResponse',
             InternalError = 'InternalError',
             UnknownError = 'UnknownError',
@@ -10979,7 +12483,7 @@ export namespace Protocol {
              * of the operation already exists und thus, the operation was abort
              * preemptively (e.g. a cache hit). (TrustTokenOperationDoneEventStatus enum)
              */
-            status: ('Ok' | 'InvalidArgument' | 'FailedPrecondition' | 'ResourceExhausted' | 'AlreadyExists' | 'Unavailable' | 'BadResponse' | 'InternalError' | 'UnknownError' | 'FulfilledLocally');
+            status: ('Ok' | 'InvalidArgument' | 'MissingIssuerKeys' | 'FailedPrecondition' | 'ResourceExhausted' | 'AlreadyExists' | 'ResourceLimited' | 'Unauthorized' | 'BadResponse' | 'InternalError' | 'UnknownError' | 'FulfilledLocally');
             type: TrustTokenOperationType;
             requestId: RequestId;
             /**
@@ -11081,6 +12585,14 @@ export namespace Protocol {
         export interface ReportingApiReportUpdatedEvent {
             report: ReportingApiReport;
         }
+
+        export interface ReportingApiEndpointsChangedForOriginEvent {
+            /**
+             * Origin of the document(s) which configured the endpoints.
+             */
+            origin: string;
+            endpoints: ReportingApiEndpoint[];
+        }
     }
 
     /**
@@ -11093,7 +12605,7 @@ export namespace Protocol {
          */
         export interface SourceOrderConfig {
             /**
-             * the color to outline the givent element in.
+             * the color to outline the given element in.
              */
             parentOutlineColor: DOM.RGBA;
             /**
@@ -11361,7 +12873,7 @@ export namespace Protocol {
             containerQueryContainerHighlightConfig?: ContainerQueryContainerHighlightConfig;
         }
 
-        export type ColorFormat = ('rgb' | 'hsl' | 'hex');
+        export type ColorFormat = ('rgb' | 'hsl' | 'hwb' | 'hex');
 
         /**
          * Configurations for Persistent Grid Highlight
@@ -11436,6 +12948,24 @@ export namespace Protocol {
             outlineColor?: DOM.RGBA;
         }
 
+        /**
+         * Configuration for Window Controls Overlay
+         */
+        export interface WindowControlsOverlayConfig {
+            /**
+             * Whether the title bar CSS should be shown when emulating the Window Controls Overlay.
+             */
+            showCSS: boolean;
+            /**
+             * Selected platforms to show the overlay.
+             */
+            selectedPlatform: string;
+            /**
+             * The theme color defined in app manifest.
+             */
+            themeColor: string;
+        }
+
         export interface ContainerQueryHighlightConfig {
             /**
              * A descriptor for the highlight appearance of container query containers.
@@ -11764,6 +13294,13 @@ export namespace Protocol {
             isolatedElementHighlightConfigs: IsolatedElementHighlightConfig[];
         }
 
+        export interface SetShowWindowControlsOverlayRequest {
+            /**
+             * Window Controls Overlay data, null means hide Window Controls Overlay
+             */
+            windowControlsOverlayConfig?: WindowControlsOverlayConfig;
+        }
+
         /**
          * Fired when the node should be inspected. This happens after call to `setInspectMode` or when
          * user manually inspects an element.
@@ -11818,6 +13355,22 @@ export namespace Protocol {
             explanations?: AdFrameExplanation[];
         }
 
+        /**
+         * Identifies the bottom-most script which caused the frame to be labelled
+         * as an ad.
+         */
+        export interface AdScriptId {
+            /**
+             * Script Id of the bottom-most script which caused the frame to be labelled
+             * as an ad.
+             */
+            scriptId: Runtime.ScriptId;
+            /**
+             * Id of adScriptId's debugger.
+             */
+            debuggerId: Runtime.UniqueDebuggerId;
+        }
+
         /**
          * Indicates whether the frame is a secure context and why it is the case.
          */
@@ -11834,12 +13387,12 @@ export namespace Protocol {
          * All Permissions Policy features. This enum should match the one defined
          * in third_party/blink/renderer/core/permissions_policy/permissions_policy_features.json5.
          */
-        export type PermissionsPolicyFeature = ('accelerometer' | 'ambient-light-sensor' | 'attribution-reporting' | 'autoplay' | 'camera' | 'ch-dpr' | 'ch-device-memory' | 'ch-downlink' | 'ch-ect' | 'ch-prefers-color-scheme' | 'ch-rtt' | 'ch-ua' | 'ch-ua-arch' | 'ch-ua-bitness' | 'ch-ua-platform' | 'ch-ua-model' | 'ch-ua-mobile' | 'ch-ua-full-version' | 'ch-ua-platform-version' | 'ch-ua-reduced' | 'ch-viewport-height' | 'ch-viewport-width' | 'ch-width' | 'clipboard-read' | 'clipboard-write' | 'cross-origin-isolated' | 'direct-sockets' | 'display-capture' | 'document-domain' | 'encrypted-media' | 'execution-while-out-of-viewport' | 'execution-while-not-rendered' | 'focus-without-user-activation' | 'fullscreen' | 'frobulate' | 'gamepad' | 'geolocation' | 'gyroscope' | 'hid' | 'idle-detection' | 'interest-cohort' | 'magnetometer' | 'microphone' | 'midi' | 'otp-credentials' | 'payment' | 'picture-in-picture' | 'publickey-credentials-get' | 'screen-wake-lock' | 'serial' | 'shared-autofill' | 'storage-access-api' | 'sync-xhr' | 'trust-token-redemption' | 'usb' | 'vertical-scroll' | 'web-share' | 'window-placement' | 'xr-spatial-tracking');
+        export type PermissionsPolicyFeature = ('accelerometer' | 'all-screens-capture' | 'ambient-light-sensor' | 'attribution-reporting' | 'autoplay' | 'bluetooth' | 'browsing-topics' | 'camera' | 'captured-surface-control' | 'ch-dpr' | 'ch-device-memory' | 'ch-downlink' | 'ch-ect' | 'ch-prefers-color-scheme' | 'ch-prefers-reduced-motion' | 'ch-prefers-reduced-transparency' | 'ch-rtt' | 'ch-save-data' | 'ch-ua' | 'ch-ua-arch' | 'ch-ua-bitness' | 'ch-ua-platform' | 'ch-ua-model' | 'ch-ua-mobile' | 'ch-ua-form-factors' | 'ch-ua-full-version' | 'ch-ua-full-version-list' | 'ch-ua-platform-version' | 'ch-ua-wow64' | 'ch-viewport-height' | 'ch-viewport-width' | 'ch-width' | 'clipboard-read' | 'clipboard-write' | 'compute-pressure' | 'cross-origin-isolated' | 'deferred-fetch' | 'digital-credentials-get' | 'direct-sockets' | 'display-capture' | 'document-domain' | 'encrypted-media' | 'execution-while-out-of-viewport' | 'execution-while-not-rendered' | 'focus-without-user-activation' | 'fullscreen' | 'frobulate' | 'gamepad' | 'geolocation' | 'gyroscope' | 'hid' | 'identity-credentials-get' | 'idle-detection' | 'interest-cohort' | 'join-ad-interest-group' | 'keyboard-map' | 'local-fonts' | 'magnetometer' | 'media-playback-while-not-visible' | 'microphone' | 'midi' | 'otp-credentials' | 'payment' | 'picture-in-picture' | 'popins' | 'private-aggregation' | 'private-state-token-issuance' | 'private-state-token-redemption' | 'publickey-credentials-create' | 'publickey-credentials-get' | 'run-ad-auction' | 'screen-wake-lock' | 'serial' | 'shared-autofill' | 'shared-storage' | 'shared-storage-select-url' | 'smart-card' | 'speaker-selection' | 'storage-access' | 'sub-apps' | 'sync-xhr' | 'unload' | 'usb' | 'usb-unrestricted' | 'vertical-scroll' | 'web-app-installation' | 'web-printing' | 'web-share' | 'window-management' | 'xr-spatial-tracking');
 
         /**
          * Reason for a permissions policy feature to be disabled.
          */
-        export type PermissionsPolicyBlockReason = ('Header' | 'IframeAttribute');
+        export type PermissionsPolicyBlockReason = ('Header' | 'IframeAttribute' | 'InFencedFrameTree' | 'InIsolatedApp');
 
         export interface PermissionsPolicyBlockLocator {
             frameId: FrameId;
@@ -12105,7 +13658,7 @@ export namespace Protocol {
              */
             message: string;
             /**
-             * If criticial, this is a non-recoverable parse error.
+             * If critical, this is a non-recoverable parse error.
              */
             critical: integer;
             /**
@@ -12243,9 +13796,23 @@ export namespace Protocol {
              */
             fantasy?: string;
             /**
-             * The pictograph font-family.
+             * The math font-family.
+             */
+            math?: string;
+        }
+
+        /**
+         * Font families collection for a script.
+         */
+        export interface ScriptFontFamilies {
+            /**
+             * Name of the script which these font families are defined for.
+             */
+            script: string;
+            /**
+             * Generic font families collection for the script.
              */
-            pictograph?: string;
+            fontFamilies: FontFamilies;
         }
 
         /**
@@ -12262,7 +13829,7 @@ export namespace Protocol {
             fixed?: integer;
         }
 
-        export type ClientNavigationReason = ('formSubmissionGet' | 'formSubmissionPost' | 'httpHeaderRefresh' | 'scriptInitiated' | 'metaTagRefresh' | 'pageBlockInterstitial' | 'reload' | 'anchorClick');
+        export type ClientNavigationReason = ('anchorClick' | 'formSubmissionGet' | 'formSubmissionPost' | 'httpHeaderRefresh' | 'initialFrameNavigation' | 'metaTagRefresh' | 'other' | 'pageBlockInterstitial' | 'reload' | 'scriptInitiated');
 
         export type ClientNavigationDisposition = ('currentTab' | 'newTab' | 'newWindow' | 'download');
 
@@ -12311,6 +13878,141 @@ export namespace Protocol {
             eager?: boolean;
         }
 
+        export interface FileFilter {
+            name?: string;
+            accepts?: string[];
+        }
+
+        export interface FileHandler {
+            action: string;
+            name: string;
+            icons?: ImageResource[];
+            /**
+             * Mimic a map, name is the key, accepts is the value.
+             */
+            accepts?: FileFilter[];
+            /**
+             * Won't repeat the enums, using string for easy comparison. Same as the
+             * other enums below.
+             */
+            launchType: string;
+        }
+
+        /**
+         * The image definition used in both icon and screenshot.
+         */
+        export interface ImageResource {
+            /**
+             * The src field in the definition, but changing to url in favor of
+             * consistency.
+             */
+            url: string;
+            sizes?: string;
+            type?: string;
+        }
+
+        export interface LaunchHandler {
+            clientMode: string;
+        }
+
+        export interface ProtocolHandler {
+            protocol: string;
+            url: string;
+        }
+
+        export interface RelatedApplication {
+            id?: string;
+            url: string;
+        }
+
+        export interface ScopeExtension {
+            /**
+             * Instead of using tuple, this field always returns the serialized string
+             * for easy understanding and comparison.
+             */
+            origin: string;
+            hasOriginWildcard: boolean;
+        }
+
+        export interface Screenshot {
+            image: ImageResource;
+            formFactor: string;
+            label?: string;
+        }
+
+        export interface ShareTarget {
+            action: string;
+            method: string;
+            enctype: string;
+            /**
+             * Embed the ShareTargetParams
+             */
+            title?: string;
+            text?: string;
+            url?: string;
+            files?: FileFilter[];
+        }
+
+        export interface Shortcut {
+            name: string;
+            url: string;
+        }
+
+        export interface WebAppManifest {
+            backgroundColor?: string;
+            /**
+             * The extra description provided by the manifest.
+             */
+            description?: string;
+            dir?: string;
+            display?: string;
+            /**
+             * The overrided display mode controlled by the user.
+             */
+            displayOverrides?: string[];
+            /**
+             * The handlers to open files.
+             */
+            fileHandlers?: FileHandler[];
+            icons?: ImageResource[];
+            id?: string;
+            lang?: string;
+            /**
+             * TODO(crbug.com/1231886): This field is non-standard and part of a Chrome
+             * experiment. See:
+             * https://github.com/WICG/web-app-launch/blob/main/launch_handler.md
+             */
+            launchHandler?: LaunchHandler;
+            name?: string;
+            orientation?: string;
+            preferRelatedApplications?: boolean;
+            /**
+             * The handlers to open protocols.
+             */
+            protocolHandlers?: ProtocolHandler[];
+            relatedApplications?: RelatedApplication[];
+            scope?: string;
+            /**
+             * Non-standard, see
+             * https://github.com/WICG/manifest-incubations/blob/gh-pages/scope_extensions-explainer.md
+             */
+            scopeExtensions?: ScopeExtension[];
+            /**
+             * The screenshots used by chromium.
+             */
+            screenshots?: Screenshot[];
+            shareTarget?: ShareTarget;
+            shortName?: string;
+            shortcuts?: Shortcut[];
+            startUrl?: string;
+            themeColor?: string;
+        }
+
+        /**
+         * Enum of possible auto-response for permission / prompt dialogs.
+         */
+        export type AutoResponseMode = ('none' | 'autoAccept' | 'autoReject' | 'autoOptOut');
+
         /**
          * The type of a frameNavigated event.
          */
@@ -12319,13 +14021,32 @@ export namespace Protocol {
         /**
          * List of not restored reasons for back-forward cache.
          */
-        export type BackForwardCacheNotRestoredReason = ('NotMainFrame' | 'BackForwardCacheDisabled' | 'RelatedActiveContentsExist' | 'HTTPStatusNotOK' | 'SchemeNotHTTPOrHTTPS' | 'Loading' | 'WasGrantedMediaAccess' | 'DisableForRenderFrameHostCalled' | 'DomainNotAllowed' | 'HTTPMethodNotGET' | 'SubframeIsNavigating' | 'Timeout' | 'CacheLimit' | 'JavaScriptExecution' | 'RendererProcessKilled' | 'RendererProcessCrashed' | 'GrantedMediaStreamAccess' | 'SchedulerTrackedFeatureUsed' | 'ConflictingBrowsingInstance' | 'CacheFlushed' | 'ServiceWorkerVersionActivation' | 'SessionRestored' | 'ServiceWorkerPostMessage' | 'EnteredBackForwardCacheBeforeServiceWorkerHostAdded' | 'RenderFrameHostReused_SameSite' | 'RenderFrameHostReused_CrossSite' | 'ServiceWorkerClaim' | 'IgnoreEventAndEvict' | 'HaveInnerContents' | 'TimeoutPuttingInCache' | 'BackForwardCacheDisabledByLowMemory' | 'BackForwardCacheDisabledByCommandLine' | 'NetworkRequestDatapipeDrainedAsBytesConsumer' | 'NetworkRequestRedirected' | 'NetworkRequestTimeout' | 'NetworkExceedsBufferLimit' | 'NavigationCancelledWhileRestoring' | 'NotMostRecentNavigationEntry' | 'BackForwardCacheDisabledForPrerender' | 'UserAgentOverrideDiffers' | 'ForegroundCacheLimit' | 'BrowsingInstanceNotSwapped' | 'BackForwardCacheDisabledForDelegate' | 'OptInUnloadHeaderNotPresent' | 'UnloadHandlerExistsInMainFrame' | 'UnloadHandlerExistsInSubFrame' | 'ServiceWorkerUnregistration' | 'CacheControlNoStore' | 'CacheControlNoStoreCookieModified' | 'CacheControlNoStoreHTTPOnlyCookieModified' | 'NoResponseHead' | 'Unknown' | 'ActivationNavigationsDisallowedForBug1234857' | 'WebSocket' | 'WebTransport' | 'WebRTC' | 'MainResourceHasCacheControlNoStore' | 'MainResourceHasCacheControlNoCache' | 'SubresourceHasCacheControlNoStore' | 'SubresourceHasCacheControlNoCache' | 'ContainsPlugins' | 'DocumentLoaded' | 'DedicatedWorkerOrWorklet' | 'OutstandingNetworkRequestOthers' | 'OutstandingIndexedDBTransaction' | 'RequestedNotificationsPermission' | 'RequestedMIDIPermission' | 'RequestedAudioCapturePermission' | 'RequestedVideoCapturePermission' | 'RequestedBackForwardCacheBlockedSensors' | 'RequestedBackgroundWorkPermission' | 'BroadcastChannel' | 'IndexedDBConnection' | 'WebXR' | 'SharedWorker' | 'WebLocks' | 'WebHID' | 'WebShare' | 'RequestedStorageAccessGrant' | 'WebNfc' | 'OutstandingNetworkRequestFetch' | 'OutstandingNetworkRequestXHR' | 'AppBanner' | 'Printing' | 'WebDatabase' | 'PictureInPicture' | 'Portal' | 'SpeechRecognizer' | 'IdleManager' | 'PaymentManager' | 'SpeechSynthesis' | 'KeyboardLock' | 'WebOTPService' | 'OutstandingNetworkRequestDirectSocket' | 'InjectedJavascript' | 'InjectedStyleSheet' | 'Dummy' | 'ContentSecurityHandler' | 'ContentWebAuthenticationAPI' | 'ContentFileChooser' | 'ContentSerial' | 'ContentFileSystemAccess' | 'ContentMediaDevicesDispatcherHost' | 'ContentWebBluetooth' | 'ContentWebUSB' | 'ContentMediaSession' | 'ContentMediaSessionService' | 'ContentMediaPlay' | 'EmbedderPopupBlockerTabHelper' | 'EmbedderSafeBrowsingTriggeredPopupBlocker' | 'EmbedderSafeBrowsingThreatDetails' | 'EmbedderAppBannerManager' | 'EmbedderDomDistillerViewerSource' | 'EmbedderDomDistillerSelfDeletingRequestDelegate' | 'EmbedderOomInterventionTabHelper' | 'EmbedderOfflinePage' | 'EmbedderChromePasswordManagerClientBindCredentialManager' | 'EmbedderPermissionRequestManager' | 'EmbedderModalDialog' | 'EmbedderExtensions' | 'EmbedderExtensionMessaging' | 'EmbedderExtensionMessagingForOpenPort' | 'EmbedderExtensionSentMessageToCachedFrame');
+        export type BackForwardCacheNotRestoredReason = ('NotPrimaryMainFrame' | 'BackForwardCacheDisabled' | 'RelatedActiveContentsExist' | 'HTTPStatusNotOK' | 'SchemeNotHTTPOrHTTPS' | 'Loading' | 'WasGrantedMediaAccess' | 'DisableForRenderFrameHostCalled' | 'DomainNotAllowed' | 'HTTPMethodNotGET' | 'SubframeIsNavigating' | 'Timeout' | 'CacheLimit' | 'JavaScriptExecution' | 'RendererProcessKilled' | 'RendererProcessCrashed' | 'SchedulerTrackedFeatureUsed' | 'ConflictingBrowsingInstance' | 'CacheFlushed' | 'ServiceWorkerVersionActivation' | 'SessionRestored' | 'ServiceWorkerPostMessage' | 'EnteredBackForwardCacheBeforeServiceWorkerHostAdded' | 'RenderFrameHostReused_SameSite' | 'RenderFrameHostReused_CrossSite' | 'ServiceWorkerClaim' | 'IgnoreEventAndEvict' | 'HaveInnerContents' | 'TimeoutPuttingInCache' | 'BackForwardCacheDisabledByLowMemory' | 'BackForwardCacheDisabledByCommandLine' | 'NetworkRequestDatapipeDrainedAsBytesConsumer' | 'NetworkRequestRedirected' | 'NetworkRequestTimeout' | 'NetworkExceedsBufferLimit' | 'NavigationCancelledWhileRestoring' | 'NotMostRecentNavigationEntry' | 'BackForwardCacheDisabledForPrerender' | 'UserAgentOverrideDiffers' | 'ForegroundCacheLimit' | 'BrowsingInstanceNotSwapped' | 'BackForwardCacheDisabledForDelegate' | 'UnloadHandlerExistsInMainFrame' | 'UnloadHandlerExistsInSubFrame' | 'ServiceWorkerUnregistration' | 'CacheControlNoStore' | 'CacheControlNoStoreCookieModified' | 'CacheControlNoStoreHTTPOnlyCookieModified' | 'NoResponseHead' | 'Unknown' | 'ActivationNavigationsDisallowedForBug1234857' | 'ErrorDocument' | 'FencedFramesEmbedder' | 'CookieDisabled' | 'HTTPAuthRequired' | 'CookieFlushed' | 'BroadcastChannelOnMessage' | 'WebViewSettingsChanged' | 'WebViewJavaScriptObjectChanged' | 'WebViewMessageListenerInjected' | 'WebViewSafeBrowsingAllowlistChanged' | 'WebViewDocumentStartJavascriptChanged' | 'WebSocket' | 'WebTransport' | 'WebRTC' | 'MainResourceHasCacheControlNoStore' | 'MainResourceHasCacheControlNoCache' | 'SubresourceHasCacheControlNoStore' | 'SubresourceHasCacheControlNoCache' | 'ContainsPlugins' | 'DocumentLoaded' | 'OutstandingNetworkRequestOthers' | 'RequestedMIDIPermission' | 'RequestedAudioCapturePermission' | 'RequestedVideoCapturePermission' | 'RequestedBackForwardCacheBlockedSensors' | 'RequestedBackgroundWorkPermission' | 'BroadcastChannel' | 'WebXR' | 'SharedWorker' | 'WebLocks' | 'WebHID' | 'WebShare' | 'RequestedStorageAccessGrant' | 'WebNfc' | 'OutstandingNetworkRequestFetch' | 'OutstandingNetworkRequestXHR' | 'AppBanner' | 'Printing' | 'WebDatabase' | 'PictureInPicture' | 'SpeechRecognizer' | 'IdleManager' | 'PaymentManager' | 'SpeechSynthesis' | 'KeyboardLock' | 'WebOTPService' | 'OutstandingNetworkRequestDirectSocket' | 'InjectedJavascript' | 'InjectedStyleSheet' | 'KeepaliveRequest' | 'IndexedDBEvent' | 'Dummy' | 'JsNetworkRequestReceivedCacheControlNoStoreResource' | 'WebRTCSticky' | 'WebTransportSticky' | 'WebSocketSticky' | 'SmartCard' | 'LiveMediaStreamTrack' | 'UnloadHandler' | 'ParserAborted' | 'ContentSecurityHandler' | 'ContentWebAuthenticationAPI' | 'ContentFileChooser' | 'ContentSerial' | 'ContentFileSystemAccess' | 'ContentMediaDevicesDispatcherHost' | 'ContentWebBluetooth' | 'ContentWebUSB' | 'ContentMediaSessionService' | 'ContentScreenReader' | 'ContentDiscarded' | 'EmbedderPopupBlockerTabHelper' | 'EmbedderSafeBrowsingTriggeredPopupBlocker' | 'EmbedderSafeBrowsingThreatDetails' | 'EmbedderAppBannerManager' | 'EmbedderDomDistillerViewerSource' | 'EmbedderDomDistillerSelfDeletingRequestDelegate' | 'EmbedderOomInterventionTabHelper' | 'EmbedderOfflinePage' | 'EmbedderChromePasswordManagerClientBindCredentialManager' | 'EmbedderPermissionRequestManager' | 'EmbedderModalDialog' | 'EmbedderExtensions' | 'EmbedderExtensionMessaging' | 'EmbedderExtensionMessagingForOpenPort' | 'EmbedderExtensionSentMessageToCachedFrame' | 'RequestedByWebViewClient');
 
         /**
          * Types of not restored reasons for back-forward cache.
          */
         export type BackForwardCacheNotRestoredReasonType = ('SupportPending' | 'PageSupportNeeded' | 'Circumstantial');
 
+        export interface BackForwardCacheBlockingDetails {
+            /**
+             * Url of the file where blockage happened. Optional because of tests.
+             */
+            url?: string;
+            /**
+             * Function name where blockage happened. Optional because of anonymous functions and tests.
+             */
+            function?: string;
+            /**
+             * Line number in the script (0-based).
+             */
+            lineNumber: integer;
+            /**
+             * Column number in the script (0-based).
+             */
+            columnNumber: integer;
+        }
+
         export interface BackForwardCacheNotRestoredExplanation {
             /**
              * Type of the reason
@@ -12335,6 +14056,28 @@ export namespace Protocol {
              * Not restored reason
              */
             reason: BackForwardCacheNotRestoredReason;
+            /**
+             * Context associated with the reason. The meaning of this context is
+             * dependent on the reason:
+             * - EmbedderExtensionSentMessageToCachedFrame: the extension ID.
+             */
+            context?: string;
+            details?: BackForwardCacheBlockingDetails[];
+        }
+
+        export interface BackForwardCacheNotRestoredExplanationTree {
+            /**
+             * URL of each frame
+             */
+            url: string;
+            /**
+             * Not restored reasons of each frame
+             */
+            explanations: BackForwardCacheNotRestoredExplanation[];
+            /**
+             * Array of children frame
+             */
+            children: BackForwardCacheNotRestoredExplanationTree[];
         }
 
         export interface AddScriptToEvaluateOnLoadRequest {
@@ -12361,6 +14104,11 @@ export namespace Protocol {
              * to false.
              */
             includeCommandLineAPI?: boolean;
+            /**
+             * If true, runs the script immediately on existing execution contexts or worlds.
+             * Default: false.
+             */
+            runImmediately?: boolean;
         }
 
         export interface AddScriptToEvaluateOnNewDocumentResponse {
@@ -12397,6 +14145,10 @@ export namespace Protocol {
              * Capture the screenshot beyond the viewport. Defaults to false.
              */
             captureBeyondViewport?: boolean;
+            /**
+             * Optimize image encoding for speed, not for resulting size (defaults to false)
+             */
+            optimizeForSpeed?: boolean;
         }
 
         export interface CaptureScreenshotResponse {
@@ -12458,6 +14210,10 @@ export namespace Protocol {
             url: string;
         }
 
+        export interface GetAppManifestRequest {
+            manifestId?: string;
+        }
+
         export interface GetAppManifestResponse {
             /**
              * Manifest location.
@@ -12469,9 +14225,10 @@ export namespace Protocol {
              */
             data?: string;
             /**
-             * Parsed manifest properties
+             * Parsed manifest properties. Deprecated, use manifest instead.
              */
             parsed?: AppManifestParsedProperties;
+            manifest: WebAppManifest;
         }
 
         export interface GetInstallabilityErrorsResponse {
@@ -12493,11 +14250,16 @@ export namespace Protocol {
             recommendedId?: string;
         }
 
-        export interface GetCookiesResponse {
+        export interface GetAdScriptIdRequest {
+            frameId: FrameId;
+        }
+
+        export interface GetAdScriptIdResponse {
             /**
-             * Array of cookie objects.
+             * Identifies the bottom-most script which caused the frame to be labelled
+             * as an ad. Only sent if frame is labelled as an ad and id is available.
              */
-            cookies: Network.Cookie[];
+            adScriptId?: AdScriptId;
         }
 
         export interface GetFrameTreeResponse {
@@ -12509,15 +14271,15 @@ export namespace Protocol {
 
         export interface GetLayoutMetricsResponse {
             /**
-             * Deprecated metrics relating to the layout viewport. Can be in DP or in CSS pixels depending on the `enable-use-zoom-for-dsf` flag. Use `cssLayoutViewport` instead.
+             * Deprecated metrics relating to the layout viewport. Is in device pixels. Use `cssLayoutViewport` instead.
              */
             layoutViewport: LayoutViewport;
             /**
-             * Deprecated metrics relating to the visual viewport. Can be in DP or in CSS pixels depending on the `enable-use-zoom-for-dsf` flag. Use `cssVisualViewport` instead.
+             * Deprecated metrics relating to the visual viewport. Is in device pixels. Use `cssVisualViewport` instead.
              */
             visualViewport: VisualViewport;
             /**
-             * Deprecated size of scrollable area. Can be in DP or in CSS pixels depending on the `enable-use-zoom-for-dsf` flag. Use `cssContentSize` instead.
+             * Deprecated size of scrollable area. Is in DP. Use `cssContentSize` instead.
              */
             contentSize: DOM.Rect;
             /**
@@ -12615,7 +14377,8 @@ export namespace Protocol {
              */
             frameId: FrameId;
             /**
-             * Loader identifier.
+             * Loader identifier. This is omitted in case of same-document navigation,
+             * as the previously committed loaderId would not change.
              */
             loaderId?: Network.LoaderId;
             /**
@@ -12678,15 +14441,16 @@ export namespace Protocol {
              */
             marginRight?: number;
             /**
-             * Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means
-             * print all pages.
+             * Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are
+             * printed in the document order, not in the order specified, and no
+             * more than once.
+             * Defaults to empty string, which implies the entire document is printed.
+             * The page numbers are quietly capped to actual page count of the
+             * document, and ranges beyond the end of the document are ignored.
+             * If this results in no pages to print, an error is reported.
+             * It is an error to specify a range with start greater than end.
              */
             pageRanges?: string;
-            /**
-             * Whether to silently ignore invalid but successfully parsed page ranges, such as '3-2'.
-             * Defaults to false.
-             */
-            ignoreInvalidPageRanges?: boolean;
             /**
              * HTML template for the print header. Should be valid HTML markup with following
              * classes used to inject printing values into them:
@@ -12712,6 +14476,14 @@ export namespace Protocol {
              * return as stream (PrintToPDFRequestTransferMode enum)
              */
             transferMode?: ('ReturnAsBase64' | 'ReturnAsStream');
+            /**
+             * Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
+             */
+            generateTaggedPDF?: boolean;
+            /**
+             * Whether or not to embed the document outline into the PDF.
+             */
+            generateDocumentOutline?: boolean;
         }
 
         export interface PrintToPDFResponse {
@@ -12735,6 +14507,12 @@ export namespace Protocol {
              * Argument will be ignored if reloading dataURL origin.
              */
             scriptToEvaluateOnLoad?: string;
+            /**
+             * If set, an error will be thrown if the target page's main frame's
+             * loader id does not match the provided id. This prevents accidentally
+             * reloading an unintended target in case there's a racing navigation.
+             */
+            loaderId?: Network.LoaderId;
         }
 
         export interface RemoveScriptToEvaluateOnLoadRequest {
@@ -12884,6 +14662,10 @@ export namespace Protocol {
              * Specifies font families to set. If a font family is not specified, it won't be changed.
              */
             fontFamilies: FontFamilies;
+            /**
+             * Specifies font families to set for individual scripts.
+             */
+            forScripts?: ScriptFontFamilies[];
         }
 
         export interface SetFontSizesRequest {
@@ -13000,10 +14782,6 @@ export namespace Protocol {
             state: ('frozen' | 'active');
         }
 
-        export interface SetProduceCompilationCacheRequest {
-            enabled: boolean;
-        }
-
         export interface ProduceCompilationCacheRequest {
             scripts: CompilationCacheParams[];
         }
@@ -13016,6 +14794,14 @@ export namespace Protocol {
             data: string;
         }
 
+        export interface SetSPCTransactionModeRequest {
+            mode: AutoResponseMode;
+        }
+
+        export interface SetRPHRegistrationModeRequest {
+            mode: AutoResponseMode;
+        }
+
         export interface GenerateTestReportRequest {
             /**
              * Message to be displayed in the report.
@@ -13031,6 +14817,10 @@ export namespace Protocol {
             enabled: boolean;
         }
 
+        export interface SetPrerenderingAllowedRequest {
+            isAllowed: boolean;
+        }
+
         export interface DomContentEventFiredEvent {
             timestamp: Network.MonotonicTime;
         }
@@ -13048,14 +14838,14 @@ export namespace Protocol {
              * Id of the frame containing input node.
              */
             frameId: FrameId;
-            /**
-             * Input node id.
-             */
-            backendNodeId: DOM.BackendNodeId;
             /**
              * Input mode. (FileChooserOpenedEventMode enum)
              */
             mode: ('selectSingle' | 'selectMultiple');
+            /**
+             * Input node id. Only present for file choosers opened via an `<input type="file">` element.
+             */
+            backendNodeId?: DOM.BackendNodeId;
         }
 
         /**
@@ -13312,7 +15102,7 @@ export namespace Protocol {
          */
         export interface BackForwardCacheNotUsedEvent {
             /**
-             * The loader id for the associated navgation.
+             * The loader id for the associated navigation.
              */
             loaderId: Network.LoaderId;
             /**
@@ -13323,12 +15113,22 @@ export namespace Protocol {
              * Array of reasons why the page could not be cached. This must not be empty.
              */
             notRestoredExplanations: BackForwardCacheNotRestoredExplanation[];
+            /**
+             * Tree structure of reasons why the page could not be cached for each frame.
+             */
+            notRestoredExplanationsTree?: BackForwardCacheNotRestoredExplanationTree;
         }
 
         export interface LoadEventFiredEvent {
             timestamp: Network.MonotonicTime;
         }
 
+        export const enum NavigatedWithinDocumentEventNavigationType {
+            Fragment = 'fragment',
+            HistoryAPI = 'historyApi',
+            Other = 'other',
+        }
+
         /**
          * Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
          */
@@ -13341,6 +15141,10 @@ export namespace Protocol {
              * Frame's new url.
              */
             url: string;
+            /**
+             * Navigation type (NavigatedWithinDocumentEventNavigationType enum)
+             */
+            navigationType: ('fragment' | 'historyApi' | 'other');
         }
 
         /**
@@ -13522,7 +15326,7 @@ export namespace Protocol {
             frameId: Page.FrameId;
             /**
              * The event type, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
-             * This determines which of the optional "details" fiedls is present.
+             * This determines which of the optional "details" fields is present.
              */
             type: string;
             /**
@@ -13630,7 +15434,7 @@ export namespace Protocol {
              */
             certificateNetworkError?: string;
             /**
-             * True if the certificate uses a weak signature aglorithm.
+             * True if the certificate uses a weak signature algorithm.
              */
             certificateHasWeakSignature: boolean;
             /**
@@ -13825,7 +15629,7 @@ export namespace Protocol {
         }
 
         /**
-         * The security state of the page changed.
+         * The security state of the page changed. No longer being sent.
          */
         export interface SecurityStateChangedEvent {
             /**
@@ -13837,8 +15641,8 @@ export namespace Protocol {
              */
             schemeIsCryptographic: boolean;
             /**
-             * List of explanations for the security state. If the overall security state is `insecure` or
-             * `warning`, at least one corresponding explanation should be included.
+             * Previously a list of explanations for the security state. Now always
+             * empty.
              */
             explanations: SecurityStateExplanation[];
             /**
@@ -13846,7 +15650,7 @@ export namespace Protocol {
              */
             insecureContentStatus: InsecureContentStatus;
             /**
-             * Overrides user-visible description of the state.
+             * Overrides user-visible description of the state. Always omitted.
              */
             summary?: string;
         }
@@ -13889,6 +15693,7 @@ export namespace Protocol {
             scriptResponseTime?: number;
             controlledClients?: Target.TargetID[];
             targetId?: Target.TargetID;
+            routerRules?: string;
         }
 
         /**
@@ -13965,10 +15770,12 @@ export namespace Protocol {
 
     export namespace Storage {
 
+        export type SerializedStorageKey = string;
+
         /**
          * Enum of possible storage types.
          */
-        export type StorageType = ('appcache' | 'cookies' | 'file_systems' | 'indexeddb' | 'local_storage' | 'shader_cache' | 'websql' | 'service_workers' | 'cache_storage' | 'all' | 'other');
+        export type StorageType = ('appcache' | 'cookies' | 'file_systems' | 'indexeddb' | 'local_storage' | 'shader_cache' | 'websql' | 'service_workers' | 'cache_storage' | 'interest_groups' | 'shared_storage' | 'storage_buckets' | 'all' | 'other');
 
         /**
          * Usage for a storage type.
@@ -13993,49 +15800,401 @@ export namespace Protocol {
             count: number;
         }
 
-        export interface ClearDataForOriginRequest {
+        /**
+         * Protected audience interest group auction identifier.
+         */
+        export type InterestGroupAuctionId = string;
+
+        /**
+         * Enum of interest group access types.
+         */
+        export type InterestGroupAccessType = ('join' | 'leave' | 'update' | 'loaded' | 'bid' | 'win' | 'additionalBid' | 'additionalBidWin' | 'topLevelBid' | 'topLevelAdditionalBid' | 'clear');
+
+        /**
+         * Enum of auction events.
+         */
+        export type InterestGroupAuctionEventType = ('started' | 'configResolved');
+
+        /**
+         * Enum of network fetches auctions can do.
+         */
+        export type InterestGroupAuctionFetchType = ('bidderJs' | 'bidderWasm' | 'sellerJs' | 'bidderTrustedSignals' | 'sellerTrustedSignals');
+
+        /**
+         * Enum of shared storage access types.
+         */
+        export type SharedStorageAccessType = ('documentAddModule' | 'documentSelectURL' | 'documentRun' | 'documentSet' | 'documentAppend' | 'documentDelete' | 'documentClear' | 'documentGet' | 'workletSet' | 'workletAppend' | 'workletDelete' | 'workletClear' | 'workletGet' | 'workletKeys' | 'workletEntries' | 'workletLength' | 'workletRemainingBudget' | 'headerSet' | 'headerAppend' | 'headerDelete' | 'headerClear');
+
+        /**
+         * Struct for a single key-value pair in an origin's shared storage.
+         */
+        export interface SharedStorageEntry {
+            key: string;
+            value: string;
+        }
+
+        /**
+         * Details for an origin's shared storage.
+         */
+        export interface SharedStorageMetadata {
             /**
-             * Security origin.
+             * Time when the origin's shared storage was last created.
              */
-            origin: string;
+            creationTime: Network.TimeSinceEpoch;
             /**
-             * Comma separated list of StorageType to clear.
+             * Number of key-value pairs stored in origin's shared storage.
              */
-            storageTypes: string;
-        }
-
-        export interface GetCookiesRequest {
+            length: integer;
             /**
-             * Browser context to use when called on the browser endpoint.
+             * Current amount of bits of entropy remaining in the navigation budget.
              */
-            browserContextId?: Browser.BrowserContextID;
-        }
-
-        export interface GetCookiesResponse {
+            remainingBudget: number;
             /**
-             * Array of cookie objects.
+             * Total number of bytes stored as key-value pairs in origin's shared
+             * storage.
              */
-            cookies: Network.Cookie[];
+            bytesUsed: integer;
         }
 
-        export interface SetCookiesRequest {
+        /**
+         * Pair of reporting metadata details for a candidate URL for `selectURL()`.
+         */
+        export interface SharedStorageReportingMetadata {
+            eventType: string;
+            reportingUrl: string;
+        }
+
+        /**
+         * Bundles a candidate URL with its reporting metadata.
+         */
+        export interface SharedStorageUrlWithMetadata {
             /**
-             * Cookies to be set.
+             * Spec of candidate URL.
              */
-            cookies: Network.CookieParam[];
+            url: string;
             /**
-             * Browser context to use when called on the browser endpoint.
+             * Any associated reporting metadata.
              */
-            browserContextId?: Browser.BrowserContextID;
+            reportingMetadata: SharedStorageReportingMetadata[];
         }
 
-        export interface ClearCookiesRequest {
+        /**
+         * Bundles the parameters for shared storage access events whose
+         * presence/absence can vary according to SharedStorageAccessType.
+         */
+        export interface SharedStorageAccessParams {
             /**
-             * Browser context to use when called on the browser endpoint.
+             * Spec of the module script URL.
+             * Present only for SharedStorageAccessType.documentAddModule.
              */
-            browserContextId?: Browser.BrowserContextID;
-        }
-
+            scriptSourceUrl?: string;
+            /**
+             * Name of the registered operation to be run.
+             * Present only for SharedStorageAccessType.documentRun and
+             * SharedStorageAccessType.documentSelectURL.
+             */
+            operationName?: string;
+            /**
+             * The operation's serialized data in bytes (converted to a string).
+             * Present only for SharedStorageAccessType.documentRun and
+             * SharedStorageAccessType.documentSelectURL.
+             */
+            serializedData?: string;
+            /**
+             * Array of candidate URLs' specs, along with any associated metadata.
+             * Present only for SharedStorageAccessType.documentSelectURL.
+             */
+            urlsWithMetadata?: SharedStorageUrlWithMetadata[];
+            /**
+             * Key for a specific entry in an origin's shared storage.
+             * Present only for SharedStorageAccessType.documentSet,
+             * SharedStorageAccessType.documentAppend,
+             * SharedStorageAccessType.documentDelete,
+             * SharedStorageAccessType.workletSet,
+             * SharedStorageAccessType.workletAppend,
+             * SharedStorageAccessType.workletDelete,
+             * SharedStorageAccessType.workletGet,
+             * SharedStorageAccessType.headerSet,
+             * SharedStorageAccessType.headerAppend, and
+             * SharedStorageAccessType.headerDelete.
+             */
+            key?: string;
+            /**
+             * Value for a specific entry in an origin's shared storage.
+             * Present only for SharedStorageAccessType.documentSet,
+             * SharedStorageAccessType.documentAppend,
+             * SharedStorageAccessType.workletSet,
+             * SharedStorageAccessType.workletAppend,
+             * SharedStorageAccessType.headerSet, and
+             * SharedStorageAccessType.headerAppend.
+             */
+            value?: string;
+            /**
+             * Whether or not to set an entry for a key if that key is already present.
+             * Present only for SharedStorageAccessType.documentSet,
+             * SharedStorageAccessType.workletSet, and
+             * SharedStorageAccessType.headerSet.
+             */
+            ignoreIfPresent?: boolean;
+        }
+
+        export type StorageBucketsDurability = ('relaxed' | 'strict');
+
+        export interface StorageBucket {
+            storageKey: SerializedStorageKey;
+            /**
+             * If not specified, it is the default bucket of the storageKey.
+             */
+            name?: string;
+        }
+
+        export interface StorageBucketInfo {
+            bucket: StorageBucket;
+            id: string;
+            expiration: Network.TimeSinceEpoch;
+            /**
+             * Storage quota (bytes).
+             */
+            quota: number;
+            persistent: boolean;
+            durability: StorageBucketsDurability;
+        }
+
+        export type AttributionReportingSourceType = ('navigation' | 'event');
+
+        export type UnsignedInt64AsBase10 = string;
+
+        export type UnsignedInt128AsBase16 = string;
+
+        export type SignedInt64AsBase10 = string;
+
+        export interface AttributionReportingFilterDataEntry {
+            key: string;
+            values: string[];
+        }
+
+        export interface AttributionReportingFilterConfig {
+            filterValues: AttributionReportingFilterDataEntry[];
+            /**
+             * duration in seconds
+             */
+            lookbackWindow?: integer;
+        }
+
+        export interface AttributionReportingFilterPair {
+            filters: AttributionReportingFilterConfig[];
+            notFilters: AttributionReportingFilterConfig[];
+        }
+
+        export interface AttributionReportingAggregationKeysEntry {
+            key: string;
+            value: UnsignedInt128AsBase16;
+        }
+
+        export interface AttributionReportingEventReportWindows {
+            /**
+             * duration in seconds
+             */
+            start: integer;
+            /**
+             * duration in seconds
+             */
+            ends: integer[];
+        }
+
+        export interface AttributionReportingTriggerSpec {
+            /**
+             * number instead of integer because not all uint32 can be represented by
+             * int
+             */
+            triggerData: number[];
+            eventReportWindows: AttributionReportingEventReportWindows;
+        }
+
+        export type AttributionReportingTriggerDataMatching = ('exact' | 'modulus');
+
+        export interface AttributionReportingAggregatableDebugReportingData {
+            keyPiece: UnsignedInt128AsBase16;
+            /**
+             * number instead of integer because not all uint32 can be represented by
+             * int
+             */
+            value: number;
+            types: string[];
+        }
+
+        export interface AttributionReportingAggregatableDebugReportingConfig {
+            /**
+             * number instead of integer because not all uint32 can be represented by
+             * int, only present for source registrations
+             */
+            budget?: number;
+            keyPiece: UnsignedInt128AsBase16;
+            debugData: AttributionReportingAggregatableDebugReportingData[];
+            aggregationCoordinatorOrigin?: string;
+        }
+
+        export interface AttributionReportingSourceRegistration {
+            time: Network.TimeSinceEpoch;
+            /**
+             * duration in seconds
+             */
+            expiry: integer;
+            triggerSpecs: AttributionReportingTriggerSpec[];
+            /**
+             * duration in seconds
+             */
+            aggregatableReportWindow: integer;
+            type: AttributionReportingSourceType;
+            sourceOrigin: string;
+            reportingOrigin: string;
+            destinationSites: string[];
+            eventId: UnsignedInt64AsBase10;
+            priority: SignedInt64AsBase10;
+            filterData: AttributionReportingFilterDataEntry[];
+            aggregationKeys: AttributionReportingAggregationKeysEntry[];
+            debugKey?: UnsignedInt64AsBase10;
+            triggerDataMatching: AttributionReportingTriggerDataMatching;
+            destinationLimitPriority: SignedInt64AsBase10;
+            aggregatableDebugReportingConfig: AttributionReportingAggregatableDebugReportingConfig;
+        }
+
+        export type AttributionReportingSourceRegistrationResult = ('success' | 'internalError' | 'insufficientSourceCapacity' | 'insufficientUniqueDestinationCapacity' | 'excessiveReportingOrigins' | 'prohibitedByBrowserPolicy' | 'successNoised' | 'destinationReportingLimitReached' | 'destinationGlobalLimitReached' | 'destinationBothLimitsReached' | 'reportingOriginsPerSiteLimitReached' | 'exceedsMaxChannelCapacity' | 'exceedsMaxTriggerStateCardinality' | 'destinationPerDayReportingLimitReached');
+
+        export type AttributionReportingSourceRegistrationTimeConfig = ('include' | 'exclude');
+
+        export interface AttributionReportingAggregatableValueDictEntry {
+            key: string;
+            /**
+             * number instead of integer because not all uint32 can be represented by
+             * int
+             */
+            value: number;
+            filteringId: UnsignedInt64AsBase10;
+        }
+
+        export interface AttributionReportingAggregatableValueEntry {
+            values: AttributionReportingAggregatableValueDictEntry[];
+            filters: AttributionReportingFilterPair;
+        }
+
+        export interface AttributionReportingEventTriggerData {
+            data: UnsignedInt64AsBase10;
+            priority: SignedInt64AsBase10;
+            dedupKey?: UnsignedInt64AsBase10;
+            filters: AttributionReportingFilterPair;
+        }
+
+        export interface AttributionReportingAggregatableTriggerData {
+            keyPiece: UnsignedInt128AsBase16;
+            sourceKeys: string[];
+            filters: AttributionReportingFilterPair;
+        }
+
+        export interface AttributionReportingAggregatableDedupKey {
+            dedupKey?: UnsignedInt64AsBase10;
+            filters: AttributionReportingFilterPair;
+        }
+
+        export interface AttributionReportingTriggerRegistration {
+            filters: AttributionReportingFilterPair;
+            debugKey?: UnsignedInt64AsBase10;
+            aggregatableDedupKeys: AttributionReportingAggregatableDedupKey[];
+            eventTriggerData: AttributionReportingEventTriggerData[];
+            aggregatableTriggerData: AttributionReportingAggregatableTriggerData[];
+            aggregatableValues: AttributionReportingAggregatableValueEntry[];
+            aggregatableFilteringIdMaxBytes: integer;
+            debugReporting: boolean;
+            aggregationCoordinatorOrigin?: string;
+            sourceRegistrationTimeConfig: AttributionReportingSourceRegistrationTimeConfig;
+            triggerContextId?: string;
+            aggregatableDebugReportingConfig: AttributionReportingAggregatableDebugReportingConfig;
+        }
+
+        export type AttributionReportingEventLevelResult = ('success' | 'successDroppedLowerPriority' | 'internalError' | 'noCapacityForAttributionDestination' | 'noMatchingSources' | 'deduplicated' | 'excessiveAttributions' | 'priorityTooLow' | 'neverAttributedSource' | 'excessiveReportingOrigins' | 'noMatchingSourceFilterData' | 'prohibitedByBrowserPolicy' | 'noMatchingConfigurations' | 'excessiveReports' | 'falselyAttributedSource' | 'reportWindowPassed' | 'notRegistered' | 'reportWindowNotStarted' | 'noMatchingTriggerData');
+
+        export type AttributionReportingAggregatableResult = ('success' | 'internalError' | 'noCapacityForAttributionDestination' | 'noMatchingSources' | 'excessiveAttributions' | 'excessiveReportingOrigins' | 'noHistograms' | 'insufficientBudget' | 'noMatchingSourceFilterData' | 'notRegistered' | 'prohibitedByBrowserPolicy' | 'deduplicated' | 'reportWindowPassed' | 'excessiveReports');
+
+        /**
+         * A single Related Website Set object.
+         */
+        export interface RelatedWebsiteSet {
+            /**
+             * The primary site of this set, along with the ccTLDs if there is any.
+             */
+            primarySites: string[];
+            /**
+             * The associated sites of this set, along with the ccTLDs if there is any.
+             */
+            associatedSites: string[];
+            /**
+             * The service sites of this set, along with the ccTLDs if there is any.
+             */
+            serviceSites: string[];
+        }
+
+        export interface GetStorageKeyForFrameRequest {
+            frameId: Page.FrameId;
+        }
+
+        export interface GetStorageKeyForFrameResponse {
+            storageKey: SerializedStorageKey;
+        }
+
+        export interface ClearDataForOriginRequest {
+            /**
+             * Security origin.
+             */
+            origin: string;
+            /**
+             * Comma separated list of StorageType to clear.
+             */
+            storageTypes: string;
+        }
+
+        export interface ClearDataForStorageKeyRequest {
+            /**
+             * Storage key.
+             */
+            storageKey: string;
+            /**
+             * Comma separated list of StorageType to clear.
+             */
+            storageTypes: string;
+        }
+
+        export interface GetCookiesRequest {
+            /**
+             * Browser context to use when called on the browser endpoint.
+             */
+            browserContextId?: Browser.BrowserContextID;
+        }
+
+        export interface GetCookiesResponse {
+            /**
+             * Array of cookie objects.
+             */
+            cookies: Network.Cookie[];
+        }
+
+        export interface SetCookiesRequest {
+            /**
+             * Cookies to be set.
+             */
+            cookies: Network.CookieParam[];
+            /**
+             * Browser context to use when called on the browser endpoint.
+             */
+            browserContextId?: Browser.BrowserContextID;
+        }
+
+        export interface ClearCookiesRequest {
+            /**
+             * Browser context to use when called on the browser endpoint.
+             */
+            browserContextId?: Browser.BrowserContextID;
+        }
+
         export interface GetUsageAndQuotaRequest {
             /**
              * Security origin.
@@ -14086,6 +16245,13 @@ export namespace Protocol {
             origin: string;
         }
 
+        export interface TrackCacheStorageForStorageKeyRequest {
+            /**
+             * Storage key.
+             */
+            storageKey: string;
+        }
+
         export interface TrackIndexedDBForOriginRequest {
             /**
              * Security origin.
@@ -14093,6 +16259,13 @@ export namespace Protocol {
             origin: string;
         }
 
+        export interface TrackIndexedDBForStorageKeyRequest {
+            /**
+             * Storage key.
+             */
+            storageKey: string;
+        }
+
         export interface UntrackCacheStorageForOriginRequest {
             /**
              * Security origin.
@@ -14100,6 +16273,13 @@ export namespace Protocol {
             origin: string;
         }
 
+        export interface UntrackCacheStorageForStorageKeyRequest {
+            /**
+             * Storage key.
+             */
+            storageKey: string;
+        }
+
         export interface UntrackIndexedDBForOriginRequest {
             /**
              * Security origin.
@@ -14107,6 +16287,13 @@ export namespace Protocol {
             origin: string;
         }
 
+        export interface UntrackIndexedDBForStorageKeyRequest {
+            /**
+             * Storage key.
+             */
+            storageKey: string;
+        }
+
         export interface GetTrustTokensResponse {
             tokens: TrustTokens[];
         }
@@ -14122,6 +16309,108 @@ export namespace Protocol {
             didDeleteTokens: boolean;
         }
 
+        export interface GetInterestGroupDetailsRequest {
+            ownerOrigin: string;
+            name: string;
+        }
+
+        export interface GetInterestGroupDetailsResponse {
+            /**
+             * This largely corresponds to:
+             * https://wicg.github.io/turtledove/#dictdef-generatebidinterestgroup
+             * but has absolute expirationTime instead of relative lifetimeMs and
+             * also adds joiningOrigin.
+             */
+            details: any;
+        }
+
+        export interface SetInterestGroupTrackingRequest {
+            enable: boolean;
+        }
+
+        export interface SetInterestGroupAuctionTrackingRequest {
+            enable: boolean;
+        }
+
+        export interface GetSharedStorageMetadataRequest {
+            ownerOrigin: string;
+        }
+
+        export interface GetSharedStorageMetadataResponse {
+            metadata: SharedStorageMetadata;
+        }
+
+        export interface GetSharedStorageEntriesRequest {
+            ownerOrigin: string;
+        }
+
+        export interface GetSharedStorageEntriesResponse {
+            entries: SharedStorageEntry[];
+        }
+
+        export interface SetSharedStorageEntryRequest {
+            ownerOrigin: string;
+            key: string;
+            value: string;
+            /**
+             * If `ignoreIfPresent` is included and true, then only sets the entry if
+             * `key` doesn't already exist.
+             */
+            ignoreIfPresent?: boolean;
+        }
+
+        export interface DeleteSharedStorageEntryRequest {
+            ownerOrigin: string;
+            key: string;
+        }
+
+        export interface ClearSharedStorageEntriesRequest {
+            ownerOrigin: string;
+        }
+
+        export interface ResetSharedStorageBudgetRequest {
+            ownerOrigin: string;
+        }
+
+        export interface SetSharedStorageTrackingRequest {
+            enable: boolean;
+        }
+
+        export interface SetStorageBucketTrackingRequest {
+            storageKey: string;
+            enable: boolean;
+        }
+
+        export interface DeleteStorageBucketRequest {
+            bucket: StorageBucket;
+        }
+
+        export interface RunBounceTrackingMitigationsResponse {
+            deletedSites: string[];
+        }
+
+        export interface SetAttributionReportingLocalTestingModeRequest {
+            /**
+             * If enabled, noise is suppressed and reports are sent immediately.
+             */
+            enabled: boolean;
+        }
+
+        export interface SetAttributionReportingTrackingRequest {
+            enable: boolean;
+        }
+
+        export interface SendPendingAttributionReportsResponse {
+            /**
+             * The number of reports that were sent.
+             */
+            numSent: integer;
+        }
+
+        export interface GetRelatedWebsiteSetsResponse {
+            sets: RelatedWebsiteSet[];
+        }
+
         /**
          * A cache's contents have been modified.
          */
@@ -14130,6 +16419,14 @@ export namespace Protocol {
              * Origin to update.
              */
             origin: string;
+            /**
+             * Storage key to update.
+             */
+            storageKey: string;
+            /**
+             * Storage bucket to update.
+             */
+            bucketId: string;
             /**
              * Name of cache in origin.
              */
@@ -14144,6 +16441,14 @@ export namespace Protocol {
              * Origin to update.
              */
             origin: string;
+            /**
+             * Storage key to update.
+             */
+            storageKey: string;
+            /**
+             * Storage bucket to update.
+             */
+            bucketId: string;
         }
 
         /**
@@ -14154,6 +16459,14 @@ export namespace Protocol {
              * Origin to update.
              */
             origin: string;
+            /**
+             * Storage key to update.
+             */
+            storageKey: string;
+            /**
+             * Storage bucket to update.
+             */
+            bucketId: string;
             /**
              * Database to update.
              */
@@ -14172,13 +16485,128 @@ export namespace Protocol {
              * Origin to update.
              */
             origin: string;
+            /**
+             * Storage key to update.
+             */
+            storageKey: string;
+            /**
+             * Storage bucket to update.
+             */
+            bucketId: string;
         }
-    }
-
-    /**
-     * The SystemInfo domain defines methods and events for querying low-level system information.
-     */
-    export namespace SystemInfo {
+
+        /**
+         * One of the interest groups was accessed. Note that these events are global
+         * to all targets sharing an interest group store.
+         */
+        export interface InterestGroupAccessedEvent {
+            accessTime: Network.TimeSinceEpoch;
+            type: InterestGroupAccessType;
+            ownerOrigin: string;
+            name: string;
+            /**
+             * For topLevelBid/topLevelAdditionalBid, and when appropriate,
+             * win and additionalBidWin
+             */
+            componentSellerOrigin?: string;
+            /**
+             * For bid or somethingBid event, if done locally and not on a server.
+             */
+            bid?: number;
+            bidCurrency?: string;
+            /**
+             * For non-global events --- links to interestGroupAuctionEvent
+             */
+            uniqueAuctionId?: InterestGroupAuctionId;
+        }
+
+        /**
+         * An auction involving interest groups is taking place. These events are
+         * target-specific.
+         */
+        export interface InterestGroupAuctionEventOccurredEvent {
+            eventTime: Network.TimeSinceEpoch;
+            type: InterestGroupAuctionEventType;
+            uniqueAuctionId: InterestGroupAuctionId;
+            /**
+             * Set for child auctions.
+             */
+            parentAuctionId?: InterestGroupAuctionId;
+            /**
+             * Set for started and configResolved
+             */
+            auctionConfig?: any;
+        }
+
+        /**
+         * Specifies which auctions a particular network fetch may be related to, and
+         * in what role. Note that it is not ordered with respect to
+         * Network.requestWillBeSent (but will happen before loadingFinished
+         * loadingFailed).
+         */
+        export interface InterestGroupAuctionNetworkRequestCreatedEvent {
+            type: InterestGroupAuctionFetchType;
+            requestId: Network.RequestId;
+            /**
+             * This is the set of the auctions using the worklet that issued this
+             * request.  In the case of trusted signals, it's possible that only some of
+             * them actually care about the keys being queried.
+             */
+            auctions: InterestGroupAuctionId[];
+        }
+
+        /**
+         * Shared storage was accessed by the associated page.
+         * The following parameters are included in all events.
+         */
+        export interface SharedStorageAccessedEvent {
+            /**
+             * Time of the access.
+             */
+            accessTime: Network.TimeSinceEpoch;
+            /**
+             * Enum value indicating the Shared Storage API method invoked.
+             */
+            type: SharedStorageAccessType;
+            /**
+             * DevTools Frame Token for the primary frame tree's root.
+             */
+            mainFrameId: Page.FrameId;
+            /**
+             * Serialized origin for the context that invoked the Shared Storage API.
+             */
+            ownerOrigin: string;
+            /**
+             * The sub-parameters wrapped by `params` are all optional and their
+             * presence/absence depends on `type`.
+             */
+            params: SharedStorageAccessParams;
+        }
+
+        export interface StorageBucketCreatedOrUpdatedEvent {
+            bucketInfo: StorageBucketInfo;
+        }
+
+        export interface StorageBucketDeletedEvent {
+            bucketId: string;
+        }
+
+        export interface AttributionReportingSourceRegisteredEvent {
+            registration: AttributionReportingSourceRegistration;
+            result: AttributionReportingSourceRegistrationResult;
+        }
+
+        export interface AttributionReportingTriggerRegisteredEvent {
+            registration: AttributionReportingTriggerRegistration;
+            eventLevel: AttributionReportingEventLevelResult;
+            aggregatable: AttributionReportingAggregatableResult;
+        }
+    }
+
+    /**
+     * The SystemInfo domain defines methods and events for querying low-level system information.
+     */
+    export namespace SystemInfo {
 
         /**
          * Describes a single graphics processor (GPU).
@@ -14381,6 +16809,14 @@ export namespace Protocol {
             commandLine: string;
         }
 
+        export interface GetFeatureStateRequest {
+            featureState: string;
+        }
+
+        export interface GetFeatureStateResponse {
+            featureEnabled: boolean;
+        }
+
         export interface GetProcessInfoResponse {
             /**
              * An array of process info blocks.
@@ -14403,6 +16839,9 @@ export namespace Protocol {
 
         export interface TargetInfo {
             targetId: TargetID;
+            /**
+             * List of types: https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/devtools_agent_host_impl.cc?ss=chromium&q=f:devtools%20-f:out%20%22::kTypeTab%5B%5D%22
+             */
             type: string;
             title: string;
             url: string;
@@ -14423,8 +16862,37 @@ export namespace Protocol {
              */
             openerFrameId?: Page.FrameId;
             browserContextId?: Browser.BrowserContextID;
+            /**
+             * Provides additional details for specific target types. For example, for
+             * the type of "page", this may be set to "prerender".
+             */
+            subtype?: string;
+        }
+
+        /**
+         * A filter used by target query/discovery/auto-attach operations.
+         */
+        export interface FilterEntry {
+            /**
+             * If set, causes exclusion of matching targets from the list.
+             */
+            exclude?: boolean;
+            /**
+             * If not present, matches any type.
+             */
+            type?: string;
         }
 
+        /**
+         * The entries in TargetFilter are matched sequentially against targets and
+         * the first entry that matches determines if the target is included or not,
+         * depending on the value of `exclude` field in the entry.
+         * If filter is not specified, the one assumed is
+         * [{type: "browser", exclude: true}, {type: "tab", exclude: true}, {}]
+         * (i.e. include everything but `browser` and `tab`).
+         */
+        export type TargetFilter = FilterEntry[];
+
         export interface RemoteLocation {
             host: string;
             port: integer;
@@ -14490,6 +16958,11 @@ export namespace Protocol {
              * Proxy bypass list, similar to the one passed to --proxy-bypass-list
              */
             proxyBypassList?: string;
+            /**
+             * An optional list of origins to grant unlimited cross-origin access to.
+             * Parts of the URL other than those constituting origin are ignored.
+             */
+            originsWithUniversalNetworkAccess?: string[];
         }
 
         export interface CreateBrowserContextResponse {
@@ -14537,6 +17010,10 @@ export namespace Protocol {
              * false by default).
              */
             background?: boolean;
+            /**
+             * Whether to create the target of type "tab".
+             */
+            forTab?: boolean;
         }
 
         export interface CreateTargetResponse {
@@ -14569,6 +17046,15 @@ export namespace Protocol {
             targetInfo: TargetInfo;
         }
 
+        export interface GetTargetsRequest {
+            /**
+             * Only targets matching filter will be reported. If filter is not specified
+             * and target discovery is currently enabled, a filter used for target discovery
+             * is used for consistency.
+             */
+            filter?: TargetFilter;
+        }
+
         export interface GetTargetsResponse {
             /**
              * The list of targets.
@@ -14604,6 +17090,10 @@ export namespace Protocol {
              * and eventually retire it. See crbug.com/991325.
              */
             flatten?: boolean;
+            /**
+             * Only targets matching filter will be attached.
+             */
+            filter?: TargetFilter;
         }
 
         export interface AutoAttachRelatedRequest {
@@ -14613,6 +17103,10 @@ export namespace Protocol {
              * to run paused targets.
              */
             waitForDebuggerOnStart: boolean;
+            /**
+             * Only targets matching filter will be attached.
+             */
+            filter?: TargetFilter;
         }
 
         export interface SetDiscoverTargetsRequest {
@@ -14620,6 +17114,11 @@ export namespace Protocol {
              * Whether to discover available targets.
              */
             discover: boolean;
+            /**
+             * Only targets matching filter will be attached. If `discover` is false,
+             * `filter` must be omitted or empty.
+             */
+            filter?: TargetFilter;
         }
 
         export interface SetRemoteLocationsRequest {
@@ -14765,6 +17264,11 @@ export namespace Protocol {
              * Controls how the trace buffer stores data. (TraceConfigRecordMode enum)
              */
             recordMode?: ('recordUntilFull' | 'recordContinuously' | 'recordAsMuchAsPossible' | 'echoToConsole');
+            /**
+             * Size of the trace buffer in kilobytes. If not specified or zero is passed, a default value
+             * of 200 MB would be used.
+             */
+            traceBufferSizeInKb?: number;
             /**
              * Turns on JavaScript stack sampling.
              */
@@ -14922,8 +17426,8 @@ export namespace Protocol {
         }
 
         /**
-         * Contains an bucket of collected trace events. When tracing is stopped collected events will be
-         * send as a sequence of dataCollected events followed by tracingComplete event.
+         * Contains a bucket of collected trace events. When tracing is stopped collected events will be
+         * sent as a sequence of dataCollected events followed by tracingComplete event.
          */
         export interface DataCollectedEvent {
             value: any[];
@@ -15126,7 +17630,9 @@ export namespace Protocol {
              */
             postData?: string;
             /**
-             * If set, overrides the request headers.
+             * If set, overrides the request headers. Note that the overrides do not
+             * extend to subsequent redirect hops, if a redirect happens. Another override
+             * may be applied to a different request produced by a redirect.
              */
             headers?: HeaderEntry[];
             /**
@@ -15206,6 +17712,11 @@ export namespace Protocol {
          * The stage of the request can be determined by presence of responseErrorReason
          * and responseStatusCode -- the request is at the response stage if either
          * of these fields is present and in the request stage otherwise.
+         * Redirect responses and subsequent requests are reported similarly to regular
+         * responses and requests. Redirect responses may be distinguished by the value
+         * of `responseStatusCode` (which is one of 301, 302, 303, 307, 308) along with
+         * presence of the `location` header. Requests resulting from a redirect will
+         * have `redirectedRequestId` field set.
          */
         export interface RequestPausedEvent {
             /**
@@ -15244,7 +17755,12 @@ export namespace Protocol {
              * If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,
              * then this networkId will be the same as the requestId present in the requestWillBeSent event.
              */
-            networkId?: RequestId;
+            networkId?: Network.RequestId;
+            /**
+             * If the request is due to a redirect response from the server, the id of the request that
+             * has caused the redirect.
+             */
+            redirectedRequestId?: RequestId;
         }
 
         /**
@@ -15564,6 +18080,18 @@ export namespace Protocol {
              * Defaults to false.
              */
             hasCredBlob?: boolean;
+            /**
+             * If set to true, the authenticator will support the minPinLength extension.
+             * https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#sctn-minpinlength-extension
+             * Defaults to false.
+             */
+            hasMinPinLength?: boolean;
+            /**
+             * If set to true, the authenticator will support the prf extension.
+             * https://w3c.github.io/webauthn/#prf-extension
+             * Defaults to false.
+             */
+            hasPrf?: boolean;
             /**
              * If set to true, tests of user presence will succeed immediately.
              * Otherwise, they will not be resolved. Defaults to true.
@@ -15574,6 +18102,18 @@ export namespace Protocol {
              * Defaults to false.
              */
             isUserVerified?: boolean;
+            /**
+             * Credentials created by this authenticator will have the backup
+             * eligibility (BE) flag set to this value. Defaults to false.
+             * https://w3c.github.io/webauthn/#sctn-credential-backup
+             */
+            defaultBackupEligibility?: boolean;
+            /**
+             * Credentials created by this authenticator will have the backup state
+             * (BS) flag set to this value. Defaults to false.
+             * https://w3c.github.io/webauthn/#sctn-credential-backup
+             */
+            defaultBackupState?: boolean;
         }
 
         export interface Credential {
@@ -15604,6 +18144,29 @@ export namespace Protocol {
              * See https://w3c.github.io/webauthn/#sctn-large-blob-extension (Encoded as a base64 string when passed over JSON)
              */
             largeBlob?: string;
+            /**
+             * Assertions returned by this credential will have the backup eligibility
+             * (BE) flag set to this value. Defaults to the authenticator's
+             * defaultBackupEligibility value.
+             */
+            backupEligibility?: boolean;
+            /**
+             * Assertions returned by this credential will have the backup state (BS)
+             * flag set to this value. Defaults to the authenticator's
+             * defaultBackupState value.
+             */
+            backupState?: boolean;
+        }
+
+        export interface EnableRequest {
+            /**
+             * Whether to enable the WebAuthn user interface. Enabling the UI is
+             * recommended for debugging and demo purposes, as it is closer to the real
+             * experience. Disabling the UI is recommended for automated testing.
+             * Supported at the embedder's discretion if UI is available.
+             * Defaults to false.
+             */
+            enableUI?: boolean;
         }
 
         export interface AddVirtualAuthenticatorRequest {
@@ -15614,6 +18177,25 @@ export namespace Protocol {
             authenticatorId: AuthenticatorId;
         }
 
+        export interface SetResponseOverrideBitsRequest {
+            authenticatorId: AuthenticatorId;
+            /**
+             * If isBogusSignature is set, overrides the signature in the authenticator response to be zero.
+             * Defaults to false.
+             */
+            isBogusSignature?: boolean;
+            /**
+             * If isBadUV is set, overrides the UV bit in the flags in the authenticator response to
+             * be zero. Defaults to false.
+             */
+            isBadUV?: boolean;
+            /**
+             * If isBadUP is set, overrides the UP bit in the flags in the authenticator response to
+             * be zero. Defaults to false.
+             */
+            isBadUP?: boolean;
+        }
+
         export interface RemoveVirtualAuthenticatorRequest {
             authenticatorId: AuthenticatorId;
         }
@@ -15658,6 +18240,29 @@ export namespace Protocol {
             authenticatorId: AuthenticatorId;
             enabled: boolean;
         }
+
+        export interface SetCredentialPropertiesRequest {
+            authenticatorId: AuthenticatorId;
+            credentialId: string;
+            backupEligibility?: boolean;
+            backupState?: boolean;
+        }
+
+        /**
+         * Triggered when a credential is added to an authenticator.
+         */
+        export interface CredentialAddedEvent {
+            authenticatorId: AuthenticatorId;
+            credential: Credential;
+        }
+
+        /**
+         * Triggered when a credential is used in a webauthn assertion.
+         */
+        export interface CredentialAssertedEvent {
+            authenticatorId: AuthenticatorId;
+            credential: Credential;
+        }
     }
 
     /**
@@ -15715,27 +18320,38 @@ export namespace Protocol {
             value: string;
         }
 
-        export const enum PlayerErrorType {
-            Pipeline_error = 'pipeline_error',
-            Media_error = 'media_error',
+        /**
+         * Represents logged source line numbers reported in an error.
+         * NOTE: file and line are from chromium c++ implementation code, not js.
+         */
+        export interface PlayerErrorSourceLocation {
+            file: string;
+            line: integer;
         }
 
         /**
          * Corresponds to kMediaError
          */
         export interface PlayerError {
+            errorType: string;
+            /**
+             * Code is the numeric enum entry for a specific set of error codes, such
+             * as PipelineStatusCodes in media/base/pipeline_status.h
+             */
+            code: integer;
+            /**
+             * A trace of where this error was caused / where it passed through.
+             */
+            stack: PlayerErrorSourceLocation[];
             /**
-             *  (PlayerErrorType enum)
+             * Errors potentially have a root cause error, ie, a DecoderError might be
+             * caused by an WindowsError
              */
-            type: ('pipeline_error' | 'media_error');
+            cause: PlayerError[];
             /**
-             * When this switches to using media::Status instead of PipelineStatus
-             * we can remove "errorCode" and replace it with the fields from
-             * a Status instance. This also seems like a duplicate of the error
-             * level enum - there is a todo bug to have that level removed and
-             * use this instead. (crbug.com/1068454)
+             * Extra data attached to an error, such as an HRESULT, Video Codec, etc.
              */
-            errorCode: string;
+            data: any;
         }
 
         /**
@@ -15781,6 +18397,506 @@ export namespace Protocol {
             players: PlayerId[];
         }
     }
+
+    export namespace DeviceAccess {
+
+        /**
+         * Device request id.
+         */
+        export type RequestId = string;
+
+        /**
+         * A device id.
+         */
+        export type DeviceId = string;
+
+        /**
+         * Device information displayed in a user prompt to select a device.
+         */
+        export interface PromptDevice {
+            id: DeviceId;
+            /**
+             * Display name as it appears in a device request user prompt.
+             */
+            name: string;
+        }
+
+        export interface SelectPromptRequest {
+            id: RequestId;
+            deviceId: DeviceId;
+        }
+
+        export interface CancelPromptRequest {
+            id: RequestId;
+        }
+
+        /**
+         * A device request opened a user prompt to select a device. Respond with the
+         * selectPrompt or cancelPrompt command.
+         */
+        export interface DeviceRequestPromptedEvent {
+            id: RequestId;
+            devices: PromptDevice[];
+        }
+    }
+
+    export namespace Preload {
+
+        /**
+         * Unique id
+         */
+        export type RuleSetId = string;
+
+        /**
+         * Corresponds to SpeculationRuleSet
+         */
+        export interface RuleSet {
+            id: RuleSetId;
+            /**
+             * Identifies a document which the rule set is associated with.
+             */
+            loaderId: Network.LoaderId;
+            /**
+             * Source text of JSON representing the rule set. If it comes from
+             * `<script>` tag, it is the textContent of the node. Note that it is
+             * a JSON for valid case.
+             * 
+             * See also:
+             * - https://wicg.github.io/nav-speculation/speculation-rules.html
+             * - https://github.com/WICG/nav-speculation/blob/main/triggers.md
+             */
+            sourceText: string;
+            /**
+             * A speculation rule set is either added through an inline
+             * `<script>` tag or through an external resource via the
+             * 'Speculation-Rules' HTTP header. For the first case, we include
+             * the BackendNodeId of the relevant `<script>` tag. For the second
+             * case, we include the external URL where the rule set was loaded
+             * from, and also RequestId if Network domain is enabled.
+             * 
+             * See also:
+             * - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-script
+             * - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-header
+             */
+            backendNodeId?: DOM.BackendNodeId;
+            url?: string;
+            requestId?: Network.RequestId;
+            /**
+             * Error information
+             * `errorMessage` is null iff `errorType` is null.
+             */
+            errorType?: RuleSetErrorType;
+            /**
+             * TODO(https://crbug.com/1425354): Replace this property with structured error.
+             */
+            errorMessage?: string;
+        }
+
+        export type RuleSetErrorType = ('SourceIsNotJsonObject' | 'InvalidRulesSkipped');
+
+        /**
+         * The type of preloading attempted. It corresponds to
+         * mojom::SpeculationAction (although PrefetchWithSubresources is omitted as it
+         * isn't being used by clients).
+         */
+        export type SpeculationAction = ('Prefetch' | 'Prerender');
+
+        /**
+         * Corresponds to mojom::SpeculationTargetHint.
+         * See https://github.com/WICG/nav-speculation/blob/main/triggers.md#window-name-targeting-hints
+         */
+        export type SpeculationTargetHint = ('Blank' | 'Self');
+
+        /**
+         * A key that identifies a preloading attempt.
+         * 
+         * The url used is the url specified by the trigger (i.e. the initial URL), and
+         * not the final url that is navigated to. For example, prerendering allows
+         * same-origin main frame navigations during the attempt, but the attempt is
+         * still keyed with the initial URL.
+         */
+        export interface PreloadingAttemptKey {
+            loaderId: Network.LoaderId;
+            action: SpeculationAction;
+            url: string;
+            targetHint?: SpeculationTargetHint;
+        }
+
+        /**
+         * Lists sources for a preloading attempt, specifically the ids of rule sets
+         * that had a speculation rule that triggered the attempt, and the
+         * BackendNodeIds of <a href> or <area href> elements that triggered the
+         * attempt (in the case of attempts triggered by a document rule). It is
+         * possible for multiple rule sets and links to trigger a single attempt.
+         */
+        export interface PreloadingAttemptSource {
+            key: PreloadingAttemptKey;
+            ruleSetIds: RuleSetId[];
+            nodeIds: DOM.BackendNodeId[];
+        }
+
+        /**
+         * List of FinalStatus reasons for Prerender2.
+         */
+        export type PrerenderFinalStatus = ('Activated' | 'Destroyed' | 'LowEndDevice' | 'InvalidSchemeRedirect' | 'InvalidSchemeNavigation' | 'NavigationRequestBlockedByCsp' | 'MainFrameNavigation' | 'MojoBinderPolicy' | 'RendererProcessCrashed' | 'RendererProcessKilled' | 'Download' | 'TriggerDestroyed' | 'NavigationNotCommitted' | 'NavigationBadHttpStatus' | 'ClientCertRequested' | 'NavigationRequestNetworkError' | 'CancelAllHostsForTesting' | 'DidFailLoad' | 'Stop' | 'SslCertificateError' | 'LoginAuthRequested' | 'UaChangeRequiresReload' | 'BlockedByClient' | 'AudioOutputDeviceRequested' | 'MixedContent' | 'TriggerBackgrounded' | 'MemoryLimitExceeded' | 'DataSaverEnabled' | 'TriggerUrlHasEffectiveUrl' | 'ActivatedBeforeStarted' | 'InactivePageRestriction' | 'StartFailed' | 'TimeoutBackgrounded' | 'CrossSiteRedirectInInitialNavigation' | 'CrossSiteNavigationInInitialNavigation' | 'SameSiteCrossOriginRedirectNotOptInInInitialNavigation' | 'SameSiteCrossOriginNavigationNotOptInInInitialNavigation' | 'ActivationNavigationParameterMismatch' | 'ActivatedInBackground' | 'EmbedderHostDisallowed' | 'ActivationNavigationDestroyedBeforeSuccess' | 'TabClosedByUserGesture' | 'TabClosedWithoutUserGesture' | 'PrimaryMainFrameRendererProcessCrashed' | 'PrimaryMainFrameRendererProcessKilled' | 'ActivationFramePolicyNotCompatible' | 'PreloadingDisabled' | 'BatterySaverEnabled' | 'ActivatedDuringMainFrameNavigation' | 'PreloadingUnsupportedByWebContents' | 'CrossSiteRedirectInMainFrameNavigation' | 'CrossSiteNavigationInMainFrameNavigation' | 'SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation' | 'SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation' | 'MemoryPressureOnTrigger' | 'MemoryPressureAfterTriggered' | 'PrerenderingDisabledByDevTools' | 'SpeculationRuleRemoved' | 'ActivatedWithAuxiliaryBrowsingContexts' | 'MaxNumOfRunningEagerPrerendersExceeded' | 'MaxNumOfRunningNonEagerPrerendersExceeded' | 'MaxNumOfRunningEmbedderPrerendersExceeded' | 'PrerenderingUrlHasEffectiveUrl' | 'RedirectedPrerenderingUrlHasEffectiveUrl' | 'ActivationUrlHasEffectiveUrl' | 'JavaScriptInterfaceAdded' | 'JavaScriptInterfaceRemoved' | 'AllPrerenderingCanceled' | 'WindowClosed' | 'SlowNetwork' | 'OtherPrerenderedPageActivated');
+
+        /**
+         * Preloading status values, see also PreloadingTriggeringOutcome. This
+         * status is shared by prefetchStatusUpdated and prerenderStatusUpdated.
+         */
+        export type PreloadingStatus = ('Pending' | 'Running' | 'Ready' | 'Success' | 'Failure' | 'NotSupported');
+
+        /**
+         * TODO(https://crbug.com/1384419): revisit the list of PrefetchStatus and
+         * filter out the ones that aren't necessary to the developers.
+         */
+        export type PrefetchStatus = ('PrefetchAllowed' | 'PrefetchFailedIneligibleRedirect' | 'PrefetchFailedInvalidRedirect' | 'PrefetchFailedMIMENotSupported' | 'PrefetchFailedNetError' | 'PrefetchFailedNon2XX' | 'PrefetchFailedPerPageLimitExceeded' | 'PrefetchEvictedAfterCandidateRemoved' | 'PrefetchEvictedForNewerPrefetch' | 'PrefetchHeldback' | 'PrefetchIneligibleRetryAfter' | 'PrefetchIsPrivacyDecoy' | 'PrefetchIsStale' | 'PrefetchNotEligibleBrowserContextOffTheRecord' | 'PrefetchNotEligibleDataSaverEnabled' | 'PrefetchNotEligibleExistingProxy' | 'PrefetchNotEligibleHostIsNonUnique' | 'PrefetchNotEligibleNonDefaultStoragePartition' | 'PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy' | 'PrefetchNotEligibleSchemeIsNotHttps' | 'PrefetchNotEligibleUserHasCookies' | 'PrefetchNotEligibleUserHasServiceWorker' | 'PrefetchNotEligibleBatterySaverEnabled' | 'PrefetchNotEligiblePreloadingDisabled' | 'PrefetchNotFinishedInTime' | 'PrefetchNotStarted' | 'PrefetchNotUsedCookiesChanged' | 'PrefetchProxyNotAvailable' | 'PrefetchResponseUsed' | 'PrefetchSuccessfulButNotUsed' | 'PrefetchNotUsedProbeFailed');
+
+        /**
+         * Information of headers to be displayed when the header mismatch occurred.
+         */
+        export interface PrerenderMismatchedHeaders {
+            headerName: string;
+            initialValue?: string;
+            activationValue?: string;
+        }
+
+        /**
+         * Upsert. Currently, it is only emitted when a rule set added.
+         */
+        export interface RuleSetUpdatedEvent {
+            ruleSet: RuleSet;
+        }
+
+        export interface RuleSetRemovedEvent {
+            id: RuleSetId;
+        }
+
+        /**
+         * Fired when a preload enabled state is updated.
+         */
+        export interface PreloadEnabledStateUpdatedEvent {
+            disabledByPreference: boolean;
+            disabledByDataSaver: boolean;
+            disabledByBatterySaver: boolean;
+            disabledByHoldbackPrefetchSpeculationRules: boolean;
+            disabledByHoldbackPrerenderSpeculationRules: boolean;
+        }
+
+        /**
+         * Fired when a prefetch attempt is updated.
+         */
+        export interface PrefetchStatusUpdatedEvent {
+            key: PreloadingAttemptKey;
+            /**
+             * The frame id of the frame initiating prefetch.
+             */
+            initiatingFrameId: Page.FrameId;
+            prefetchUrl: string;
+            status: PreloadingStatus;
+            prefetchStatus: PrefetchStatus;
+            requestId: Network.RequestId;
+        }
+
+        /**
+         * Fired when a prerender attempt is updated.
+         */
+        export interface PrerenderStatusUpdatedEvent {
+            key: PreloadingAttemptKey;
+            status: PreloadingStatus;
+            prerenderStatus?: PrerenderFinalStatus;
+            /**
+             * This is used to give users more information about the name of Mojo interface
+             * that is incompatible with prerender and has caused the cancellation of the attempt.
+             */
+            disallowedMojoInterface?: string;
+            mismatchedHeaders?: PrerenderMismatchedHeaders[];
+        }
+
+        /**
+         * Send a list of sources for all preloading attempts in a document.
+         */
+        export interface PreloadingAttemptSourcesUpdatedEvent {
+            loaderId: Network.LoaderId;
+            preloadingAttemptSources: PreloadingAttemptSource[];
+        }
+    }
+
+    /**
+     * This domain allows interacting with the FedCM dialog.
+     */
+    export namespace FedCm {
+
+        /**
+         * Whether this is a sign-up or sign-in action for this account, i.e.
+         * whether this account has ever been used to sign in to this RP before.
+         */
+        export type LoginState = ('SignIn' | 'SignUp');
+
+        /**
+         * The types of FedCM dialogs.
+         */
+        export type DialogType = ('AccountChooser' | 'AutoReauthn' | 'ConfirmIdpLogin' | 'Error');
+
+        /**
+         * The buttons on the FedCM dialog.
+         */
+        export type DialogButton = ('ConfirmIdpLoginContinue' | 'ErrorGotIt' | 'ErrorMoreDetails');
+
+        /**
+         * The URLs that each account has
+         */
+        export type AccountUrlType = ('TermsOfService' | 'PrivacyPolicy');
+
+        /**
+         * Corresponds to IdentityRequestAccount
+         */
+        export interface Account {
+            accountId: string;
+            email: string;
+            name: string;
+            givenName: string;
+            pictureUrl: string;
+            idpConfigUrl: string;
+            idpLoginUrl: string;
+            loginState: LoginState;
+            /**
+             * These two are only set if the loginState is signUp
+             */
+            termsOfServiceUrl?: string;
+            privacyPolicyUrl?: string;
+        }
+
+        export interface EnableRequest {
+            /**
+             * Allows callers to disable the promise rejection delay that would
+             * normally happen, if this is unimportant to what's being tested.
+             * (step 4 of https://fedidcg.github.io/FedCM/#browser-api-rp-sign-in)
+             */
+            disableRejectionDelay?: boolean;
+        }
+
+        export interface SelectAccountRequest {
+            dialogId: string;
+            accountIndex: integer;
+        }
+
+        export interface ClickDialogButtonRequest {
+            dialogId: string;
+            dialogButton: DialogButton;
+        }
+
+        export interface OpenUrlRequest {
+            dialogId: string;
+            accountIndex: integer;
+            accountUrlType: AccountUrlType;
+        }
+
+        export interface DismissDialogRequest {
+            dialogId: string;
+            triggerCooldown?: boolean;
+        }
+
+        export interface DialogShownEvent {
+            dialogId: string;
+            dialogType: DialogType;
+            accounts: Account[];
+            /**
+             * These exist primarily so that the caller can verify the
+             * RP context was used appropriately.
+             */
+            title: string;
+            subtitle?: string;
+        }
+
+        /**
+         * Triggered when a dialog is closed, either by user action, JS abort,
+         * or a command below.
+         */
+        export interface DialogClosedEvent {
+            dialogId: string;
+        }
+    }
+
+    /**
+     * This domain allows interacting with the browser to control PWAs.
+     */
+    export namespace PWA {
+
+        /**
+         * The following types are the replica of
+         * https://crsrc.org/c/chrome/browser/web_applications/proto/web_app_os_integration_state.proto;drc=9910d3be894c8f142c977ba1023f30a656bc13fc;l=67
+         */
+        export interface FileHandlerAccept {
+            /**
+             * New name of the mimetype according to
+             * https://www.iana.org/assignments/media-types/media-types.xhtml
+             */
+            mediaType: string;
+            fileExtensions: string[];
+        }
+
+        export interface FileHandler {
+            action: string;
+            accepts: FileHandlerAccept[];
+            displayName: string;
+        }
+
+        /**
+         * If user prefers opening the app in browser or an app window.
+         */
+        export type DisplayMode = ('standalone' | 'browser');
+
+        export interface GetOsAppStateRequest {
+            /**
+             * The id from the webapp's manifest file, commonly it's the url of the
+             * site installing the webapp. See
+             * https://web.dev/learn/pwa/web-app-manifest.
+             */
+            manifestId: string;
+        }
+
+        export interface GetOsAppStateResponse {
+            badgeCount: integer;
+            fileHandlers: FileHandler[];
+        }
+
+        export interface InstallRequest {
+            manifestId: string;
+            /**
+             * The location of the app or bundle overriding the one derived from the
+             * manifestId.
+             */
+            installUrlOrBundleUrl?: string;
+        }
+
+        export interface UninstallRequest {
+            manifestId: string;
+        }
+
+        export interface LaunchRequest {
+            manifestId: string;
+            url?: string;
+        }
+
+        export interface LaunchResponse {
+            /**
+             * ID of the tab target created as a result.
+             */
+            targetId: Target.TargetID;
+        }
+
+        export interface LaunchFilesInAppRequest {
+            manifestId: string;
+            files: string[];
+        }
+
+        export interface LaunchFilesInAppResponse {
+            /**
+             * IDs of the tab targets created as the result.
+             */
+            targetIds: Target.TargetID[];
+        }
+
+        export interface OpenCurrentPageInAppRequest {
+            manifestId: string;
+        }
+
+        export interface ChangeAppUserSettingsRequest {
+            manifestId: string;
+            /**
+             * If user allows the links clicked on by the user in the app's scope, or
+             * extended scope if the manifest has scope extensions and the flags
+             * `DesktopPWAsLinkCapturingWithScopeExtensions` and
+             * `WebAppEnableScopeExtensions` are enabled.
+             * 
+             * Note, the API does not support resetting the linkCapturing to the
+             * initial value, uninstalling and installing the web app again will reset
+             * it.
+             * 
+             * TODO(crbug.com/339453269): Setting this value on ChromeOS is not
+             * supported yet.
+             */
+            linkCapturing?: boolean;
+            displayMode?: DisplayMode;
+        }
+    }
+
+    /**
+     * This domain allows configuring virtual Bluetooth devices to test
+     * the web-bluetooth API.
+     */
+    export namespace BluetoothEmulation {
+
+        /**
+         * Indicates the various states of Central.
+         */
+        export type CentralState = ('absent' | 'powered-off' | 'powered-on');
+
+        /**
+         * Stores the manufacturer data
+         */
+        export interface ManufacturerData {
+            /**
+             * Company identifier
+             * https://bitbucket.org/bluetooth-SIG/public/src/main/assigned_numbers/company_identifiers/company_identifiers.yaml
+             * https://usb.org/developers
+             */
+            key: integer;
+            /**
+             * Manufacturer-specific data (Encoded as a base64 string when passed over JSON)
+             */
+            data: string;
+        }
+
+        /**
+         * Stores the byte data of the advertisement packet sent by a Bluetooth device.
+         */
+        export interface ScanRecord {
+            name?: string;
+            uuids?: string[];
+            /**
+             * Stores the external appearance description of the device.
+             */
+            appearance?: integer;
+            /**
+             * Stores the transmission power of a broadcasting device.
+             */
+            txPower?: integer;
+            /**
+             * Key is the company identifier and the value is an array of bytes of
+             * manufacturer specific data.
+             */
+            manufacturerData?: ManufacturerData[];
+        }
+
+        /**
+         * Stores the advertisement packet information that is sent by a Bluetooth device.
+         */
+        export interface ScanEntry {
+            deviceAddress: string;
+            rssi: integer;
+            scanRecord: ScanRecord;
+        }
+
+        export interface EnableRequest {
+            /**
+             * State of the simulated central.
+             */
+            state: CentralState;
+        }
+
+        export interface SimulatePreconnectedPeripheralRequest {
+            address: string;
+            name: string;
+            manufacturerData: ManufacturerData[];
+            knownServiceUuids: string[];
+        }
+
+        export interface SimulateAdvertisementRequest {
+            entry: ScanEntry;
+        }
+    }
 }
 
 export default Protocol;
